<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>一种服务器推送技术-WebSocket</title>
      <link href="/2020/07/24/%E4%B8%80%E7%A7%8D%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A8%E9%80%81%E6%8A%80%E6%9C%AF-WebSocket/"/>
      <url>/2020/07/24/%E4%B8%80%E7%A7%8D%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A8%E9%80%81%E6%8A%80%E6%9C%AF-WebSocket/</url>
      
        <content type="html"><![CDATA[<h1 id="为何要用-WebSocket"><a href="#为何要用-WebSocket" class="headerlink" title="为何要用 WebSocket"></a>为何要用 WebSocket</h1><p>HTTP 协议遵循经典的客户端-服务器模型，客户端发送一个请求，然后等待服务器端的响应，服务器端只能在接收到客户端的请求之后进行响应，不能主动的发送数据到客户端。</p><p>客户端想要在不刷新页面的情况下实时获取到服务器端最新的数据，可以通过以下途径:</p><ul><li>轮询：客户端（浏览器）定时向服务器端发送请求，获取最新的数据。轮询的间隔过长会导致用户不能及时接收到更新的数据；轮询的间隔过短会增加服务器端的负担。</li><li>长轮询：客户端发起一个请求到服务器端，服务器端一直保持连接打开，直到有数据推送，再返回这个请求，客户端收到服务器端返回的数据后，处理数据并发起一个新请求。使用这种方法，每有一个客户端服务器端就要一直保持一条连接，当达到服务器处理的上限的时候，服务器将无法响应新的请求。</li><li>SSE：是基于 HTTP 实现的一套服务器向客户端发送数据的 API。他是针对上面说到的三种方法（轮询，长轮询，HTTP 流）的一个标准 API 实现。但不兼容 IE 浏览器。</li><li>Web Sockets：Web Sockets 采用了一套全新的协议（ws/wss）来建立客户端到服务器端的全双工、双向通信连接，相较于 HTTP 请求更加高效(不需要握手，连接始终存在；无需携带头部信息)。</li></ul><p>在使用的过程中，根据产品将来的使用环境(支持的浏览器类型、版本)，使用场景(双向通信、单向通信)这些点，并结合每一种方法的优缺点去考虑，然后选取对应的策略。</p><p>WebSocket 协议在 2008 年诞生，2011 年成为国际标准。所有浏览器都已经支持了。最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。</p><p>其他特点包括：</p><ol><li>建立在 TCP 协议之上，服务器端的实现比较容易。</li><li>与 HTTP 协议有着良好的兼容性。默认端口也是 80 和 443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。</li><li>数据格式比较轻量，性能开销小，通信高效。</li><li>可以发送文本，也可以发送二进制数据。</li><li>没有同源限制，客户端可以与任意服务器通信。</li><li>协议标识符是 ws（如果加密，则为 wss），服务器网址就是 URL。</li></ol><p>下面从服务器端和客户端分别展开讨论。</p><h1 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h1><p>目前有两个流行的 ws 通信库，分别是 ws 和 socket.io。两个库各有特点，简单说，ws 通信速度更快，socket.io 兼容性更好，最低可支持 IE9，而且易用性更好，封装了心跳检测等功能。</p><p>两个库用法类似，下面以 ws 为例展开。(ws 的官网：<a href="https://github.com/websockets/ws" target="_blank" rel="noopener">https://github.com/websockets/ws</a>)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> WebSocket = <span class="built_in">require</span>(<span class="string">'ws'</span>)</span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="keyword">const</span> wss = <span class="keyword">new</span> WebSocket.Server(&#123; <span class="attr">noServer</span>: <span class="literal">true</span> &#125;)</span><br><span class="line"><span class="keyword">const</span> server = http.createServer()</span><br><span class="line"><span class="keyword">const</span> jwt = <span class="built_in">require</span>(<span class="string">'jsonwebtoken'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> timeInterval = <span class="number">1000</span></span><br><span class="line"><span class="comment">// 多聊天室的功能</span></span><br><span class="line"><span class="comment">// roomid -&gt; 对应相同的roomid进行广播消息</span></span><br><span class="line"><span class="keyword">let</span> group = &#123;&#125;</span><br><span class="line"></span><br><span class="line">wss.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span> <span class="title">connection</span>(<span class="params">ws</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 初始的心跳连接状态</span></span><br><span class="line">  ws.isAlive = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'one client is connected'</span>)</span><br><span class="line">  <span class="comment">// 接收客户端的消息</span></span><br><span class="line">  ws.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">msg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> msgObj = <span class="built_in">JSON</span>.parse(msg)</span><br><span class="line">    <span class="keyword">if</span> (msgObj.event === <span class="string">'enter'</span>) &#123;</span><br><span class="line">      ws.name = msgObj.message</span><br><span class="line">      ws.roomid = msgObj.roomid</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> group[ws.roomid] === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">        group[ws.roomid] = <span class="number">1</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        group[ws.roomid]++</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 心跳检测</span></span><br><span class="line">    <span class="keyword">if</span> (msgObj.event === <span class="string">'heartbeat'</span> &amp;&amp; msgObj.message === <span class="string">'pong'</span>) &#123;</span><br><span class="line">      ws.isAlive = <span class="literal">true</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主动发送消息给客户端</span></span><br><span class="line">    <span class="comment">// ws.send('server:' + msg)</span></span><br><span class="line">    <span class="comment">// 广播消息</span></span><br><span class="line">    wss.clients.forEach(<span class="function">(<span class="params">client</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 判断非自己的客户端</span></span><br><span class="line">      <span class="keyword">if</span> (client.readyState === WebSocket.OPEN &amp;&amp; client.roomid === ws.roomid) &#123;</span><br><span class="line">        msgObj.name = ws.name</span><br><span class="line">        msgObj.num = group[ws.roomid]</span><br><span class="line">        client.send(<span class="built_in">JSON</span>.stringify(msgObj))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当ws客户端断开链接的时候</span></span><br><span class="line">  ws.on(<span class="string">'close'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ws.name) &#123;</span><br><span class="line">      group[ws.roomid]--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> msgObj = &#123;&#125;</span><br><span class="line">    <span class="comment">// 广播消息</span></span><br><span class="line">    wss.clients.forEach(<span class="function">(<span class="params">client</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 判断非自己的客户端</span></span><br><span class="line">      <span class="keyword">if</span> (client.readyState === WebSocket.OPEN &amp;&amp; ws.roomid === client.roomid) &#123;</span><br><span class="line">        msgObj.name = ws.name</span><br><span class="line">        msgObj.num = group[ws.roomid]</span><br><span class="line">        msgObj.event = <span class="string">'out'</span></span><br><span class="line">        client.send(<span class="built_in">JSON</span>.stringify(msgObj))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">'upgrade'</span>, <span class="function"><span class="keyword">function</span> <span class="title">upgrade</span>(<span class="params">request, socket, head</span>) </span>&#123;</span><br><span class="line">  wss.handleUpgrade(request, socket, head, <span class="function"><span class="keyword">function</span> <span class="title">done</span>(<span class="params">ws</span>) </span>&#123;</span><br><span class="line">    wss.emit(<span class="string">'connection'</span>, ws, request)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>)</span><br><span class="line"></span><br><span class="line">setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  wss.clients.forEach(<span class="function">(<span class="params">ws</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!ws.isAlive &amp;&amp; ws.roomid) &#123;</span><br><span class="line">      group[ws.roomid]--</span><br><span class="line">      <span class="keyword">delete</span> ws[<span class="string">'roomid'</span>]</span><br><span class="line">      <span class="keyword">return</span> ws.terminate()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 主动发送心跳检测请求</span></span><br><span class="line">    <span class="comment">// 当客户端返回了消息之后，主动设置flag为在线</span></span><br><span class="line">    ws.isAlive = <span class="literal">false</span></span><br><span class="line">    ws.send(</span><br><span class="line">      <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">        event: <span class="string">'heartbeat'</span>,</span><br><span class="line">        message: <span class="string">'ping'</span>,</span><br><span class="line">        num: group[ws.roomid],</span><br><span class="line">      &#125;)</span><br><span class="line">    )</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, timeInterval)</span><br></pre></td></tr></table></figure><h1 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.staticfile.org/vue/2.6.11/vue.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"isShow"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>昵称：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"name"</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>房间号：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"roomid"</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> @<span class="attr">click</span>=<span class="string">"enter()"</span>&gt;</span>进入聊天室<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(item,index) in lists"</span> <span class="attr">:key</span>=<span class="string">"'message' + index"</span>&gt;</span></span><br><span class="line">            &#123;&#123;item&#125;&#125;</span><br><span class="line">          <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">li</span>&gt;</span>在线人数&#123;&#123;num&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"ctrl"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"message"</span> /&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> @<span class="attr">click</span>=<span class="string">"send()"</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el: <span class="string">'#app'</span>,</span></span><br><span class="line">        data: &#123;</span><br><span class="line"><span class="actionscript">          message: <span class="string">''</span>,</span></span><br><span class="line">          lists: [],</span><br><span class="line">          ws: &#123;&#125;,</span><br><span class="line"><span class="actionscript">          name: <span class="string">''</span>,</span></span><br><span class="line"><span class="actionscript">          isShow: <span class="literal">true</span>,</span></span><br><span class="line">          num: 0,</span><br><span class="line"><span class="actionscript">          roomid: <span class="string">''</span>,</span></span><br><span class="line">          handle: &#123;&#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        mounted() &#123;&#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">          init() &#123;</span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.ws = <span class="keyword">new</span> WebSocket(<span class="string">'ws://127.0.0.1:3000'</span>)</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.ws.onopen = <span class="keyword">this</span>.onOpen</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.ws.onmessage = <span class="keyword">this</span>.onMessage</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.ws.onclose = <span class="keyword">this</span>.onClose</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.ws.onerror = <span class="keyword">this</span>.onError</span></span><br><span class="line">          &#125;,</span><br><span class="line">          enter() &#123;</span><br><span class="line"><span class="actionscript">            <span class="keyword">if</span> (<span class="keyword">this</span>.name.trim() === <span class="string">''</span>) &#123;</span></span><br><span class="line"><span class="actionscript">              alert(<span class="string">'用户名不得为空'</span>)</span></span><br><span class="line"><span class="actionscript">              <span class="keyword">return</span></span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.init()</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.isShow = <span class="literal">false</span></span></span><br><span class="line">          &#125;,</span><br><span class="line"><span class="actionscript">          onOpen: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.ws.send(</span></span><br><span class="line"><span class="javascript">              <span class="built_in">JSON</span>.stringify(&#123;</span></span><br><span class="line"><span class="actionscript">                event: <span class="string">'enter'</span>,</span></span><br><span class="line"><span class="actionscript">                message: <span class="keyword">this</span>.name,</span></span><br><span class="line"><span class="actionscript">                roomid: <span class="keyword">this</span>.roomid,</span></span><br><span class="line">              &#125;)</span><br><span class="line">            )</span><br><span class="line">          &#125;,</span><br><span class="line"><span class="actionscript">          onMessage: <span class="function"><span class="keyword">function</span> <span class="params">(event)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 当用户未进入聊天室，则不接收消息</span></span></span><br><span class="line"><span class="actionscript">            <span class="keyword">if</span> (<span class="keyword">this</span>.isShow) &#123;</span></span><br><span class="line"><span class="actionscript">              <span class="keyword">return</span></span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="actionscript">            <span class="comment">// 接收服务端发送过来的消息</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> obj = <span class="built_in">JSON</span>.parse(event.data)</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">switch</span> (obj.event) &#123;</span></span><br><span class="line"><span class="actionscript">              <span class="keyword">case</span> <span class="string">'noauth'</span>:</span></span><br><span class="line"><span class="actionscript">                <span class="comment">// 鉴权失败</span></span></span><br><span class="line"><span class="actionscript">                <span class="comment">// 路由跳转到 /login 重新获取token</span></span></span><br><span class="line"><span class="actionscript">                <span class="keyword">break</span></span></span><br><span class="line"><span class="actionscript">              <span class="keyword">case</span> <span class="string">'enter'</span>:</span></span><br><span class="line"><span class="actionscript">                <span class="comment">// 当有一个新的用户进入聊天室</span></span></span><br><span class="line"><span class="actionscript">                <span class="keyword">this</span>.lists.push(<span class="string">'欢迎：'</span> + obj.message + <span class="string">'加入聊天室！'</span>)</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">break</span></span></span><br><span class="line"><span class="actionscript">              <span class="keyword">case</span> <span class="string">'out'</span>:</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">this</span>.lists.push(obj.name + <span class="string">'已经退出了聊天室！'</span>)</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">break</span></span></span><br><span class="line"><span class="actionscript">              <span class="keyword">case</span> <span class="string">'heartbeat'</span>:</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">this</span>.checkServer() <span class="comment">// timeInterval + t</span></span></span><br><span class="line"><span class="actionscript">                <span class="keyword">this</span>.ws.send(</span></span><br><span class="line"><span class="javascript">                  <span class="built_in">JSON</span>.stringify(&#123;</span></span><br><span class="line"><span class="actionscript">                    event: <span class="string">'heartbeat'</span>,</span></span><br><span class="line"><span class="actionscript">                    message: <span class="string">'pong'</span>,</span></span><br><span class="line">                  &#125;)</span><br><span class="line">                )</span><br><span class="line"><span class="actionscript">                <span class="keyword">break</span></span></span><br><span class="line"><span class="actionscript">              <span class="keyword">default</span>:</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">if</span> (obj.name !== <span class="keyword">this</span>.name) &#123;</span></span><br><span class="line"><span class="actionscript">                  <span class="comment">// 接收正常的聊天</span></span></span><br><span class="line"><span class="actionscript">                  <span class="keyword">this</span>.lists.push(obj.name + <span class="string">':'</span> + obj.message)</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.num = obj.num</span></span><br><span class="line">          &#125;,</span><br><span class="line"><span class="actionscript">          onClose: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 当链接主动断开的时候触发close事件</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'close:'</span> + <span class="keyword">this</span>.ws.readyState)</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'已关闭websocket'</span>)</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.ws.close()</span></span><br><span class="line">          &#125;,</span><br><span class="line"><span class="actionscript">          onError: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 当连接失败时，触发error事件</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'error:'</span> + <span class="keyword">this</span>.ws.readyState)</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'websocket连接失败！'</span>)</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 连接失败之后，1s进行断线重连！</span></span></span><br><span class="line"><span class="actionscript">            <span class="keyword">var</span> _this = <span class="keyword">this</span></span></span><br><span class="line"><span class="actionscript">            setTimeout(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line">              _this.init()</span><br><span class="line">            &#125;, 1000)</span><br><span class="line">          &#125;,</span><br><span class="line"><span class="actionscript">          <span class="comment">// 发送消息</span></span></span><br><span class="line"><span class="actionscript">          send: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.lists.push(<span class="keyword">this</span>.name + <span class="string">':'</span> + <span class="keyword">this</span>.message)</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.ws.send(</span></span><br><span class="line"><span class="javascript">              <span class="built_in">JSON</span>.stringify(&#123;</span></span><br><span class="line"><span class="actionscript">                event: <span class="string">'message'</span>,</span></span><br><span class="line"><span class="actionscript">                message: <span class="keyword">this</span>.message,</span></span><br><span class="line"><span class="actionscript">                name: <span class="keyword">this</span>.name,</span></span><br><span class="line">              &#125;)</span><br><span class="line">            )</span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.message = <span class="string">''</span></span></span><br><span class="line">          &#125;,</span><br><span class="line"><span class="actionscript">          checkServer: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">var</span> _this = <span class="keyword">this</span></span></span><br><span class="line"><span class="actionscript">            clearTimeout(<span class="keyword">this</span>.handle)</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.handle = setTimeout(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line">              _this.onClose()</span><br><span class="line">              _this.init()</span><br><span class="line">            &#125;, 1000 + 500)</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> NodeJS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> NodeJS </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用echarts分分钟做出漂亮图表</title>
      <link href="/2020/07/20/%E4%BD%BF%E7%94%A8echarts%E5%88%86%E5%88%86%E9%92%9F%E5%81%9A%E5%87%BA%E6%BC%82%E4%BA%AE%E5%9B%BE%E8%A1%A8/"/>
      <url>/2020/07/20/%E4%BD%BF%E7%94%A8echarts%E5%88%86%E5%88%86%E9%92%9F%E5%81%9A%E5%87%BA%E6%BC%82%E4%BA%AE%E5%9B%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>与 canvas 类似，echarts 通过标签做出图表占位，具体图表内容通过 js 绘制。如果学过 canvas，echarts 会很容易上手。echarts 是第三方插件，可以通过标签引入 echarts.js 文件或通过 npm install 安装。</p><p>图表生成的基本步骤是：</p><ol><li>为 ECharts 准备一个具备高宽的 DOM 容器；</li><li>通过 echarts.init 方法初始化一个 echarts 实例</li><li>通过实例的 setOption 方法导入配置项生成对应图形</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 为 ECharts 准备一个具备大小（宽高）的 DOM --&gt;</span><br><span class="line">&lt;div id=<span class="string">"main"</span> style=<span class="string">"width: 600px;height:400px;"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;script type="text/</span>javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">    // 基于准备好的dom，初始化echarts实例</span></span><br><span class="line"><span class="string">    var myChart = echarts.init(document.getElementById('main'));</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // 指定图表的配置项和数据</span></span><br><span class="line"><span class="string">    var option = &#123;</span></span><br><span class="line"><span class="string">        title: &#123;</span></span><br><span class="line"><span class="string">            text: 'ECharts 入门示例'</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        tooltip: &#123;&#125;,</span></span><br><span class="line"><span class="string">        legend: &#123;</span></span><br><span class="line"><span class="string">            data:['销量']</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        xAxis: &#123;</span></span><br><span class="line"><span class="string">            data: ["</span>衬衫<span class="string">","</span>羊毛衫<span class="string">","</span>雪纺衫<span class="string">","</span>裤子<span class="string">","</span>高跟鞋<span class="string">","</span>袜子<span class="string">"]</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        yAxis: &#123;&#125;,</span></span><br><span class="line"><span class="string">        series: [&#123;</span></span><br><span class="line"><span class="string">            name: '销量',</span></span><br><span class="line"><span class="string">            type: 'bar',</span></span><br><span class="line"><span class="string">            data: [5, 20, 36, 10, 10, 20]</span></span><br><span class="line"><span class="string">        &#125;]</span></span><br><span class="line"><span class="string">    &#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // 使用刚指定的配置项和数据显示图表。</span></span><br><span class="line"><span class="string">    myChart.setOption(option);</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><p>上面代码可以生成一个柱状图。</p><p>使用 option 来描述其对图表的各种需求，包括：有什么数据、要画什么图表、图表长什么样子、含有什么组件、组件能操作什么事情等等。简而言之，option 表述了：数据、数据如何映射成图形、交互行为。</p><h1 id="图形基本画法"><a href="#图形基本画法" class="headerlink" title="图形基本画法"></a>图形基本画法</h1><h3 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h3><p>一个 html 可以配置多个作为 echarts 渲染容器的 DOM 节点，每个 DOM 节点只能放置一个 echarts 实例，每个 echarts 实例可以通过系列(series)绘制多个有关联的图形。</p><p>echarts 里系列类型(series.type)就是图表类型。系列类型(series.type)有：line(折线图)、bar(柱状图)、pie(饼图)、scatter(散点图)、graph(关系图)、tree(树图)等。系列的数据从 series.dataset 中取。通过 series.encode 选择 dataset 中对应的列。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> option = &#123;</span><br><span class="line">    dataset: &#123;</span><br><span class="line">        source: [</span><br><span class="line">            [<span class="number">121</span>, <span class="string">'XX'</span>, <span class="number">442</span>, <span class="number">43.11</span>],</span><br><span class="line">            [<span class="number">663</span>, <span class="string">'ZZ'</span>, <span class="number">311</span>, <span class="number">91.14</span>],</span><br><span class="line">            [<span class="number">913</span>, <span class="string">'ZZ'</span>, <span class="number">312</span>, <span class="number">92.12</span>],</span><br><span class="line">            ...</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    xAxis: &#123;&#125;,</span><br><span class="line">    yAxis: &#123;&#125;,</span><br><span class="line">    series: [</span><br><span class="line">        <span class="comment">// 数据从 dataset 中取，encode 中的数值是 dataset.source 的维度 index （即第几列）</span></span><br><span class="line">        &#123;<span class="attr">type</span>: <span class="string">'bar'</span>, <span class="attr">encode</span>: &#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">0</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="attr">type</span>: <span class="string">'bar'</span>, <span class="attr">encode</span>: &#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="attr">type</span>: <span class="string">'scatter'</span>, <span class="attr">encode</span>: &#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">3</span>&#125;&#125;,</span><br><span class="line">        ...</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>option 中各种属性，被抽象为“组件”。例如，echarts 中至少有这些组件：xAxis(直角坐标系 X 轴)、yAxis(直角坐标系 Y 轴)、grid(直角坐标系底板)、angleAxis(极坐标系角度轴)、radiusAxis(极坐标系半径轴)、polar(极坐标系底板)、geo(地理坐标系)、dataZoom(数据区缩放组件)、visualMap(视觉映射组件)、tooltip(提示框组件)、toolbox(工具栏组件)等。其实系列(series)也是一种组件，可以理解为：系列是专门绘制“图”的组件。</p><figure class="image-box">                <img src="/2020/07/20/%E4%BD%BF%E7%94%A8echarts%E5%88%86%E5%88%86%E9%92%9F%E5%81%9A%E5%87%BA%E6%BC%82%E4%BA%AE%E5%9B%BE%E8%A1%A8/1.jpg" alt="option组件" title class>                <p>option组件</p>            </figure><h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><p>多数组件和系列，都能够基于 top / right / down / left / width / height 绝对定位。 这种绝对定位的方式，类似于 CSS 的绝对定位（position: absolute）。绝对定位基于的是 echarts 容器 DOM 节点。每个值都可以是绝对数值或基于 echarts 容器高宽的百分比。left right width 是一组（横向）、top bottom height 是另一组（纵向）。每组中，至多设置两项就可以了。</p><p>少数圆形的组件或系列，可以使用“中心半径定位”，例如，pie（饼图）、sunburst（旭日图）、polar（极坐标系）。中心半径定位往往依据 center（中心）、radius（半径）来决定位置。</p><h3 id="坐标系"><a href="#坐标系" class="headerlink" title="坐标系"></a>坐标系</h3><p>很多系列，例如 line（折线图）、bar（柱状图）、scatter（散点图）、heatmap（热力图）等等，需要运行在 “坐标系” 上。坐标系用于布局这些图，以及显示数据的刻度等等。还有一些图，例如 graph（关系图）等，既能独立存在，也能布局在坐标系中，依据用户的设定而来。其他一些系列，例如 pie（饼图）、tree（树图）等等，并不依赖坐标系。</p><p>直角坐标系中，包括有 xAxis（直角坐标系 X 轴）、yAxis（直角坐标系 Y 轴）、grid（直角坐标系底板）三种组件。xAxis、yAxis 被 grid 自动引用并组织起来，共同工作。</p><p>下图中，两个 yAxis，共享了一个 xAxis。两个 series，也共享了这个 xAxis，但是分别使用不同的 yAxis，使用 yAxisIndex 来指定它自己使用的是哪个 yAxis：</p><figure class="image-box">                <img src="/2020/07/20/%E4%BD%BF%E7%94%A8echarts%E5%88%86%E5%88%86%E9%92%9F%E5%81%9A%E5%87%BA%E6%BC%82%E4%BA%AE%E5%9B%BE%E8%A1%A8/2.jpg" alt="共享同一grid" title class>                <p>共享同一grid</p>            </figure><p>下图中，一个 echarts 实例中，有多个 grid，每个 grid 分别有 xAxis、yAxis，他们使用 xAxisIndex、yAxisIndex、gridIndex 来指定引用关系：</p><figure class="image-box">                <img src="/2020/07/20/%E4%BD%BF%E7%94%A8echarts%E5%88%86%E5%88%86%E9%92%9F%E5%81%9A%E5%87%BA%E6%BC%82%E4%BA%AE%E5%9B%BE%E8%A1%A8/3.jpg" alt="使用两个grid" title class>                <p>使用两个grid</p>            </figure><h1 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h1><p>ECharts 能够从全局、系列、数据三个层级设置数据图形的样式。</p><h3 id="全局样式"><a href="#全局样式" class="headerlink" title="全局样式"></a>全局样式</h3><p>color：调色盘列表样式，会依次循环从该列表中取颜色作为系列颜色。默认的列表为<code>[&#39;#c23531&#39;,&#39;#2f4554&#39;, &#39;#61a0a8&#39;, &#39;#d48265&#39;, &#39;#91c7ae&#39;,&#39;#749f83&#39;, &#39;#ca8622&#39;, &#39;#bda29a&#39;,&#39;#6e7074&#39;, &#39;#546570&#39;, &#39;#c4ccd3&#39;]</code>。</p><p>backgroundColor：背景色。Echarts 中所有的颜色配置除了纯色之外也支持渐变色和纹理填充。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线性渐变，前四个参数分别是 x0, y0, x2, y2, 范围从 0 - 1，相当于在图形包围盒中的百分比，如果 globalCoord 为 `true`，则该四个值是绝对的像素位置</span></span><br><span class="line">color: &#123;</span><br><span class="line">    type: <span class="string">'linear'</span>,</span><br><span class="line">    x: <span class="number">0</span>,</span><br><span class="line">    y: <span class="number">0</span>,</span><br><span class="line">    x2: <span class="number">0</span>,</span><br><span class="line">    y2: <span class="number">1</span>,</span><br><span class="line">    colorStops: [&#123;</span><br><span class="line">        offset: <span class="number">0</span>, <span class="attr">color</span>: <span class="string">'red'</span> <span class="comment">// 0% 处的颜色</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        offset: <span class="number">1</span>, <span class="attr">color</span>: <span class="string">'blue'</span> <span class="comment">// 100% 处的颜色</span></span><br><span class="line">    &#125;],</span><br><span class="line">    global: <span class="literal">false</span> <span class="comment">// 缺省为 false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 径向渐变，前三个参数分别是圆心 x, y 和半径，取值同线性渐变</span></span><br><span class="line">color: &#123;</span><br><span class="line">    type: <span class="string">'radial'</span>,</span><br><span class="line">    x: <span class="number">0.5</span>,</span><br><span class="line">    y: <span class="number">0.5</span>,</span><br><span class="line">    r: <span class="number">0.5</span>,</span><br><span class="line">    colorStops: [&#123;</span><br><span class="line">        offset: <span class="number">0</span>, <span class="attr">color</span>: <span class="string">'red'</span> <span class="comment">// 0% 处的颜色</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        offset: <span class="number">1</span>, <span class="attr">color</span>: <span class="string">'blue'</span> <span class="comment">// 100% 处的颜色</span></span><br><span class="line">    &#125;],</span><br><span class="line">    global: <span class="literal">false</span> <span class="comment">// 缺省为 false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 纹理填充</span></span><br><span class="line">color: &#123;</span><br><span class="line">    image: imageDom, <span class="comment">// 支持为 HTMLImageElement, HTMLCanvasElement，不支持路径字符串</span></span><br><span class="line">    repeat: <span class="string">'repeat'</span> <span class="comment">// 是否平铺，可以是 'repeat-x', 'repeat-y', 'no-repeat'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>textStyle 全局文本样式。textStyle 的属性有：</p><ol><li>color；</li><li>fontStyle；</li><li>fontWeight；</li><li>fontFamily；</li><li>fontSize；</li><li>lineHeight；</li><li>width；</li><li>height；</li><li>textBorderColor；</li><li>textBorderWidth；</li><li>textShadowColor；</li><li>textShadowBlur；</li><li>textShadowOffsetX；</li><li>textShadowOffsetY。</li></ol><p>全局还可以设置一些动画样式：</p><ol><li>animation: true，是否开启动画；</li><li>animationThreshold: 2000，是否开启动画的阈值，当单个系列显示的图形数量大于这个阈值时会关闭动画；</li><li>animationDuration: 1000，初始动画的时长，支持回调函数，可以通过每个数据返回不同的时长实现更戏剧的初始动画效果；</li><li>animationEasing: cubicOut，初始动画的缓动效果；</li><li>animationDelay: 0，初始动画的延迟，支持回调函数，可以通过每个数据返回不同的 delay 时间实现更戏剧的初始动画效果；</li><li>animationDurationUpdate: 300，数据更新动画的时长；</li><li>animationEasingUpdate: cubicOut，数据更新动画的缓动效果；</li><li>animationDelayUpdate: 0，数据更新动画的延迟。</li></ol><h3 id="系列样式"><a href="#系列样式" class="headerlink" title="系列样式"></a>系列样式</h3><p>ECharts 中有一些通用的样式，诸如图形元素的颜色、线宽、点的大小、标签的文字、标签的样式，这些样式一般都会在系列的 itemStyle、lineStyle、areaStyle、label 里设置。</p><p>在四个配置项中，阴影配置是公用的：</p><ol><li>图形阴影的模糊大小：shadowBlur，该属性配合 shadowColor,shadowOffsetX, shadowOffsetY 一起设置图形的阴影效果；</li><li>阴影颜色：shadowColor；</li><li>阴影水平方向上的偏移距离：shadowOffsetX；</li><li>阴影垂直方向上的偏移距离：shadowOffsetY；</li></ol><p>itemStyle 为折线拐点标志的样式，有如下配置项：</p><ol><li>图形的颜色：color；</li><li>图形的描边颜色：borderColor；</li><li>描边线宽：borderWidth，为 0 时无描边；</li><li>柱条的描边类型：borderType，默认为实线，支持 ‘solid’, ‘dashed’, ‘dotted’；</li><li>图形透明度：opacity，0-1。</li></ol><p>lineStyle 为线条样式，有如下配置项：</p><ol><li>color，修改 lineStyle 中的颜色不会影响图例颜色，如果需要图例颜色和折线图颜色一致，需修改 itemStyle.color，线条颜色默认也会取该颜色；</li><li>width；</li><li>type；</li><li>opacity。</li></ol><p>areaStyle 为区域填充样式，有如下配置项：</p><ol><li>color；</li><li>origin，图形区域的起始位置，默认情况下图形会从坐标轴轴线到数据间进行填充，如果需要填充的区域是坐标轴最大值到数据间，或者坐标轴最小值到数据间，则可以通过这个配置项进行设置，<br>可选值包括 ‘auto’（默认值）填充坐标轴轴线到数据间的区域、 ‘start’填充坐标轴底部（非 inverse 情况是最小值）到数据间的区域、 ‘end’填充坐标轴顶部（非 inverse 情况是最大值）到数据间的区域；</li><li>opacity。</li></ol><p>label 为图形上的文本标签，可用于说明图形的一些数据信息，属性中项除了阴影属性和 textStyle 中的属性，还有：</p><ol><li>show，是否显示标签，接受布尔值；</li><li>position: ‘top’，标签的位置，可以通过内置的语义声明位置，可以用一个数组表示相对的百分比或者绝对像素值表示标签相对于图形包围盒左上角的位置；</li><li>distance，距离图形元素的距离，当 position 为字符描述值（如 ‘top’、’insideRight’）时候有效；</li><li>rotate，标签旋转，从 -90 度到 90 度，正值是逆时针；</li><li>offset，是否对文字进行偏移。默认不偏移，例如 [30, 40] 表示文字在横向上偏移 30，纵向上偏移 40；</li><li>formatter，标签内容格式器，支持字符串模板和回调函数两种形式，字符串模板与回调函数返回的字符串均支持用 \n 换行；</li><li>align，文字水平对齐方式，默认自动，可选’left’、’center’、’right’；</li><li>verticalAlign，文字垂直对齐方式，默认自动，可选’top’、’middle’、’bottom’；</li><li>backgroundColor，文字块背景色；</li><li>borderColor，文字块边框颜色；</li><li>borderWidth，文字块边框宽度；</li><li>borderRadius，文字块圆角；</li><li>padding，文字块的内边距；</li><li>rich，自定义富文本样式，利用富文本样式，可以在标签中做出非常丰富的效果，下面单独拿出来说。</li></ol><p>label.rich 中的属性除了阴影属性和 textStyle 中的属性还有 label 中的：align , verticalAlign , backgroundColor , borderColor , borderWidth , borderRadius , padding。原先 echarts 中的文本标签，只能对整块统一进行样式设置，并且仅仅支持颜色和字体的设置，从而导致不易于制作表达能力更强的文字描述信息。通过 label.rich，可以实现如下功能：</p><ul><li>定制文本块整体的样式（如背景、边框、阴影等）、位置、旋转等。</li><li>对文本块中个别片段定义样式（如颜色、字体、高宽、背景、阴影等）、对齐方式等。</li><li>在文本中使用图片做小图标或者背景。</li><li>特定组合以上的规则，可以做出简单表格、分割线等效果。</li></ul><p>开始下面的介绍之前，先说明一下下面会使用的两个名词的含义：</p><p>文本块（Text Block）：文本标签块整体。<br>文本片段（Text fragment）：文本标签块中的部分文本。</p><h3 id="数据样式"><a href="#数据样式" class="headerlink" title="数据样式"></a>数据样式</h3><p>ECharts 中每个数据对应图形的样式可以通过分别设置 data 下的数据项实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data: [&#123;</span><br><span class="line">    value:<span class="number">400</span>,</span><br><span class="line">    name:<span class="string">'搜索引擎'</span>,</span><br><span class="line">    itemStyle: &#123;</span><br><span class="line">        color: <span class="string">'#c23531'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;, ...]</span><br></pre></td></tr></table></figure><h3 id="高亮样式"><a href="#高亮样式" class="headerlink" title="高亮样式"></a>高亮样式</h3><p>在鼠标悬浮到图形元素上时，一般会出现高亮的样式。默认情况下，高亮的样式是根据普通样式自动生成的。但是高亮的样式也可以自己定义，主要是通过 emphasis 属性来定制。ECharts4 之前 emphasis 在 label 和 itemStyle 的属性中，ECharts4 将 emphasis 抽离出来作为 label 和 itemStyle 的平级属性，在 emphasis 中设置了 label 和 itemStyle 两个属性，分别设置对应的高亮状态。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 高亮样式</span></span><br><span class="line">emphasis: &#123;</span><br><span class="line">    itemStyle: &#123;</span><br><span class="line">        <span class="comment">// 高亮时点的颜色</span></span><br><span class="line">        color: <span class="string">'blue'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    label: &#123;</span><br><span class="line">        show: <span class="literal">true</span>,</span><br><span class="line">        <span class="comment">// 高亮时标签的文字</span></span><br><span class="line">        formatter: <span class="string">'This is a emphasis label.'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="异步数据加载和更新"><a href="#异步数据加载和更新" class="headerlink" title="异步数据加载和更新"></a>异步数据加载和更新</h1><p>很多时候可能数据需要异步加载后再填入。ECharts 中实现异步数据的更新非常简单，在图表初始化后不管任何时候只要通过 jQuery 等工具异步获取数据后通过 setOption 填入数据和配置项就行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myChart = echarts.init(<span class="built_in">document</span>.getElementById(<span class="string">'main'</span>))</span><br><span class="line"><span class="comment">// 显示标题，图例和空的坐标轴</span></span><br><span class="line">myChart.setOption(&#123;</span><br><span class="line">  title: &#123;</span><br><span class="line">    text: <span class="string">'异步数据加载示例'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  tooltip: &#123;&#125;,</span><br><span class="line">  legend: &#123;</span><br><span class="line">    data: [<span class="string">'销量'</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">  xAxis: &#123;</span><br><span class="line">    data: [],</span><br><span class="line">  &#125;,</span><br><span class="line">  yAxis: &#123;&#125;,</span><br><span class="line">  series: [</span><br><span class="line">    &#123;</span><br><span class="line">      name: <span class="string">'销量'</span>,</span><br><span class="line">      type: <span class="string">'bar'</span>,</span><br><span class="line">      data: [],</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步加载数据</span></span><br><span class="line">$.<span class="keyword">get</span>('data.json').done(function (data) &#123;</span><br><span class="line">  <span class="comment">// 填入数据</span></span><br><span class="line">  myChart.setOption(&#123;</span><br><span class="line">    xAxis: &#123;</span><br><span class="line">      data: data.categories,</span><br><span class="line">    &#125;,</span><br><span class="line">    series: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 根据名字对应到相应的系列</span></span><br><span class="line">        name: <span class="string">'销量'</span>,</span><br><span class="line">        data: data.data,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面代码先设置完其它的样式，显示一个空的直角坐标轴，然后获取数据后填入数据。</p><p>如果数据加载时间较长，一个空的坐标轴放在画布上也会让用户觉得是不是产生 bug 了，因此需要一个 loading 的动画来提示用户数据正在加载。ECharts 默认有提供了一个简单的加载动画。只需要调用 showLoading 方法显示。数据加载完成后再调用 hideLoading 方法隐藏加载动画。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">myChart.showLoading();</span><br><span class="line">$.<span class="keyword">get</span>('data.json').done(function (data) &#123;</span><br><span class="line">    myChart.hideLoading();</span><br><span class="line">    myChart.setOption(...);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>所有数据的更新都通过 setOption 实现，只需要定时获取数据，然后 setOption 填入数据，而不用考虑数据到底产生了那些变化，ECharts 会找到两组数据之间的差异然后通过合适的动画去表现数据的变化。</p><h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p>在 ECharts 的图表中用户的操作将会触发相应的事件。开发者可以监听这些事件，然后通过回调函数做相应的处理，比如跳转到一个地址，或者弹出对话框，或者做数据下钻等等。如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myChart.on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">params</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(params.name)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>ECharts 支持常规的鼠标事件类型，包括 ‘click’、’dblclick’、’mousedown’、’mousemove’、’mouseup’、’mouseover’、’mouseout’、’globalout’、’contextmenu’ 事件。</p><p>同时，ECharts 也支持一些图表行为的监听。例如’updateAxisPointer’可以实现多图联动。</p><h1 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h1><p>除以上用法外，还有其他不少使用的功能，如：</p><ol><li>visualMap 组件提供了通用的视觉映射，用于把更多的维度展现出来。</li><li>toolbox 组件，内置有导出图片，数据视图，动态类型切换，数据区域缩放，重置五个工具。</li><li>数据区域缩放组件(dataZoom)，可以对数轴(axis)进行『数据窗口缩放』、『数据窗口平移』操作。</li><li>timeline 组件，提供了在多个 ECharts option 间进行切换、播放等操作的功能。</li><li>legend 组件用于展示图例。展现了不同系列的标记(symbol)，颜色和名字。可以通过点击图例控制哪些系列不显示。</li><li>ECharts4 发布了 SVG 渲染器。设置 renderer 参数 为 ‘canvas’ 或 ‘svg’ 即可指定渲染器。SVG 具有重要的优势：内存占用更低(移动端)、渲染性能略高、使用浏览器内置缩放功能时不会模糊。</li><li>ECharts GL 为 ECharts 补充了丰富的三维可视化组件，可以实现一些常见的三维可视化作品。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 动画 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 使用手册 </tag>
            
            <tag> 前端 </tag>
            
            <tag> 动画 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学会H5音视频标签基本用法</title>
      <link href="/2020/07/11/%E5%AD%A6%E4%BC%9AH5%E9%9F%B3%E8%A7%86%E9%A2%91%E6%A0%87%E7%AD%BE%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"/>
      <url>/2020/07/11/%E5%AD%A6%E4%BC%9AH5%E9%9F%B3%E8%A7%86%E9%A2%91%E6%A0%87%E7%AD%BE%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>Html5 之前，业界对音视频没有标准，因此网页中看到的视频，都是通过第三插件的方式嵌入的，可能是 QuickTime、 RealPlayer 或 Flash。在 Html5 标准中，为<code>&lt;audio&gt;</code> 和 <code>&lt;video&gt;</code> 元素规定了一些方法、属性和事件。这些方法、属性和事件允许使用 JavaScript 操作 <code>&lt;audio&gt;</code> 和 <code>&lt;video&gt;</code> 元素。目前的情况是，传统的第三方插件嵌入的方式已经越来越少，浏览器也逐渐不在高度支持。</p><h1 id="音视频基础"><a href="#音视频基础" class="headerlink" title="音视频基础"></a>音视频基础</h1><p>视频文件（视频容器）包含了音频轨道、视频轨道和其他一些元数据。元数据包含了视频的封面、标题、子标题、字幕等相关信息。视频播放的时候，音频轨道和视频轨道是绑定在一起的。</p><p>avi、mp4 事实上仅仅是容器的格式，只决定怎么将视频存储起来，而不关系存储的内容。有点类似于 zip 和 rar 的区别。不管是音频文件或视频文件，实际上都只是一个容器文件。</p><p>主流的视频容器格式：</p><ul><li>MPEG-4：通常以.mp4 为扩展名</li><li>Flash 视频：通常以.flv 为扩展名</li><li>Ogg：通常以.ogv 为扩展名</li><li>WebM：通常以.webm 为扩展名</li><li>音频视频交错: 通常以.avi 为扩展名</li></ul><p>主流的音频容器格式：</p><ul><li>MPEG-3：.mp3</li><li>Acc 音频：.acc</li><li>Ogg 音频：.ogg</li></ul><p>原始的媒体文件体积非常巨大，需要以流数据的形式传输。音频和视频编码/解码是一组算法，用来对一段特定音频或视频进行解码和编码，以便音频和视频能够在线播放。</p><p>视频编解码器有 H.264、VP8、Ogg Theora，音频编解码器有 AAC、MPEG-3、Ogg Vorbis。</p><p>目前还没有一种编解码和容器的组合能应用于所有的浏览器中，因此处理视频的一个流程是：</p><ol><li>制作一个 Ogg 容器中使用 Theora 视频和 Vorbis 音频的版本；</li><li>制作另外一个版本，使用 WebM 视频容器（VP8 + Vorbis）；</li><li>再制作一个版本，使用 MP4 视频容器，并使用 H.264 基本配置的视频和 ACC 低配的音频；</li><li>链接上面 3 个文件到同一个 video 元素，并向后兼容基于 Flash 的视频播放器。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;video controls width=<span class="string">"300"</span> height=<span class="string">"300"</span>&gt;</span><br><span class="line">  &lt;source src=<span class="string">"resource/video/OUTPUT.mp4"</span> type=<span class="string">"video/mp4"</span>&gt;&lt;<span class="regexp">/source&gt;</span></span><br><span class="line"><span class="regexp">  &lt;source src="resource/</span>video/OUTPUT.ogv<span class="string">" type="</span>video/ogg<span class="string">"&gt;&lt;/source&gt;</span></span><br><span class="line"><span class="string">  &lt;source src="</span>resource/video/OUTPUT.webm<span class="string">" type="</span>video/webm<span class="string">"&gt;&lt;/source&gt;</span></span><br><span class="line"><span class="string">  当前浏览器不支持 video直接播放，点击这里下载视频：</span></span><br><span class="line"><span class="string">  &lt;a href="</span>resource/video/OUTPUT.mp4<span class="string">"&gt;下载视频&lt;/a&gt;</span></span><br><span class="line"><span class="string">&lt;/video&gt;</span></span><br></pre></td></tr></table></figure><p>在上面的代码中，浏览器会先后判断三个<code>source</code>标签的<code>type</code>属性是否支持，如果支持则加载对应文件。</p><p>现在的视频编解码器会使用各种技巧减少从一帧到另一帧过程中传递的信息数量，它们不会存储每一帧的所有信息，而只是存储两帧之间的差异信息。 编码器也分有损和无损，无损视频文件一般太大，在网页中没有优势，所以我们重点研究有损编解码器。有损编解码器中，信息在编码过程中丢失是无法避免的，反复的对视频编码会导致其画面不均匀。</p><h1 id="lt-audio-gt-和-lt-video-gt-的属性"><a href="#lt-audio-gt-和-lt-video-gt-的属性" class="headerlink" title="&lt;audio&gt; 和 &lt;video&gt;的属性"></a><code>&lt;audio&gt;</code> 和 <code>&lt;video&gt;</code>的属性</h1><p>两个标签的主要 attribute 属性有:</p><ul><li><code>src</code>：要嵌到页面的视频的 URL</li><li><code>controls</code>：显示或隐藏用户控制界面</li><li><code>autoplay</code>：媒体是否自动播放</li><li><code>loop</code>：媒体是否循环播放</li><li><code>muted</code>：是否静音</li><li><code>preload</code>：该属性旨在告诉浏览器作者认为达到最佳的用户体验的方式是什么，有四个值。<ul><li><code>none</code>: 提示作者认为用户不需要查看该视频，服务器也想要最小化访问流量，换句话说就是提示浏览器该视频不需要缓存。</li><li><code>metadata</code>: 提示尽管作者认为用户不需要查看该视频，不过抓取元数据（比如：长度）还是很合理的。</li><li><code>auto</code>: 用户需要这个视频优先加载，换句话说就是提示：如果需要的话，可以下载整个视频，即使用户并不一定会用它。</li><li>空字符串：也就代指 auto 值。</li></ul></li></ul><p>此外，<code>&lt;video&gt;</code>还有宽高属性 <code>width</code> 、 <code>height</code> 和 用于在用户播放或者跳帧之前的展示海报帧 URL <code>poster</code>。</p><p>两个标签的主要 property 属性有:</p><ul><li>duration：媒体总时间(只读)，不能马上取到对应的值，最好在<code>loadeddata</code>事件中(加载第一帧后)读取。</li><li>currentTime：开始播放到现在所用的时间(可读写)</li><li>muted：是否静音(可读写,相比于 volume 优先级要高)</li><li>volume：0.0-1.0 的音量相对值(可读写)</li><li>paused：媒体是否暂停(只读)</li><li>ended：媒体是否播放完毕(只读)</li><li>error：媒体发生错误的时候，返回错误代码 (只读)</li><li>currentSrc：以字符串的形式返回媒体地址(只读)</li></ul><p>此外，<code>&lt;video&gt;</code>还有<code>poster</code>：视频播放前的预览图片(读写)；<code>width</code>、<code>height</code>：设置视频的尺寸(读写)；<code>videoWidth</code>、 <code>videoHeight</code>：视频的实际尺寸(只读)。</p><h1 id="lt-audio-gt-和-lt-video-gt-的函数和事件"><a href="#lt-audio-gt-和-lt-video-gt-的函数和事件" class="headerlink" title="&lt;audio&gt; 和 &lt;video&gt;的函数和事件"></a><code>&lt;audio&gt;</code> 和 <code>&lt;video&gt;</code>的函数和事件</h1><p>相关函数有：</p><ul><li>play()：媒体播放</li><li>pause()：媒体暂停</li><li>load()：重新加载媒体</li></ul><p>相关事件有：</p><ul><li>abort 在播放被终止时触发，例如当播放中的视频重新开始播放时会触发这个事件。</li><li>canplay 在媒体数据已经有足够的数据（至少播放数帧）可供播放时触发。这个事件对应 CAN_PLAY 的 readyState。</li><li>canplaythrough 在媒体的 readyState 变为 CAN_PLAY_THROUGH 时触发，表明媒体可以在保持当前的下载速度的情况下不被中断地播放完毕。注意：手动设置 currentTime 会使得 firefox 触发一次 canplaythrough 事件，其他浏览器或许不会如此。</li><li>durationchange 元信息已载入或已改变，表明媒体的长度发生了改变。例如，在媒体已被加载足够的长度从而得知总长度时会触发这个事件。</li><li>emptied 媒体被清空（初始化）时触发。</li><li>ended 播放结束时触发。</li><li>error 在发生错误时触发。元素的 error 属性会包含更多信息。参阅 Error handling 获得详细信息。</li><li>loadeddata 媒体的第一帧已经加载完毕。</li><li>loadedmetadata 媒体的元数据已经加载完毕，现在所有的属性包含了它们应有的有效信息。</li><li>loadstart 在媒体开始加载时触发。</li><li>mozaudioavailable 当音频数据缓存并交给音频层处理时</li><li>pause 播放暂停时触发。</li><li>play 在媒体回放被暂停后再次开始时触发。即，在一次暂停事件后恢复媒体回放。</li><li>playing 在媒体开始播放时触发（不论是初次播放、在暂停后恢复、或是在结束后重新开始）。</li><li>progress 告知媒体相关部分的下载进度时周期性地触发。有关媒体当前已下载总计的信息可以在元素的 buffered 属性中获取到。</li><li>ratechange 在回放速率变化时触发。</li><li>seeked 在跳跃操作完成时触发。</li><li>seeking 在跳跃操作开始时触发。</li><li>stalled 在尝试获取媒体数据，但数据不可用时触发。</li><li>suspend 在媒体资源加载终止时触发，这可能是因为下载已完成或因为其他原因暂停。</li><li>timeupdate 元素的 currentTime 属性表示的时间已经改变。</li><li>volumechange 在音频音量改变时触发（既可以是 volume 属性改变，也可以是 muted 属性改变）。</li><li>waiting 在一个待执行的操作（如回放）因等待另一个操作（如跳跃或下载）被延迟时触发。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 使用手册 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文学会基于C#的ABB机械臂二次开发</title>
      <link href="/2020/07/10/%E4%B8%80%E6%96%87%E5%AD%A6%E4%BC%9AABB%E6%9C%BA%E6%A2%B0%E8%87%82%E7%9A%84%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91/"/>
      <url>/2020/07/10/%E4%B8%80%E6%96%87%E5%AD%A6%E4%BC%9AABB%E6%9C%BA%E6%A2%B0%E8%87%82%E7%9A%84%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<p>不经意间研二已经结束了，研究生生涯已过大半。研究生阶段主要在研究机械臂相关的内容。本文将就基于 C#的 ABB 机械臂二次开发相关内容做一个介绍，主要包括与机械臂控制器的连接和断开、机械臂 RAPID 程序变量的读写、机械臂输入信号的监听和输出信号的控制、机械臂当前位姿的读取。</p><h1 id="ABB-SDK"><a href="#ABB-SDK" class="headerlink" title="ABB SDK"></a>ABB SDK</h1><p>经过两年多对机械臂的接触，真心觉得 ABB 机械臂好用。不仅仅是因为精度较高，更重要的是比较开放，支持 C#的二次开发，甚至也支持网络服务器开发，通过 RESTful API 实现控制。个人认为是机械臂行业的龙头老大。</p><p><a href="https://developercenter.robotstudio.com/pc-sdk" target="_blank" rel="noopener">https://developercenter.robotstudio.com/pc-sdk</a></p><p>这个网址是 ABB 机械臂 PC SDK 的开发者中心，提供了 C#、VB 两种语言的二次开发 API 文档和一些简单案例。但目前似乎只支持 Windows 系统。我采用的是 C#语言进行开发。</p><p>在这个网址找到 SDK 安装包并安装到本地，在目录中找到三个 dll 文件(<code>ABB.Robotics.Controllers.PC.dll</code>、<code>RobotStudio.Services.RobApi.dll</code>、<code>RobotStudio.Services.RobApi.Desktop.dll</code>)，在 C#程序中对其进行引用。</p><figure class="image-box">                <img src="/2020/07/10/%E4%B8%80%E6%96%87%E5%AD%A6%E4%BC%9AABB%E6%9C%BA%E6%A2%B0%E8%87%82%E7%9A%84%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91/1.png" alt="ABB SDK结构" title class>                <p>ABB SDK结构</p>            </figure><p>上图是 SDK 源程序的结构图，在项目开头引入对应命名空间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">using ABB.Robotics.Controllers;</span><br><span class="line">using ABB.Robotics.Controllers.Discovery;</span><br><span class="line">using ABB.Robotics.Controllers.MotionDomain;</span><br><span class="line">using ABB.Robotics.Controllers.RapidDomain;</span><br><span class="line">using ABB.Robotics.Controllers.IOSystemDomain;</span><br></pre></td></tr></table></figure><p>然后就可以敲代码实现一些功能了。</p><h1 id="机械臂控制器的连接和断开"><a href="#机械臂控制器的连接和断开" class="headerlink" title="机械臂控制器的连接和断开"></a>机械臂控制器的连接和断开</h1><p>先上代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">private NetworkScanner scanner &#x3D; null;</span><br><span class="line">public Controller robot &#x3D; null;</span><br><span class="line"></span><br><span class="line">private void Form1_Load(object sender, EventArgs e)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;机器人通信模块</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">        scanner &#x3D; new NetworkScanner();</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Exception)</span><br><span class="line">    &#123;</span><br><span class="line">        MessageBox.Show(&quot;ABBSDK初始化错误&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void btn_ConnectRob_Click(object sender, EventArgs e)</span><br><span class="line">&#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;扫描网络中的控制器</span><br><span class="line">        scanner.Scan();</span><br><span class="line">        &#x2F;&#x2F;获取扫描到的控制器信息</span><br><span class="line">        ControllerInfoCollection controllers &#x3D; scanner.Controllers;</span><br><span class="line">        &#x2F;&#x2F;遍历信息</span><br><span class="line">        foreach (ControllerInfo controllerInfo in controllers)</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F;判断控制器是否可用，是否是需要连接的</span><br><span class="line">            if (controllerInfo.Availability &#x3D;&#x3D; Availability.Available &amp;&amp; (controllerInfo.SystemName &#x3D;&#x3D; textB_RobID.Text || controllerInfo.Id &#x3D;&#x3D; textB_RobID.Text))</span><br><span class="line">            &#123;</span><br><span class="line">                &#x2F;&#x2F;创建控制器对象</span><br><span class="line">                robot &#x3D; ControllerFactory.CreateFrom(controllerInfo);</span><br><span class="line">                &#x2F;&#x2F;登录</span><br><span class="line">                robot.Logon(UserInfo.DefaultUser);</span><br><span class="line">                MessageBox.Show(&quot;robot登录成功&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        if (robot &#x3D;&#x3D; null)</span><br><span class="line">        &#123;</span><br><span class="line">            MessageBox.Show(&quot;robot登录失败，未找到对应机械臂&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Exception exception)</span><br><span class="line">    &#123;</span><br><span class="line">        MessageBox.Show(exception.Message, Name, MessageBoxButtons.OK, MessageBoxIcon.Error);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void btn_CloseRob_Click(object sender, EventArgs e)</span><br><span class="line">&#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;判断是否已连接</span><br><span class="line">        if (RobControl.IsConnected(robot))</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F;控制器登出</span><br><span class="line">            robot.Logoff();</span><br><span class="line">            MessageBox.Show(&quot;robot已断开连接&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Exception exception)</span><br><span class="line">    &#123;</span><br><span class="line">        MessageBox.Show(exception.Message, Name, MessageBoxButtons.OK, MessageBoxIcon.Error);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;判断是否连接</span><br><span class="line">public bool IsConnected(Controller controller)</span><br><span class="line">&#123;</span><br><span class="line">    if (controller &#x3D;&#x3D; null || controller.CurrentUser &#x3D;&#x3D; null) return false;</span><br><span class="line">    return controller.Connected;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控件设计如下：<br>两个按钮分别控制控制器的连接和断开，连接控制器时连接名称为 TextBox 文本字符串的控制器。</p><figure class="image-box">                <img src="/2020/07/10/%E4%B8%80%E6%96%87%E5%AD%A6%E4%BC%9AABB%E6%9C%BA%E6%A2%B0%E8%87%82%E7%9A%84%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91/2.png" alt="连接断开控制器" title class>                <p>连接断开控制器</p>            </figure><p>连接控制器的基本流程是：</p><ol><li>先创建一个扫描器，使用<code>Scan()</code>对当前局域网中的所有机械臂控制器进行扫描；</li><li>通过扫描器的<code>Controllers</code>属性将所有信息存入集合中，每个控制器信息以<code>ControllerInfo</code>的形式储存，包含的控制器的名称、ID、IP、是否虚拟、是否可用等信息。</li><li>创建一个<code>Controller</code>对象，调用<code>ControllerFactory.CreateFrom()</code>方法创建控制器，方法传入扫描到的<code>ControllerInfo</code>。</li><li>使用控制器的<code>Logon()</code>方法实现登录。</li></ol><p>断开控制器就比较简单了，对已登录的控制器执行<code>Logoff()</code>方法登出。</p><h1 id="机械臂-RAPID-程序变量的读写"><a href="#机械臂-RAPID-程序变量的读写" class="headerlink" title="机械臂 RAPID 程序变量的读写"></a>机械臂 RAPID 程序变量的读写</h1><p>首先是变量读取：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RapidData rapiddata &#x3D; robot1.Rapid.GetTask(cTasks1.Text.ToString()).GetModule(cBmodules1.Text.ToString()).GetRapidData(cvalue1.Text.ToString());</span><br><span class="line">value1.Text &#x3D; rapiddata.StringValue.ToString();</span><br><span class="line">textBox1.Text &#x3D; rapiddata.RapidType.ToString();</span><br></pre></td></tr></table></figure><p>依次通过 <code>Task</code>、<code>Module</code>、变量名获取对应的<code>RapidData</code>，然后可以通过<code>RapidData</code>的<code>StringValue</code>属性获取值、通过<code>RapidType</code>变量类型。</p><p>对于变量写入，必须要将机械臂控制器置于自动模式，而且要事先知道要修改变量的类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RapidData data &#x3D; robot1.Rapid.GetTask(cTasks1.Text.ToString()).GetModule(cBmodules1.Text.ToString()).GetRapidData(cvalue1.Text.ToString());</span><br><span class="line">if (data.RapidType.ToString() &#x3D;&#x3D; &quot;robtarget&quot;)</span><br><span class="line">&#123;</span><br><span class="line">    RobTarget tempdata &#x3D; (RobTarget)data.Value;</span><br><span class="line">    tempdata.FillFromString2(value1.Text.ToString());</span><br><span class="line">    &#x2F;&#x2F;请求权限并写入控制器</span><br><span class="line">    using (Mastership m &#x3D; Mastership.Request(robot1.Rapid))</span><br><span class="line">    &#123;</span><br><span class="line">        data.Value &#x3D; tempdata;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先读出要写入的变量，获取<code>RapidData</code>类型数据，将其值强制转换为其类型，通过<code>FillFromString2()</code>方法传入新值的内容，然后请求权限将这个值重新赋给<code>RapidData</code>数据的值即可。</p><h1 id="机械臂输入信号的监听和输出信号的控制"><a href="#机械臂输入信号的监听和输出信号的控制" class="headerlink" title="机械臂输入信号的监听和输出信号的控制"></a>机械臂输入信号的监听和输出信号的控制</h1><p>机械臂的 IO 操作需要调用开发包的<code>IOSystem</code>模块。下面针对数字信号，实现信号读取、信号值改变、输入信号监听三个方面。</p><h3 id="信号获取"><a href="#信号获取" class="headerlink" title="信号获取"></a>信号获取</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Signal sig &#x3D; robot.IOSystem.GetSignal(IOName.Text);</span><br><span class="line">DigitalSignal digitalSig &#x3D; (DigitalSignal)sig;</span><br><span class="line">int val &#x3D; digitalSig.Get();</span><br></pre></td></tr></table></figure><p>获取的<code>val</code>即为名为<code>IOName.Text</code>的数字信号的值，为 0 或 1。</p><h3 id="信号写入"><a href="#信号写入" class="headerlink" title="信号写入"></a>信号写入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Signal sig &#x3D; robot1.IOSystem.GetSignal(IOName.Text);</span><br><span class="line">DigitalSignal digitalSig &#x3D; (DigitalSignal)sig;</span><br><span class="line">if (IOValue.Text &#x3D;&#x3D; &quot;1&quot;)</span><br><span class="line">&#123;</span><br><span class="line">    digitalSig.Set();</span><br><span class="line">&#125;</span><br><span class="line">else if (IOValue.Text &#x3D;&#x3D; &quot;0&quot;)</span><br><span class="line">&#123;</span><br><span class="line">    digitalSig.Reset();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>digitalSig.Set()</code>表示将数字信号置 1，<code>digitalSig.Reset()</code>表示将数字信号置 0。</p><h3 id="信号监听"><a href="#信号监听" class="headerlink" title="信号监听"></a>信号监听</h3><p>可以向信号的<code>Changed</code>事件添加预订，该预订在信号状态反转时触发。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Signal sig &#x3D; robot1.IOSystem.GetSignal(IOName.Text);</span><br><span class="line">DigitalSignal digitalSig &#x3D; (DigitalSignal)sig;</span><br><span class="line">sig.Changed +&#x3D; new EventHandler&lt;SignalChangedEventArgs&gt;(sig_Changed);</span><br><span class="line"></span><br><span class="line">private void sig_Changed(object sender, SignalChangedEventArgs e)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;通过e获取监听到的信号状态</span><br><span class="line">    SignalState state &#x3D; e.NewSignalState;</span><br><span class="line">    float val &#x3D; state.Value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>val</code>可以获取监听变量的值，如果值变为期望的状态则可以在后续代码添加相应的动作。</p><h1 id="机械臂当前位姿的读取"><a href="#机械臂当前位姿的读取" class="headerlink" title="机械臂当前位姿的读取"></a>机械臂当前位姿的读取</h1><p>获取当前位姿的功能在开发包的<code>MotionSystem</code>中。获取当前位姿有两种形式：</p><ol><li>一种是获取当前机械臂末端位姿，包含 xyz 坐标和四元数构成的姿态；</li><li>另一种是六个关节的偏移角。</li></ol><p>首先看第一种，获取末端位姿：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RobTarget robtarget &#x3D; robot1.MotionSystem.ActiveMechanicalUnit.GetPosition(CoordinateSystemType.WorkObject);</span><br><span class="line">xvalue.Text &#x3D; robtarget.Trans.X.ToString();</span><br><span class="line">yvalue.Text &#x3D; robtarget.Trans.Y.ToString();</span><br><span class="line">zvalue.Text &#x3D; robtarget.Trans.Z.ToString();</span><br><span class="line">q1value.Text &#x3D; robtarget.Rot.Q1.ToString();</span><br><span class="line">q2value.Text &#x3D; robtarget.Rot.Q2.ToString();</span><br><span class="line">q3value.Text &#x3D; robtarget.Rot.Q3.ToString();</span><br><span class="line">q4value.Text &#x3D; robtarget.Rot.Q4.ToString();</span><br></pre></td></tr></table></figure><p>然后是第二种，获取六关节偏移角：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">JointTarget jointtarget &#x3D; robot1.MotionSystem.ActiveMechanicalUnit.GetPosition();</span><br><span class="line">value1.Text &#x3D; a.RobAx.Rax_1.ToString();</span><br><span class="line">value2.Text &#x3D; a.RobAx.Rax_2.ToString();</span><br><span class="line">value3.Text &#x3D; a.RobAx.Rax_3.ToString();</span><br><span class="line">value4.Text &#x3D; a.RobAx.Rax_4.ToString();</span><br><span class="line">value5.Text &#x3D; a.RobAx.Rax_5.ToString();</span><br><span class="line">value6.Text &#x3D; a.RobAx.Rax_6.ToString();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SDK二次开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SDK二次开发 </tag>
            
            <tag> 机械臂 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>玩转canvas</title>
      <link href="/2020/06/09/%E7%8E%A9%E8%BD%ACcanvas/"/>
      <url>/2020/06/09/%E7%8E%A9%E8%BD%ACcanvas/</url>
      
        <content type="html"><![CDATA[<h2 id="lt-canvas-gt-标签"><a href="#lt-canvas-gt-标签" class="headerlink" title="&lt;canvas&gt;标签"></a><code>&lt;canvas&gt;</code>标签</h2><p><code>&lt;canvas&gt;</code> 是 HTML5 新增的元素，可用于通过使用 JavaScript 中的脚本来绘制图形。使用<code>&lt;canvas&gt;</code>标签时，建议要成对出现，不要使用闭合的形式。</p><p>IE9 之前的浏览器不支持 canvas，可以在<code>&lt;canvas&gt;</code>标签中提供替换内容。支持 canvas 的浏览器将会忽略在容器中包含的内容，并正常渲染 canvas。不支持 canvas 的浏览器会显示代替内容。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"test"</span> <span class="attr">width</span>=<span class="string">"300"</span> <span class="attr">height</span>=<span class="string">"300"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>您的浏览器不支持画布元素<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="canvas-自身属性"><a href="#canvas-自身属性" class="headerlink" title="canvas 自身属性"></a>canvas 自身属性</h2><p><code>&lt;canvas&gt;</code>标签只有两个可选属性：width 和 height。所设置的宽高为画布在对应方向的 CSS 像素个数。当没有设置宽高的时候，会初始化宽度为 300 像素、高度为 150 像素。不支持在 CSS 中设置 canvas 标签的宽高，会产生其他效果。</p><p><code>&lt;canvas&gt;</code>元素有一个叫做 <code>getContext()</code> 的方法，这个方法只有一个参数，上下文的格式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'tutorial'</span>)</span><br><span class="line"><span class="keyword">if</span> (canvas.getContext) &#123;</span><br><span class="line">  <span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="矩形绘制"><a href="#矩形绘制" class="headerlink" title="矩形绘制"></a>矩形绘制</h2><p>canvas 中，矩形是唯一不需要绘制路径的图形。有三种方法绘制矩形：</p><ol><li>绘制一个填充的矩形（填充色默认为黑色）：<code>fillRect(x, y, width, height)</code></li><li>绘制一个矩形的边框（默认边框为:一像素实心黑色）：<code>strokeRect(x, y, width, height)</code></li><li>清除指定矩形区域，让清除部分完全透明：<code>clearRect(x, y, width, height)</code></li></ol><p>x 与 y 指定了画布上所绘制矩形左上角相对于画布左上角的坐标。width 和 height 设置矩形的尺寸。存在边框的话，边框会在 width 和 height 上占据一个边框的宽度，边框宽度在偏移量上下各渲染一半，一旦出现小数边框会向上取整。</p><p>需要注意的是，这些方法是作为元素的方法使用的，函数中的数值不加单位。</p><h2 id="图形样式"><a href="#图形样式" class="headerlink" title="图形样式"></a>图形样式</h2><p>canvas 中有一些设置图形颜色的属性：</p><ul><li>fillStyle 设置图形的填充颜色，也可以是背景或渐变。</li><li>strokeStyle 设置图形轮廓的颜色。</li></ul><p>默认情况下，线条和填充颜色都是黑色。</p><p>lineWidth 用来设置当前绘线的粗细。属性值为正数。描述线段宽度的数字是 0、负数、Infinity 和 NaN 会被忽略。默认值是 1.0。</p><p>lineJoin 用来设定线条与线条间接合处的样式（默认是 miter）</p><ul><li>round：圆角</li><li>bevel：斜角</li><li>miter：直角</li></ul><p>需要注意的是，canvas 中必须应用图形样式（设置画笔），在进行绘图。</p><h2 id="绘制一般路径"><a href="#绘制一般路径" class="headerlink" title="绘制一般路径"></a>绘制一般路径</h2><p>路径是通过不同颜色和宽度的线段或曲线相连形成的不同形状的点的集合。</p><p>canvas 路径绘制步骤：</p><ol><li>首先，你需要创建路径起始点。</li><li>然后你使用画图命令去画出路径</li><li>之后你把路径封闭。</li><li>一旦路径生成，你就能通过描边或填充路径区域来渲染图形。</li></ol><p>相关方法：</p><ul><li><code>moveTo(x, y)</code>：将笔触移动到指定的坐标 x 以及 y 上，通常用来设置起点。</li><li><code>lineTo(x, y)</code>：将笔触移动到指定的坐标 x 以及 y 上，绘制一条从当前位置到指定 x 以及 y 位置的直线。</li><li><code>stroke()</code>：通过线条来绘制图形轮廓。</li><li><code>fill()</code>：通过填充路径的内容区域生成实心的图形。</li><li><code>closePath()</code>：通过绘制一条从当前点到开始点的直线来闭合图形。不是必需的。这个方法会之后图重新指向到上下文中。<code>fill()</code>自动调用<code>closePath()</code>。</li><li><code>beginPath()</code>：新建一条路径，图形绘制命令被指向到路径上准备生成路径。路径是由很多子路径构成，这些子路径都是在一个列表中。每次这个方法调用之后，列表清空重置，就可以重新绘制新的图形。</li></ul><p>绘制矩形：<code>rect(x, y, width, height)</code>。<br>绘制一个左上角坐标为（x,y），宽高为 width 以及 height 的矩形。当该方法执行的时候，moveTo()方法自动设置坐标参数（0,0）。</p><p><code>lineCap</code> 是 Canvas 2D API 指定如何绘制每一条线段末端的属性。有 3 个可能的值：</p><ul><li>butt：线段末端以方形结束。</li><li>round：线段末端以圆形结束。</li><li>square：线段末端以方形结束，但是增加了一个宽度和线段相同，高度是线段厚度一半的矩形区域<br>默认值是 butt。</li></ul><p><code>save()</code> 可以将当前状态(样式相关和变换相关)放入栈中，保存 canvas 全部状态。保存到栈中的绘制状态有下面部分组成：</p><ul><li>当前的变换矩阵。</li><li>当前的剪切区域。</li><li>当前的虚线列表。</li><li>以下属性当前的值：strokeStyle,fillStyle,lineWidth,lineCap,lineJoin…</li></ul><p><code>restore()</code> 将绘图状态栈中顶端的状态弹出到样式容器，将 canvas 恢复到最近的保存状态的方法。如果没有保存状态，此方法不做任何改变。图像的渲染依赖于样式容器。</p><p><code>save()</code>和<code>restore()</code>常成对出现，分隔同一画布不同的图形。绘制路径的基本模板如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.querySelector(<span class="string">'#test'</span>)</span><br><span class="line"><span class="keyword">if</span> (canvas.getContext) &#123;</span><br><span class="line">  <span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>)</span><br><span class="line"></span><br><span class="line">  ctx.save()</span><br><span class="line">  <span class="comment">//关于样式的设置</span></span><br><span class="line">  <span class="comment">//save  restore成对出现</span></span><br><span class="line">  ctx.beginPath()</span><br><span class="line">  <span class="comment">//关于路径</span></span><br><span class="line">  ctx.restore()</span><br><span class="line"></span><br><span class="line">  ctx.save()</span><br><span class="line">  <span class="comment">//关于样式的设置</span></span><br><span class="line">  ctx.beginPath()</span><br><span class="line">  <span class="comment">//关于路径</span></span><br><span class="line"></span><br><span class="line">  ctx.fill()</span><br><span class="line">  ctx.restore()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>路径容器、样式容器和样式栈：</p><ol><li>路径容器：<br>每次调用路径 api 时,都会往路径容器里做登记；<br>调用 beginPath 时,清空整个路径容器。</li><li>样式容器：<br>每次调用样式 api 时,都会往样式容器里做登记；<br>调用 save 时候,将样式容器里的状态压入样式栈；<br>调用 restor 时候,将样式栈的栈顶状态弹出到样式样式容器里,进行覆盖。</li><li>样式栈：<br>调用 save 时候,将样式容器里的状态压入样式栈；<br>调用 restor 时候,将样式栈的栈顶状态弹出到样式样式容器里,进行覆盖。</li></ol><h2 id="绘制曲线"><a href="#绘制曲线" class="headerlink" title="绘制曲线"></a>绘制曲线</h2><p>角度与弧度的 js 表达式:<code>radians=(Math.PI/180)*degrees</code>。</p><p><code>arc(x, y, radius, startAngle, endAngle, anticlockwise)</code>可以画一个以（x,y）为圆心以 radius 为半径的圆弧（圆），从 startAngle 开始到 endAngle 结束，按 anticlockwise 给定方向（默认为顺时针，ture 为逆时针，false 为顺时针）生成。</p><p><code>arcTo(x1, y1, x2, y2, radius)</code>根据给定的控制点和半径画一段圆弧。会从当前位置出发，在(x2 y2)结束。(x1 y1)是控制点，用来控制方向但不一定经过。</p><p><code>quadraticCurveTo(cp1x, cp1y, x, y)</code>绘制二次贝塞尔曲线，cp1x,cp1y 为一个控制点，x,y 为结束点。</p><p><code>bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)</code>绘制三次贝塞尔曲线，cp1x,cp1y 为控制点一，cp2x,cp2y 为控制点二，x,y 为结束点。</p><h2 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h2><p><code>translate(x, y)</code>用来移动 canvas 的<strong>原点</strong>到一个不同的位置。x 是左右偏移量，y 是上下偏移量。在 canvas 中 translate 是累加的。</p><p><code>rotate(angle)</code>可以以顺时针偏转一定的角度，以弧度为单位。旋转的中心点始终是 canvas 的原点，如果要改变原点需要用到 translate 方法。在 canvas 中 rotate 是累加的。</p><p><code>scale(x, y)</code>用来缩放图画，x,y 分别是横轴和纵轴的缩放因子，必须是正值。值比 1.0 小表示缩小，比 1.0 大则表示放大，值为 1.0 时什么效果都没有。一般用它来增减图形在 canvas 中的像素数目，对形状、位图进行缩小或者放大，图像的像素不发生变化。在 canvas 中 scale 是累加的。</p><h2 id="插入图片和图片背景"><a href="#插入图片和图片背景" class="headerlink" title="插入图片和图片背景"></a>插入图片和图片背景</h2><ol><li>canvas 操作图片时，必须要等图片加载完才能操作；</li><li><code>drawImage(image, x, y, width, height)</code><br>其中 image 是 image 或者 canvas 对象，x 和 y 是其在目标 canvas 里的起始坐标，width 和 height 用来控制当图片插入时应该缩放的大小。</li></ol><p>使用<code>Image</code>类创建图片，在图片加载完成后添加到画布中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="keyword">new</span> Image()</span><br><span class="line">img.src = <span class="string">'1.png'</span></span><br><span class="line">img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  draw()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ctx.drawImage(img, <span class="number">0</span>, <span class="number">0</span>, img.width, img.height)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>图片也可作为背景插入到画布中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="keyword">new</span> Image()</span><br><span class="line">img.src = <span class="string">'1.png'</span></span><br><span class="line">img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  draw()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> pattern = ctx.createPattern(img, <span class="string">'no-repeat'</span>)</span><br><span class="line">  ctx.fillStyle = pattern</span><br><span class="line">  ctx.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">300</span>, <span class="number">300</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>createPattern(image, repetition)</code><br>用来设置背景图片，第一个参数 image：图像源。第二个参数 repetition：”repeat”、”repeat-x”、”repeat-y”、”no-repeat”。<br>一般情况下，将 createPattern 返回的对象作为 fillstyle 的值，并在 fillRect 中设置背景大小。</p><h2 id="渐变背景"><a href="#渐变背景" class="headerlink" title="渐变背景"></a>渐变背景</h2><p>与 CSS3 的渐变类似，分为线性渐变和径向渐变。</p><p>线性渐变使用<code>createLinearGradient(x1, y1, x2, y2)</code>，(x1,y1)、(x2,y2)<br>表示渐变的起点与终点。<br><code>gradient.addColorStop(position, color)</code>用来设置渐变的颜色和位置，gradient 是 createLinearGradient 的返回值：</p><ul><li>position 参数必须是一个 0.0 与 1.0 之间的数值，表示渐变中颜色所在的相对位置；</li><li>color 参数是一个有效的 CSS 颜色值。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gradient = ctx.createLinearGradient(<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">200</span>)</span><br><span class="line">gradient.addColorStop(<span class="number">0</span>, <span class="string">'red'</span>)</span><br><span class="line">gradient.addColorStop(<span class="number">0.5</span>, <span class="string">'yellow'</span>)</span><br><span class="line">gradient.addColorStop(<span class="number">1</span>, <span class="string">'green'</span>)</span><br><span class="line">ctx.fillStyle = gradient</span><br><span class="line">ctx.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">300</span>, <span class="number">300</span>)</span><br></pre></td></tr></table></figure><p>与线性渐变类似，径向渐变更换了函数<code>createRadialGradient(x1, y1, r1, x2, y2, r2)</code>。其中前三个参数则定义另一个以(x1,y1) 为原点，半径为 r1 的圆，后三个参数则定义另一个以 (x2,y2) 为原点，半径为 r2 的圆。</p><h2 id="像素操作"><a href="#像素操作" class="headerlink" title="像素操作"></a>像素操作</h2><p><code>getImageData(sx, sy, sw, sh)</code>获得一个包含画布场景像素数据的 <code>ImageData</code> 对象,它代表了画布区域的对象数据。sx 和 sy 表示将要被提取的图像数据矩形区域的左上角 x 和 y 坐标。sw 和 sh 表示将要被提取的图像数据矩形区域的宽度和高度。</p><p><code>ImageData</code> 对象中存储着 canvas 对象真实的像素数据，它包含以下几个只读属性：</p><ul><li>width：图片宽度，单位是像素</li><li>height：图片高度，单位是像素</li><li>data：Uint8ClampedArray 类型的一维数组，包含着 RGBA 格式的整型数据，范围在 0 至 255 之间。</li></ul><p><code>putImageData(myImageData, dx, dy)</code>方法去对场景进行像素数据的写入。dx 和 dy 参数表示在场景内绘制区域的左上角坐标。</p><p><code>createImageData(width, height)</code>用来创建<code>ImageData</code> 对象。</p><h2 id="图片的覆盖合成"><a href="#图片的覆盖合成" class="headerlink" title="图片的覆盖合成"></a>图片的覆盖合成</h2><p>全局透明度通过<code>globalAlpha = value</code>设置，影响到 canvas 里所有图形的透明度，值为 0 到 1，默认为 1。</p><p>定义下面两个概念：</p><ul><li>source:新的图像(源)；</li><li>destination:已经绘制过的图形(目标)。</li></ul><p>通过<code>globalCompositeOperation</code>设置合成图像的显示，有如下取值：</p><ul><li>“source-over”(默认值):源在上面,新的图像层级比较高</li><li>“source-in”:只留下源与目标的重叠部分(源的那一部分)</li><li>“source-out”:只留下源超过目标的部分</li><li>“source-atop”:砍掉源溢出的部分</li><li>“destination-over”:目标在上面,旧的图像层级比较高</li><li>“destination-in”:只留下源与目标的重叠部分(目标的那一部分)</li><li>“destination-out”:只留下目标超过源的部分</li><li>“destination-atop”:砍掉目标溢出的部分</li></ul><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>canvas 中有一个事件可以在选到画布中某些位置时触发：<code>isPointInPath(x, y)</code>。这个方法用于判断在当前路径中是否包含检测点，x 和 y 是检测点的 XY 坐标。此方法只作用于最新画出的 canvas 图像，即最后一个 beginPath()后的路径。</p>]]></content>
      
      
      <categories>
          
          <category> 动画 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 使用手册 </tag>
            
            <tag> 前端 </tag>
            
            <tag> 动画 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原生js函数的理解</title>
      <link href="/2020/06/06/%E5%8E%9F%E7%94%9Fjs%E5%87%BD%E6%95%B0%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2020/06/06/%E5%8E%9F%E7%94%9Fjs%E5%87%BD%E6%95%B0%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="函数的作用及用法"><a href="#函数的作用及用法" class="headerlink" title="函数的作用及用法"></a>函数的作用及用法</h1><h2 id="什么是函数"><a href="#什么是函数" class="headerlink" title="什么是函数?"></a>什么是函数?</h2><ul><li>具有特定功能的 n 条语句的封装体</li><li>只有函数是可执行的，其它类型的数据是不可执行的</li><li>函数也是对象，<code>instanceof Object===true</code></li></ul><h2 id="为什么要用函数"><a href="#为什么要用函数" class="headerlink" title="为什么要用函数?"></a>为什么要用函数?</h2><ul><li>提高代码复用</li><li>便于阅读和交流</li></ul><h2 id="如何定义函数"><a href="#如何定义函数" class="headerlink" title="如何定义函数?"></a>如何定义函数?</h2><ul><li>函数声明</li><li>表达式</li></ul><h2 id="调用-执行-函数"><a href="#调用-执行-函数" class="headerlink" title="调用(执行)函数"></a>调用(执行)函数</h2><ul><li>直接调用：<code>test()</code></li><li>构造函数：<code>new test()</code></li><li>对象方法：<code>obj.test()</code></li><li>间接调用其他对象方法：<code>test.call/apply(obj)</code></li></ul><h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>函数<strong>定义</strong>了但<strong>没有直接调用</strong>，但<strong>最终在特定条件下执行了</strong></p><p>常见的回调函数：</p><ul><li>DOM 事件函数</li><li>定时器函数</li><li>ajax 回调函数</li><li>生命周期回调函数</li></ul><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>专业术语为: IIFE (Immediately Invoked Function Expression) 立即调用函数表达式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">;(<span class="function"><span class="keyword">function</span> (<span class="params">w, obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//实现代码</span></span><br><span class="line">&#125;)(<span class="built_in">window</span>, obj)</span><br></pre></td></tr></table></figure><p>作用：</p><ul><li>隐藏内部实现</li><li>不污染外部命名空间</li></ul><h2 id="函数中的-this"><a href="#函数中的-this" class="headerlink" title="函数中的 this"></a>函数中的 this</h2><ul><li>显式指定谁：<code>obj.xxx()</code></li><li>通过 call/apply 指定谁调用：<code>xxx.call(obj)</code></li><li>不指定谁调用：<code>xxx() : window</code></li><li>回调函数：看背后是通过谁来调用的，window/其它</li></ul><h1 id="原型与原型链"><a href="#原型与原型链" class="headerlink" title="原型与原型链"></a>原型与原型链</h1><h2 id="原型-prototype"><a href="#原型-prototype" class="headerlink" title="原型 prototype"></a>原型 prototype</h2><p>每个函数都有一个 prototype 属性, 它默认指向一个 Object 空对象(即称为: 原型对象)。原型对象中有一个属性 constructor, 它指向函数对象。</p><p>给原型对象添加属性(一般都是方法)，可以使函数的所有实例对象自动拥有原型中的属性(方法)。因此原型一般只在创建实例对象时起作用。</p><h2 id="显式原型和隐式原型"><a href="#显式原型和隐式原型" class="headerlink" title="显式原型和隐式原型"></a>显式原型和隐式原型</h2><p>每个函数 function 都有一个<code>prototype</code>属性，即显式原型；每个实例对象都有一个<code>__proto__</code>属性，可称为隐式原型。对象的隐式原型的值为其对应构造函数的显式原型的值。</p><figure class="image-box">                <img src="/2020/06/06/%E5%8E%9F%E7%94%9Fjs%E5%87%BD%E6%95%B0%E7%9A%84%E7%90%86%E8%A7%A3/1.png" alt="显式原型和隐式原型" title class>                <p>显式原型和隐式原型</p>            </figure><p>函数的 prototype 属性在定义函数时自动添加，默认值是一个空 Object 对象；对象的 proto 属性在创建对象时自动添加，默认值为构造函数的 prototype 属性值。</p><p>原型对象即为当前实例对象的父对象。</p><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>所有的实例对象都有<code>__proto__</code>属性，指向原型对象。这样通过<code>__proto__</code>属性就形成了一个链的结构——原型链。</p><p>当查找对象内部的属性/方法时，js 引擎自动沿着这个原型链查找：先在自身属性中查找，找到返回；如果没有，再沿原型链向上查找，找到返回；如果最终没找到，返回 undefined。<br>当给对象属性赋值时不会使用原型链，而只是在当前对象中进行操作。</p><h1 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h1><h2 id="变量提升与函数提升"><a href="#变量提升与函数提升" class="headerlink" title="变量提升与函数提升"></a>变量提升与函数提升</h2><p>变量声明提升：通过 var 定义(声明)的变量，在定义语句之前就可以访问到。值为 undefined。<br>函数声明提升：通过 function 声明的函数，在之前就可以直接调用值为函数定义(对象)。<br>先有变量提升, 再有函数提升。</p><h2 id="执行上下文-1"><a href="#执行上下文-1" class="headerlink" title="执行上下文"></a>执行上下文</h2><p>执行上下文是由 js 引擎自动创建的对象，包含对应作用域中的所有变量属性。</p><p>将代码分为全局代码和函数代码两种。</p><p>全局执行上下文：在执行全局代码前将 window 确定为全局执行上下文，对全局数据进行预处理。var 定义的全局变量==&gt;undefined，添加为 window 的属性；function 声明的全局函数==&gt;赋值(fun)，添加为 window 的方法；this==&gt;赋值(window)。然后开始执行全局代码。 当页面刷新/关闭时死亡。</p><p>函数执行上下文：在调用函数，准备执行函数体之前，创建对应的函数执行上下文对象。对局部数据进行预处理。形参变量==&gt;赋值(实参)==&gt;添加为执行上下文的属性；arguments==&gt;赋值(实参列表的伪数组)，添加为执行上下文的属性；var 定义的局部变量==&gt;undefined，添加为执行上下文的属性；function 声明的函数 ==&gt;赋值(fun)，添加为执行上下文的方法；this==&gt;赋值(调用函数的对象，如果没有指定就是 window)。然后开始执行函数体代码。函数执行完时死亡。</p><h2 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h2><ol><li>在全局代码执行前，JS 引擎就会创建一个栈来存储管理所有的执行上下文对象；</li><li>在全局执行上下文(window)确定后，将其添加到栈中(压栈)；</li><li>在函数执行上下文创建后，将其添加到栈中(压栈)；</li><li>在当前函数执行完后，将栈顶的对象移除(出栈)；</li><li>当所有的代码执行完后，栈中只剩下 window。</li></ol><h1 id="作用域与作用域链"><a href="#作用域与作用域链" class="headerlink" title="作用域与作用域链"></a>作用域与作用域链</h1><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>作用域就是一块代码区域。它是静态的(相对于上下文对象)，在编写代码时就确定了。作用是隔离变量，不同作用域下同名变量不会有冲突。</p><p>分类：</p><ul><li>全局作用域</li><li>函数作用域</li><li>块作用域</li></ul><h2 id="作用域与执行上下文"><a href="#作用域与执行上下文" class="headerlink" title="作用域与执行上下文"></a>作用域与执行上下文</h2><ol><li><p>区别 1</p><ul><li>全局作用域之外，每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了。而不是在函数调用时；</li><li>全局执行上下文环境是在全局作用域确定之后, js 代码马上执行之前创建；</li><li>函数执行上下文环境是在调用函数时, 函数体代码执行之前创建。</li></ul></li><li><p>区别 2</p><ul><li>作用域是静态的, 只要函数定义好了就一直存在, 且不会再变化；</li><li>上下文环境是动态的, 调用函数时创建, 函数调用结束时上下文环境就会被释放。</li></ul></li><li><p>联系：上下文环境(对象)是从属于所在的作用域</p><ul><li>全局上下文环境==&gt;全局作用域；</li><li>函数上下文环境==&gt;对应的函数使用域。</li></ul></li></ol><h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>多个上下级关系的作用域形成的链，它的方向是从内到外，查找变量时就是沿着作用域链来查找，直到全局作用域, 如果还找不到就抛出找不到的异常。</p><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><h2 id="闭包的概念"><a href="#闭包的概念" class="headerlink" title="闭包的概念"></a>闭包的概念</h2><p>当一个嵌套的内部(子)函数引用了嵌套的外部(父)函数的变量(函数)时, 就产生了闭包。闭包存在于嵌套的内部函数中。</p><p>产生闭包的条件是函数嵌套以及内部函数引用了外部函数的数据(变量/函数)。</p><p>闭包可以理解为嵌套的内部函数，也可以理解为包含被引用变量(函数)。</p><p>闭包程序示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    a++</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fn2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = fn1()</span><br><span class="line">f()</span><br><span class="line">f()</span><br></pre></td></tr></table></figure><h2 id="闭包的意义"><a href="#闭包的意义" class="headerlink" title="闭包的意义"></a>闭包的意义</h2><p>作用：</p><ol><li>使函数内部的变量在函数执行完后,仍然存活在内存中(延长了局部变量的生命周期)；</li><li>让函数外部可以操作到函数内部的数据(变量/函数)。</li></ol><p>缺点:</p><ol><li>变量占用内存的时间可能会过长；</li><li>可能导致内存泄露。</li></ol><ul><li>解决：及时释放，让内部函数对象成为垃圾对象。<code>f = null</code></li></ul><p>应用：</p><p>闭包应用:</p><ul><li>模块化: 封装一些数据以及操作数据的函数, 向外暴露一些行为；</li><li>循环遍历加监听。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用的js函数库</title>
      <link href="/2020/05/26/%E5%B8%B8%E7%94%A8%E7%9A%84js%E5%87%BD%E6%95%B0%E5%BA%93/"/>
      <url>/2020/05/26/%E5%B8%B8%E7%94%A8%E7%9A%84js%E5%87%BD%E6%95%B0%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h2 id="递归实现深拷贝"><a href="#递归实现深拷贝" class="headerlink" title="递归实现深拷贝"></a>递归实现深拷贝</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> objClone = <span class="built_in">Array</span>.isArray(obj) ? [] : &#123;&#125;</span><br><span class="line">  <span class="keyword">if</span> (obj &amp;&amp; <span class="keyword">typeof</span> obj === <span class="string">'object'</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">      <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">        <span class="comment">//判断obj的子元素是否为object对象，如果是则就递归拷贝</span></span><br><span class="line">        <span class="keyword">if</span> (obj[key] &amp;&amp; <span class="keyword">typeof</span> obj[key] === <span class="string">'object'</span>) &#123;</span><br><span class="line">          objClone[key] = deepClone(obj[key])</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//如果不为对象就直接拷贝</span></span><br><span class="line">          objClone[key] = obj[key]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> objClone</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递归实现深拷贝-1"><a href="#递归实现深拷贝-1" class="headerlink" title="递归实现深拷贝"></a>递归实现深拷贝</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> objClone = <span class="built_in">Array</span>.isArray(obj) ? [] : &#123;&#125;</span><br><span class="line">  <span class="keyword">if</span> (obj &amp;&amp; <span class="keyword">typeof</span> obj === <span class="string">'object'</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">      <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">        <span class="comment">//判断obj的子元素是否为object对象，如果是则就递归拷贝</span></span><br><span class="line">        <span class="keyword">if</span> (obj[key] &amp;&amp; <span class="keyword">typeof</span> obj[key] === <span class="string">'object'</span>) &#123;</span><br><span class="line">          objClone[key] = deepClone(obj[key])</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//如果不为对象就直接拷贝</span></span><br><span class="line">          objClone[key] = obj[key]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> objClone</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一天搞定TypeScript</title>
      <link href="/2020/05/22/%E4%B8%80%E5%A4%A9%E6%90%9E%E5%AE%9ATypeScript/"/>
      <url>/2020/05/22/%E4%B8%80%E5%A4%A9%E6%90%9E%E5%AE%9ATypeScript/</url>
      
        <content type="html"><![CDATA[<h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><p>JavaScript 的类型分为两种：原始数据类型（Primitive data types）和对象类型（Object types）。<br>原始数据类型包括布尔值、数值、字符串、null、undefined 以及 ES6 中的新类型 Symbol。<br>对象类型包括数组、函数以及普通对象。<br>TypeScript 在这些类型的基础上衍生出元组、枚举、any、void、never 等。</p><p>TypeScript 的一个比较重要的功能就是类型检查，如果类型不符就会报错。下面对一些简单基本类型的检查进行列举。  </p><h4 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isDone: <span class="built_in">boolean</span> = <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>注意，使用构造函数 Boolean 创造的对象不是布尔值：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> createdByNewBoolean: <span class="built_in">boolean</span> = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="number">1</span>) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>事实上 new Boolean() 返回的是一个 Boolean 对象：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> createdByNewBoolean: <span class="built_in">Boolean</span> = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>直接调用 Boolean 也可以返回一个 boolean 类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> createdByBoolean: <span class="built_in">boolean</span> = <span class="built_in">Boolean</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>其他基本类型（除了 null 和 undefined）一样，不再赘述。</p><h4 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> decLiteral: <span class="built_in">number</span> = <span class="number">6</span></span><br><span class="line"><span class="keyword">let</span> hexLiteral: <span class="built_in">number</span> = <span class="number">0xf00d</span></span><br><span class="line"><span class="comment">// ES6 中的二进制表示法</span></span><br><span class="line"><span class="keyword">let</span> binaryLiteral: <span class="built_in">number</span> = <span class="number">0b1010</span></span><br><span class="line"><span class="comment">// ES6 中的八进制表示法</span></span><br><span class="line"><span class="keyword">let</span> octalLiteral: <span class="built_in">number</span> = <span class="number">0o744</span></span><br><span class="line"><span class="keyword">let</span> notANumber: <span class="built_in">number</span> = <span class="literal">NaN</span></span><br><span class="line"><span class="keyword">let</span> infinityNumber: <span class="built_in">number</span> = <span class="literal">Infinity</span></span><br></pre></td></tr></table></figure><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myName: <span class="built_in">string</span> = <span class="string">'Tom'</span></span><br></pre></td></tr></table></figure><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>写法一：「类型 + 方括号」表示法</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fibonacci: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure><p>写法二：数组泛型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fibonacci: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure><h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h4><p>数组合并了相同类型的对象，而元组（Tuple）合并了不同类型的对象：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tom: [<span class="built_in">string</span>, <span class="built_in">number</span>] = [<span class="string">'Tom'</span>, <span class="number">25</span>]</span><br></pre></td></tr></table></figure><p>2.6 版本后，元素个数和类型必须与声明的个数和类型一致。</p><h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><p>枚举（Enum）类型用于取值被限定在一定范围内的场景，比如一周只能有七天，颜色限定为红绿蓝等。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Days &#123;</span><br><span class="line">  Sun,</span><br><span class="line">  Mon,</span><br><span class="line">  Tue,</span><br><span class="line">  Wed,</span><br><span class="line">  Thu,</span><br><span class="line">  Fri,</span><br><span class="line">  Sat,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Days[<span class="string">'Sun'</span>] === <span class="number">0</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Days[<span class="string">'Sat'</span>] === <span class="number">6</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Days[<span class="number">0</span>] === <span class="string">'Sun'</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Days[<span class="number">6</span>] === <span class="string">'Sat'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>也可以给枚举项手动赋值：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Days &#123;</span><br><span class="line">  Sun = <span class="number">7</span>,</span><br><span class="line">  Mon,</span><br><span class="line">  Tue,</span><br><span class="line">  Wed,</span><br><span class="line">  Thu,</span><br><span class="line">  Fri,</span><br><span class="line">  Sat,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Days[<span class="string">'Mon'</span>] === <span class="number">8</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面的例子中，未手动赋值的枚举项会接着上一个枚举项递增。如果未手动赋值的枚举项与手动赋值的重复了，TypeScript 不会察觉到这一点，后面的值会覆盖前面的值，手动赋值的枚举项也可以为小数或负数。</p><p>常数枚举是使用 const enum 定义的枚举类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> Directions &#123;</span><br><span class="line">  Up,</span><br><span class="line">  Down,</span><br><span class="line">  Left,</span><br><span class="line">  Right,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> directions = [</span><br><span class="line">  Directions.Up,</span><br><span class="line">  Directions.Down,</span><br><span class="line">  Directions.Left,</span><br><span class="line">  Directions.Right,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>常数枚举与普通枚举的区别是，它会在编译阶段被删除，并且不能包含计算成员，压缩了代码体积。上例的编译结果是：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> directions = [<span class="number">0</span> <span class="comment">/* Up */</span>, <span class="number">1</span> <span class="comment">/* Down */</span>, <span class="number">2</span> <span class="comment">/* Left */</span>, <span class="number">3</span> <span class="comment">/* Right */</span>]</span><br></pre></td></tr></table></figure><h4 id="any"><a href="#any" class="headerlink" title="any"></a>any</h4><p>任意值（Any）用来表示允许赋值为任意类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr: <span class="built_in">any</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">'a'</span>, <span class="string">'b'</span>]</span><br></pre></td></tr></table></figure><h4 id="void"><a href="#void" class="headerlink" title="void"></a>void</h4><p>一般用 void 表示没有任何返回值的函数：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">alertName</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  alert(<span class="string">'My name is Tom'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="null-和-undefined"><a href="#null-和-undefined" class="headerlink" title="null 和 undefined"></a>null 和 undefined</h4><p>在 TypeScript 中，可以使用 null 和 undefined 来定义这两个原始数据类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> u: <span class="literal">undefined</span> = <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">let</span> n: <span class="literal">null</span> = <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>与 void 的区别是，undefined 和 null 是所有类型的子类型。也就是说 undefined 类型的变量，可以赋值给 number 类型的变量：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1: <span class="built_in">number</span> = <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> u: <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">let</span> num2: <span class="built_in">number</span> = u</span><br></pre></td></tr></table></figure><h4 id="never"><a href="#never" class="headerlink" title="never"></a>never</h4><p>never 一般用于抛出异常或陷入死循环的情况：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> errorFunc = (massage: <span class="built_in">string</span>): <span class="function"><span class="params">never</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> infiniteFunc = (): <span class="function"><span class="params">never</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="object"><a href="#object" class="headerlink" title="object"></a>object</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o: object = &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h4><p>如果没有明确的指定类型，那么 TypeScript 会依照类型断言（Type Inference）的规则推断出一个类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myFavoriteNumber = <span class="string">'seven'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myFavoriteNumber: <span class="built_in">string</span> = <span class="string">'seven'</span></span><br></pre></td></tr></table></figure><p>如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myFavoriteNumber</span><br><span class="line">myFavoriteNumber = <span class="string">'seven'</span></span><br><span class="line">myFavoriteNumber = <span class="number">7</span></span><br></pre></td></tr></table></figure><h4 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h4><p>联合类型（Union Types）表示取值可以为多种类型中的一种。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myFavoriteNumber: <span class="built_in">string</span> | <span class="built_in">number</span></span><br><span class="line">myFavoriteNumber = <span class="string">'seven'</span></span><br><span class="line">myFavoriteNumber = <span class="number">7</span></span><br></pre></td></tr></table></figure><p>当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型里共有的属性或方法：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLength</span>(<span class="params">something: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> something.length</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误，number没有length属性</span></span><br></pre></td></tr></table></figure><p>联合类型的变量在被赋值的时候，会根据类型推论的规则推断出一个类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myFavoriteNumber: <span class="built_in">string</span> | <span class="built_in">number</span></span><br><span class="line">myFavoriteNumber = <span class="string">'seven'</span></span><br><span class="line"><span class="built_in">console</span>.log(myFavoriteNumber.length) <span class="comment">// 5</span></span><br><span class="line">myFavoriteNumber = <span class="number">7</span></span><br><span class="line"><span class="built_in">console</span>.log(myFavoriteNumber.length) <span class="comment">// 编译时报错</span></span><br></pre></td></tr></table></figure><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>在面向对象语言中，接口（Interfaces）是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类（classes）去实现（implement）。<br>TypeScript 中的接口是一个非常灵活的概念，除了可用于对类的一部分行为进行抽象以外，也常用于对「对象的形状（Shape）」进行描述。</p><h4 id="简单的例子"><a href="#简单的例子" class="headerlink" title="简单的例子"></a>简单的例子</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IPerson &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tom: IPerson = &#123;</span><br><span class="line">  name: <span class="string">'Tom'</span>,</span><br><span class="line">  age: <span class="number">25</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义的变量比接口少了一些属性是不允许的，多一些属性也是不允许的。赋值的时候，变量的形状必须和接口的形状保持一致。</p><h4 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IPerson &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  age?: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tom: IPerson = &#123;</span><br><span class="line">  name: <span class="string">'Tom'</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sam: IPerson = &#123;</span><br><span class="line">  name: <span class="string">'Sam'</span>,</span><br><span class="line">  age: <span class="number">22</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="任意属性"><a href="#任意属性" class="headerlink" title="任意属性"></a>任意属性</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IPerson &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  age?: <span class="built_in">number</span></span><br><span class="line">  [propName: <span class="built_in">string</span>]: <span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tom: IPerson = &#123;</span><br><span class="line">  name: <span class="string">'Tom'</span>,</span><br><span class="line">  gender: <span class="string">'male'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IPerson &#123;</span><br><span class="line">  readonly id: <span class="built_in">number</span></span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  age?: <span class="built_in">number</span></span><br><span class="line">  [propName: <span class="built_in">string</span>]: <span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tom: IPerson = &#123;</span><br><span class="line">  id: <span class="number">89757</span>,</span><br><span class="line">  name: <span class="string">'Tom'</span>,</span><br><span class="line">  gender: <span class="string">'male'</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tom.id = <span class="number">9527</span> <span class="comment">// 报错，id为只读属性</span></span><br></pre></td></tr></table></figure><p>注意，只读属性必须在对象赋值时进行赋值。</p><h4 id="接口的继承"><a href="#接口的继承" class="headerlink" title="接口的继承"></a>接口的继承</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IVegetables &#123;</span><br><span class="line">  color: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> ITomato <span class="keyword">extends</span> IVegetables &#123;</span><br><span class="line">  redius: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tomato: ITomato = &#123;</span><br><span class="line">  redius: <span class="number">1</span>,</span><br><span class="line">  color: <span class="string">'red'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="小应用：计数器"><a href="#小应用：计数器" class="headerlink" title="小应用：计数器"></a>小应用：计数器</h4><p>3.1 版本后，支持了直接给函数添加属性</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ICounter &#123;</span><br><span class="line">  (): <span class="built_in">void</span></span><br><span class="line">  count: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getCounter = (): <span class="function"><span class="params">ICounter</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> c = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    c.count++</span><br><span class="line">  &#125;</span><br><span class="line">  c.count = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counter: ICounter = getCounter()</span><br><span class="line"></span><br><span class="line">counter() <span class="comment">// counter.count === 1</span></span><br><span class="line">counter() <span class="comment">// counter.count === 2</span></span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h4 id="简单的例子-1"><a href="#简单的例子-1" class="headerlink" title="简单的例子"></a>简单的例子</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明（Function Declaration）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式（Function Expression）</span></span><br><span class="line"><span class="keyword">let</span> mySum: <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  x: <span class="built_in">number</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  y: <span class="built_in">number</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，输入多余的（或者少于要求的）参数，是不被允许的。<br>对于函数表达式，注意不要混淆了 TypeScript 中的 =&gt; 和 ES6 中的 =&gt;。在 TypeScript 的类型定义中，=&gt; 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。等号左边的 mySum 可以通过赋值操作进行类型推论而推断出来，故可简写为：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mySum = <span class="function"><span class="keyword">function</span> (<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="用接口定义函数的形状"><a href="#用接口定义函数的形状" class="headerlink" title="用接口定义函数的形状"></a>用接口定义函数的形状</h4><p>采用接口定义函数时，对等号左侧进行类型限制，可以保证以后对函数名赋值时保证参数个数、参数类型、返回值类型不变：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> SearchFunc &#123;</span><br><span class="line">  (source: <span class="built_in">string</span>, subString: <span class="built_in">string</span>): <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySearch: SearchFunc</span><br><span class="line">mySearch = <span class="function"><span class="keyword">function</span> (<span class="params">source: <span class="built_in">string</span>, subString: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> source.search(subString) !== <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="用类型别名定义函数的形状"><a href="#用类型别名定义函数的形状" class="headerlink" title="用类型别名定义函数的形状"></a>用类型别名定义函数的形状</h4><p>类型别名用来给一个类型起个新名字：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SearchFunc = <span class="function">(<span class="params">source: <span class="built_in">string</span>, subString: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">boolean</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySearch: SearchFunc</span><br><span class="line">mySearch = <span class="function"><span class="keyword">function</span> (<span class="params">source: <span class="built_in">string</span>, subString: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> source.search(subString) !== <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h4><p>接口中的可选属性类似，用 ? 表示可选的参数：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: <span class="built_in">string</span>, lastName?: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (lastName) &#123;</span><br><span class="line">    <span class="keyword">return</span> firstName + <span class="string">' '</span> + lastName</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> firstName</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> tomcat = buildName(<span class="string">'Tom'</span>, <span class="string">'Cat'</span>)</span><br><span class="line"><span class="keyword">let</span> tom = buildName(<span class="string">'Tom'</span>)</span><br></pre></td></tr></table></figure><p>需要注意的是，可选参数必须接在必需参数后面。</p><h4 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h4><p>在 ES6 中，我们允许给函数的参数添加默认值，TypeScript 会将添加了默认值的参数识别为可选参数：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: <span class="built_in">string</span>, lastName: <span class="built_in">string</span> = 'Cat'</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> firstName + <span class="string">' '</span> + lastName</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> tomcat = buildName(<span class="string">'Tom'</span>, <span class="string">'Cat'</span>)</span><br><span class="line"><span class="keyword">let</span> tom = buildName(<span class="string">'Tom'</span>)</span><br></pre></td></tr></table></figure><p>此时就不受「可选参数必须接在必需参数后面」的限制了。</p><h4 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h4><p>ES6 中，可以使用 …rest 的方式获取函数中的剩余参数（rest 参数），所以我们可以用数组的类型来定义 rest：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">array: <span class="built_in">any</span>[], ...items: <span class="built_in">any</span>[]</span>) </span>&#123;</span><br><span class="line">  items.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">    array.push(item)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = []</span><br><span class="line">push(a, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>注意，rest 参数只能是最后一个参数。</p><h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><p>重载允许一个函数接受不同数量或类型的参数时，作出不同的处理 ：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x: <span class="built_in">number</span></span>): <span class="title">number</span></span></span><br><span class="line"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x: <span class="built_in">string</span></span>): <span class="title">string</span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x: <span class="built_in">number</span> | <span class="built_in">string</span></span>): <span class="title">number</span> | <span class="title">string</span> </span>&#123;</span></span></span><br><span class="line"><span class="function"><span class="function">  <span class="title">if</span> (<span class="params"><span class="keyword">typeof</span> x === '<span class="built_in">number</span>'</span>) </span>&#123;</span></span><br><span class="line"><span class="function">    <span class="title">return</span> <span class="title">Number</span>(<span class="params">x.toString().split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)</span>)</span></span><br><span class="line"><span class="function">  &#125; <span class="title">else</span> <span class="title">if</span> (<span class="params"><span class="keyword">typeof</span> x === '<span class="built_in">string</span>'</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例中，重复定义了多次函数 reverse，前几次都是函数定义，最后一次是函数实现。注意，TypeScript 会优先从最前面的函数定义开始匹配，所以多个函数定义如果有包含关系，需要优先把精确的定义写在前面。</p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。</p><h4 id="简单的例子-2"><a href="#简单的例子-2" class="headerlink" title="简单的例子"></a>简单的例子</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createArray</span>&lt;<span class="title">T</span>&gt;(<span class="params">length: <span class="built_in">number</span>, value: T</span>): <span class="title">Array</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result: T[] = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    result[i] = value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createArray&lt;<span class="built_in">string</span>&gt;(<span class="number">3</span>, <span class="string">'x'</span>) <span class="comment">// ['x', 'x', 'x']</span></span><br><span class="line"></span><br><span class="line">createArray(<span class="number">3</span>, <span class="number">1</span>) <span class="comment">// [1, 1, 1]</span></span><br></pre></td></tr></table></figure><p>在函数名后添加了 <code>&lt;T&gt;</code>，其中 T 用来指代任意输入的类型，在后面的输入 <code>value: T</code> 和输出 <code>Array&lt;T&gt;</code> 中即可使用，保证了 value 与 Array 类型一致。</p><h4 id="多个类型参数"><a href="#多个类型参数" class="headerlink" title="多个类型参数"></a>多个类型参数</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt;(<span class="params">tuple: [T, U]</span>): [<span class="title">U</span>, <span class="title">T</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [tuple[<span class="number">1</span>], tuple[<span class="number">0</span>]]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">swap([<span class="number">7</span>, <span class="string">'seven'</span>]) <span class="comment">// ['seven', 7]</span></span><br></pre></td></tr></table></figure><h4 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Lengthwise &#123;</span><br><span class="line">  length: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">Lengthwise</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arg.length)</span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例中使用了 extends 约束了泛型 T 必须符合接口 Lengthwise 的形状，也就是必须包含 length 属性。这样写可以使函数中使用 length 属性时不报错，同时也可以为 T 的类型作约束。多个类型参数之间也可以互相约束：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyFields</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">U</span>, <span class="title">U</span>&gt;(<span class="params">target: T, source: U</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> id <span class="keyword">in</span> source) &#123;</span><br><span class="line">    target[id] = (&lt;T&gt;source)[id]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> target</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x = &#123; a: <span class="number">1</span>, b: <span class="number">2</span>, c: <span class="number">3</span>, d: <span class="number">4</span> &#125;</span><br><span class="line"></span><br><span class="line">copyFields(x, &#123; b: <span class="number">10</span>, d: <span class="number">20</span> &#125;)</span><br></pre></td></tr></table></figure><h4 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> CreateArrayFunc &#123;</span><br><span class="line">  &lt;T&gt;(length: <span class="built_in">number</span>, value: T): <span class="built_in">Array</span>&lt;T&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> createArray: CreateArrayFunc</span><br><span class="line">createArray = <span class="function"><span class="keyword">function</span> &lt;<span class="title">T</span>&gt;(<span class="params">length: <span class="built_in">number</span>, value: T</span>): <span class="title">Array</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result: T[] = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    result[i] = value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createArray(<span class="number">3</span>, <span class="string">'x'</span>) <span class="comment">// ['x', 'x', 'x']</span></span><br></pre></td></tr></table></figure><p>也可以把泛型参数提前到接口名上，此时在使用泛型接口的时候，需要定义泛型的类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> CreateArrayFunc&lt;T&gt; &#123;</span><br><span class="line">  (length: <span class="built_in">number</span>, value: T): <span class="built_in">Array</span>&lt;T&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> createArray: CreateArrayFunc&lt;<span class="built_in">any</span>&gt;</span><br><span class="line">createArray = <span class="function"><span class="keyword">function</span> &lt;<span class="title">T</span>&gt;(<span class="params">length: <span class="built_in">number</span>, value: T</span>): <span class="title">Array</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result: T[] = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    result[i] = value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createArray(<span class="number">3</span>, <span class="string">'x'</span>) <span class="comment">// ['x', 'x', 'x']</span></span><br></pre></td></tr></table></figure><h4 id="泛型参数的默认类型"><a href="#泛型参数的默认类型" class="headerlink" title="泛型参数的默认类型"></a>泛型参数的默认类型</h4><p>2.3 以后，可以为泛型中的类型参数指定默认类型。当使用泛型时没有在代码中直接指定类型参数，从实际值参数中也无法推测出时，这个默认类型就会起作用：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createArray</span>&lt;<span class="title">T</span> = <span class="title">string</span>&gt;(<span class="params">length: <span class="built_in">number</span>, value: T</span>): <span class="title">Array</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result: T[] = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    result[i] = value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h4 id="public-private-和-protected"><a href="#public-private-和-protected" class="headerlink" title="public private 和 protected"></a>public private 和 protected</h4><p>TypeScript 可以使用三种访问修饰符（Access Modifiers），分别是 public、private 和 protected：</p><ol><li>public 修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 public 的。</li><li>private 修饰的属性或方法是私有的，不能在声明它的类的外部访问。</li><li>protected 修饰的属性或方法是受保护的，它和 private 类似，区别是它在子类中也是允许被访问的。</li></ol><p>需要注意的是：</p><ol><li>TypeScript 编译之后的代码中，并没有限制 private 属性在外部的可访问性。</li><li>当构造函数修饰为 private 时，该类不允许被继承或者实例化。</li><li>当构造函数修饰为 protected 时，该类只允许被继承。</li><li>修饰符和 readonly 可以使用在构造函数参数中，等同于类中定义该属性同时给该属性赋值。如果 readonly 和其他访问修饰符同时存在的话，需要写在其后面。</li></ol><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>abstract 用于定义抽象类和其中的抽象方法。抽象类不允许被实例化，抽象类中的抽象方法必须被子类实现：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> Animal &#123;</span><br><span class="line">  <span class="keyword">public</span> name</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> sayHi()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Cat <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">  <span class="keyword">public</span> sayHi() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Meow, My name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cat = <span class="keyword">new</span> Cat(<span class="string">'Tom'</span>)</span><br></pre></td></tr></table></figure><p>需要注意的是，即使是抽象方法，TypeScript 的编译结果中，仍然会存在这个类。</p><h4 id="类与接口"><a href="#类与接口" class="headerlink" title="类与接口"></a>类与接口</h4><p>实现（implements）是面向对象中的一个重要概念。一般来讲，一个类只能继承自另一个类，有时候不同类之间可以有一些共有的特性，这时候就可以把特性提取成接口（interfaces），用 implements 关键字来实现。这个特性大大提高了面向对象的灵活性。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Alarm &#123;</span><br><span class="line">  alert(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> SecurityDoor <span class="keyword">extends</span> Door <span class="keyword">implements</span> Alarm &#123;</span><br><span class="line">  alert() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'SecurityDoor alert'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Car <span class="keyword">implements</span> Alarm &#123;</span><br><span class="line">  alert() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Car alert'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个类可以实现多个接口，接口可以继承接口。接口甚至也可以继承类：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Point &#123;</span><br><span class="line">  x: <span class="built_in">number</span></span><br><span class="line">  y: <span class="built_in">number</span></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x</span><br><span class="line">    <span class="keyword">this</span>.y = y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Point3d <span class="keyword">extends</span> Point &#123;</span><br><span class="line">  z: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> point3d: Point3d = &#123; x: <span class="number">1</span>, y: <span class="number">2</span>, z: <span class="number">3</span> &#125;</span><br></pre></td></tr></table></figure><p>因为当声明 class Point 时，除了会创建一个名为 Point 的类之外，同时也创建了一个名为 Point 的类型（TS 中最重要的类型检查功能中的类型）。</p><h2 id="高级类型"><a href="#高级类型" class="headerlink" title="高级类型"></a>高级类型</h2><h4 id="交叉类型-Intersection-Types"><a href="#交叉类型-Intersection-Types" class="headerlink" title="交叉类型(Intersection Types)"></a>交叉类型(Intersection Types)</h4><p>交叉类型是将多个类型合并为一个类型。这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">  sayName: <span class="function">(<span class="params">name: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> B &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  gender: <span class="built_in">string</span></span><br><span class="line">  sayGender: <span class="function">(<span class="params">gender: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a: A &amp; B</span><br><span class="line"></span><br><span class="line"><span class="comment">// 都是合法的</span></span><br><span class="line">a.age</span><br><span class="line">a.sayName</span><br></pre></td></tr></table></figure><h4 id="类型断言和类型保护"><a href="#类型断言和类型保护" class="headerlink" title="类型断言和类型保护"></a>类型断言和类型保护</h4><p>有时需要强行给某个字段或方法设定类型以使用对应的属性，就要使用类型断言。有两种语法<code>&lt;类型&gt;值</code> 和 <code>值 as 类型</code>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someValue: <span class="built_in">any</span> = <span class="string">'this is a string'</span></span><br><span class="line"><span class="keyword">let</span> strLength: <span class="built_in">number</span> = (&lt;<span class="built_in">string</span>&gt;someValue).length</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> someValue: <span class="built_in">any</span> = <span class="string">'this is a string'</span></span><br><span class="line"><span class="keyword">let</span> strLength: <span class="built_in">number</span> = (someValue <span class="keyword">as</span> <span class="built_in">string</span>).length</span><br></pre></td></tr></table></figure><p>使用类型断言，需要多次判断十分麻烦。所以使用类型保护。类型保护是<code>param is SomeType</code>的形式，用来明确一个联合类型变量的具体类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isFish</span>(<span class="params">pet: Fish | Bird</span>): <span class="title">pet</span> <span class="title">is</span> <span class="title">Fish</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (&lt;Fish&gt;pet).swim !== <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>typeof 类型保护用于 number, string, boolean, symbol：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> v === <span class="string">'string'</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v.length)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v.toFixed())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h4><p>keyof 关键字是索引类型查询操作符，能够获得任何类型上已知的公共属性名(非 never、undefined、null 类型)的联合：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> P &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> people: P = &#123;</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">  name: <span class="string">'wang'</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> fn: &lt;P, T <span class="keyword">extends</span> keyof P&gt;<span class="function">(<span class="params">p: P, t: T[]</span>) =&gt;</span> <span class="built_in">Array</span>&lt;P[T]&gt; = <span class="function">(<span class="params">p, t</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> t.map(<span class="function">(<span class="params">item</span>) =&gt;</span> p[item])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> res = fn(people, [<span class="string">'age'</span>])</span><br></pre></td></tr></table></figure><h4 id="映射类型"><a href="#映射类型" class="headerlink" title="映射类型"></a>映射类型</h4><p>TypeScript 提供了从旧类型中创建新类型的一种方式。在映射类型里新类型以相同的形式去转换旧类型里每个属性：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Readonly&lt;T&gt; = &#123;</span><br><span class="line">  readonly [P <span class="keyword">in</span> keyof T]: T[P]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Partial&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]?: T[P]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PersonReadonly = Readonly&lt;Person&gt;</span><br><span class="line"><span class="keyword">type</span> PersonPartial = Partial&lt;Person&gt;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> PersonPartial &#123;</span><br><span class="line">  name?: <span class="built_in">string</span></span><br><span class="line">  age?: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> PersonReadonly &#123;</span><br><span class="line">  readonly name: <span class="built_in">string</span></span><br><span class="line">  readonly age: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="字面量类型"><a href="#字面量类型" class="headerlink" title="字面量类型"></a>字面量类型</h4><p>字符串字面量类型用来约束取值只能是某几个字符串中的一个：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> EventNames = <span class="string">'click'</span> | <span class="string">'scroll'</span> | <span class="string">'mousemove'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleEvent</span>(<span class="params">ele: Element, event: EventNames</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="unknown"><a href="#unknown" class="headerlink" title="unknown"></a>unknown</h4><p>使用 any 类型，就无法享受 TypeScript 大量的保护机制。3.0 引入了新的 unknown 类型，它是 any 类型对应的安全类型。</p><ol><li>unknown 类型只能被赋值给 any 类型和 unknown 类型本身。</li><li>在交叉类型中，任何类型都可以吸收 unknown 类型。这意味着将任何类型与 unknown 相交不会改变结果类型。</li><li>在联合类型中，unknown 类型会吸收任何类型。这就意味着如果任一组成类型是 unknown，联合类型也会相当于 unknown。</li><li>never 是 unknown 的子类型。</li><li>类型为 unknown 的值上使用的运算符只有相等或不等。</li></ol><h4 id="条件类型"><a href="#条件类型" class="headerlink" title="条件类型"></a>条件类型</h4><p>2.8 版本后开始支持条件类型，增加了语言的灵活性。形如<code>T extends U ? X : Y</code>，若类型 T 可被赋值给类型 U,那么结果类型就是 X 类型,否则就是 Y 类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TypeName&lt;T&gt; = T <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">  ? <span class="string">'string'</span></span><br><span class="line">  : T <span class="keyword">extends</span> <span class="built_in">number</span></span><br><span class="line">  ? <span class="string">'number'</span></span><br><span class="line">  : T <span class="keyword">extends</span> <span class="built_in">boolean</span></span><br><span class="line">  ? <span class="string">'boolean'</span></span><br><span class="line">  : T <span class="keyword">extends</span> <span class="literal">undefined</span></span><br><span class="line">  ? <span class="string">'undefined'</span></span><br><span class="line">  : T <span class="keyword">extends</span> <span class="built_in">Function</span></span><br><span class="line">  ? <span class="string">'Function'</span></span><br><span class="line">  : <span class="string">'object'</span></span><br></pre></td></tr></table></figure><p>分步式条件类型：<code>(A | B) extends U ? X : Y</code>，等价于<code>(A extends U ? X : Y) | (B extends U ? X : Y)</code>。</p><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><h4 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h4><p>命名空间是一种内部模块，同文件的其他地方或其他文件只能访问到该空间的导出内容。下面是同文件引用的一个例子：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Validation &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> StringValidator &#123;</span><br><span class="line">    isAcceptable(s: <span class="built_in">string</span>): <span class="built_in">boolean</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> lettersRegexp = <span class="regexp">/^[A-Za-z]+$/</span></span><br><span class="line">  <span class="keyword">const</span> numberRegexp = <span class="regexp">/^[0-9]+$/</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">class</span> LettersOnlyValidator <span class="keyword">implements</span> StringValidator &#123;</span><br><span class="line">    isAcceptable(s: <span class="built_in">string</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> lettersRegexp.test(s)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">class</span> ZipCodeValidator <span class="keyword">implements</span> StringValidator &#123;</span><br><span class="line">    isAcceptable(s: <span class="built_in">string</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> s.length === <span class="number">5</span> &amp;&amp; numberRegexp.test(s)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> strings = [<span class="string">'Hello'</span>, <span class="string">'98052'</span>, <span class="string">'101'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> validators: &#123; [s: <span class="built_in">string</span>]: Validation.StringValidator &#125; = &#123;&#125;</span><br><span class="line">validators[<span class="string">'ZIP code'</span>] = <span class="keyword">new</span> Validation.ZipCodeValidator()</span><br><span class="line">validators[<span class="string">'Letters only'</span>] = <span class="keyword">new</span> Validation.LettersOnlyValidator()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> s of strings) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> name <span class="keyword">in</span> validators) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(</span><br><span class="line">      <span class="string">`"<span class="subst">$&#123;s&#125;</span>" - <span class="subst">$&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">        validators[name].isAcceptable(s) ? <span class="string">'matches'</span> : <span class="string">'does not match'</span></span></span></span><br><span class="line"><span class="string"><span class="subst">      &#125;</span> <span class="subst">$&#123;name&#125;</span>`</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="声明合并"><a href="#声明合并" class="headerlink" title="声明合并"></a>声明合并</h4><p>相同名称的接口会合并。不同接口中如有相同属性，后出现的属性会覆盖先出现的属性。</p><p>命名空间可以和同名命名空间、同名类、同名函数、同名枚举合并。同名类和同名函数需置于命名空间前。</p><h4 id="声明文件"><a href="#声明文件" class="headerlink" title="声明文件"></a>声明文件</h4><p>假如我们想使用第三方库 jQuery，一种常见的方式是在 html 中通过 script 标签引入 jQuery，然后就可以使用全局变量 $ 或 jQuery 了。但是在 ts 中，编译器并不知道 $ 或 jQuery 是什么，这时就需要声明语句。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">var</span> jQuery: <span class="function">(<span class="params">selector: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">any</span></span><br><span class="line"></span><br><span class="line">jQuery(<span class="string">'#foo'</span>)</span><br></pre></td></tr></table></figure><p>上例中，declare var 并没有真的定义一个变量，只是定义了全局变量 jQuery 的类型，仅仅会用于编译时的检查，在编译结果中会被删除。其他类型的声明有：<br><code>declare var</code> 声明全局变量<br><code>declare function</code> 声明全局方法<br><code>declare class</code> 声明全局类<br><code>declare enum</code> 声明全局枚举类型<br><code>declare namespace</code> 声明（含有子属性的）全局对象<br><code>interface</code> 和 <code>type</code> 声明全局类型<br><code>export</code> 导出变量<br><code>export namespace</code> 导出（含有子属性的）对象<br><code>export default</code> ES6 默认导出<br><code>export =</code> commonjs 导出模块<br><code>export as namespace</code> UMD 库声明全局变量<br><code>declare global</code> 扩展全局变量<br><code>declare module</code> 扩展模块<br><code>/// &lt;reference /&gt;</code> 三斜线指令</p><p>通常会把声明语句放到一个单独的文件（.d.ts 为后缀）中。一般来说，ts 会解析项目中所有的 _.ts 文件，当然也包含以 .d.ts 结尾的文件。所以当 .d.ts 放到项目中时，其他所有 _.ts 文件就都可以获得类型定义。</p><h4 id="tsconfig-json-配置"><a href="#tsconfig-json-配置" class="headerlink" title="tsconfig.json 配置"></a>tsconfig.json 配置</h4><p>在 TS 的项目中，TS 最终都会被编译 JS 文件执行，TS 编译器在编译 TS 文件的时候都会根据项目根目录 tsconfig.json 文件的配置进行编译：</p><p><code>files</code> 表示编译需要编译的单个文件列表</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"files"</span>: [</span><br><span class="line">  <span class="comment">// 指定编译文件是src目录下的a.ts文件</span></span><br><span class="line">  <span class="string">"scr/a.ts"</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><code>include</code> 表示编译需要编译的文件或目录</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"include"</span>: [</span><br><span class="line">  <span class="comment">// "scr" // 会编译src目录下的所有文件，包括子目录</span></span><br><span class="line">  <span class="comment">// "scr/*" // 只会编译scr一级目录下的文件</span></span><br><span class="line">  <span class="string">"scr/*/*"</span> <span class="comment">// 只会编译scr二级目录下的文件</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><code>exclude</code> 表示编译器需要排除的文件或文件夹</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"exclude"</span>: [</span><br><span class="line">  <span class="comment">// 排除src目录下的lib文件夹下的文件不会编译</span></span><br><span class="line">  <span class="string">"src/lib"</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><code>extends</code> 引入其他配置文件，继承配置</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把基础配置抽离成tsconfig.base.json文件，然后引入</span></span><br><span class="line"><span class="string">"extends"</span>: <span class="string">"./tsconfig.base.json"</span></span><br></pre></td></tr></table></figure><p><code>compileOnSave</code> 设置保存文件的时候自动编译(vscode 暂不支持)</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"compileOnSave"</span>: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><code>references</code> 指定工程引用依赖</p><p><code>compilerOptions</code> 配置编译选项</p><p>编译配置选项<code>compilerOptions</code>包括：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"compilerOptions"</span>: &#123;</span><br><span class="line">  <span class="string">"incremental"</span>: <span class="literal">true</span>, <span class="comment">// TS编译器在第一次编译之后会生成一个存储编译信息的文件，第二次编译会在第一次的基础上进行增量编译，可以提高编译的速度</span></span><br><span class="line">  <span class="string">"tsBuildInfoFile"</span>: <span class="string">"./buildFile"</span>, <span class="comment">// 增量编译文件的存储位置</span></span><br><span class="line">  <span class="string">"diagnostics"</span>: <span class="literal">true</span>, <span class="comment">// 打印诊断信息</span></span><br><span class="line">  <span class="string">"target"</span>: <span class="string">"ES5"</span>, <span class="comment">// 目标语言的版本</span></span><br><span class="line">  <span class="string">"module"</span>: <span class="string">"CommonJS"</span>, <span class="comment">// 生成代码的模板标准</span></span><br><span class="line">  <span class="string">"outFile"</span>: <span class="string">"./app.js"</span>, <span class="comment">// 将多个相互依赖的文件生成一个文件，可以用在AMD模块中，即开启时应设置"module": "AMD",</span></span><br><span class="line">  <span class="string">"lib"</span>: [<span class="string">"DOM"</span>, <span class="string">"ES2015"</span>, <span class="string">"ScriptHost"</span>, <span class="string">"ES2019.Array"</span>], <span class="comment">// TS需要引用的库，即声明文件，es5 默认引用dom、es5、scripthost,如需要使用es的高级版本特性，通常都需要配置，如es8的数组新特性需要引入"ES2019.Array",</span></span><br><span class="line">  <span class="string">"allowJS"</span>: <span class="literal">true</span>, <span class="comment">// 允许编译器编译JS，JSX文件</span></span><br><span class="line">  <span class="string">"checkJs"</span>: <span class="literal">true</span>, <span class="comment">// 允许在JS文件中报错，通常与allowJS一起使用</span></span><br><span class="line">  <span class="string">"outDir"</span>: <span class="string">"./dist"</span>, <span class="comment">// 指定输出目录</span></span><br><span class="line">  <span class="string">"rootDir"</span>: <span class="string">"./"</span>, <span class="comment">// 指定输出文件目录(用于输出)，用于控制输出目录结构</span></span><br><span class="line">  <span class="string">"declaration"</span>: <span class="literal">true</span>, <span class="comment">// 生成声明文件，开启后会自动生成声明文件</span></span><br><span class="line">  <span class="string">"declarationDir"</span>: <span class="string">"./file"</span>, <span class="comment">// 指定生成声明文件存放目录</span></span><br><span class="line">  <span class="string">"emitDeclarationOnly"</span>: <span class="literal">true</span>, <span class="comment">// 只生成声明文件，而不会生成js文件</span></span><br><span class="line">  <span class="string">"sourceMap"</span>: <span class="literal">true</span>, <span class="comment">// 生成目标文件的sourceMap文件</span></span><br><span class="line">  <span class="string">"inlineSourceMap"</span>: <span class="literal">true</span>, <span class="comment">// 生成目标文件的inline SourceMap，inline SourceMap会包含在生成的js文件中</span></span><br><span class="line">  <span class="string">"declarationMap"</span>: <span class="literal">true</span>, <span class="comment">// 为声明文件生成sourceMap</span></span><br><span class="line">  <span class="string">"typeRoots"</span>: [], <span class="comment">// 声明文件目录，默认时node_modules/@types</span></span><br><span class="line">  <span class="string">"types"</span>: [], <span class="comment">// 加载的声明文件包</span></span><br><span class="line">  <span class="string">"removeComments"</span>:<span class="literal">true</span>, <span class="comment">// 删除注释</span></span><br><span class="line">  <span class="string">"noEmit"</span>: <span class="literal">true</span>, <span class="comment">// 不输出文件,即编译后不会生成任何js文件</span></span><br><span class="line">  <span class="string">"noEmitOnError"</span>: <span class="literal">true</span>, <span class="comment">// 发送错误时不输出任何文件</span></span><br><span class="line">  <span class="string">"noEmitHelpers"</span>: <span class="literal">true</span>, <span class="comment">// 不生成helper函数，减小体积，需要额外安装，常配合importHelpers一起使用</span></span><br><span class="line">  <span class="string">"importHelpers"</span>: <span class="literal">true</span>, <span class="comment">// 通过tslib引入helper函数，文件必须是模块</span></span><br><span class="line">  <span class="string">"downlevelIteration"</span>: <span class="literal">true</span>, <span class="comment">// 降级遍历器实现，如果目标源是es3/5，那么遍历器会有降级的实现</span></span><br><span class="line">  <span class="string">"strict"</span>: <span class="literal">true</span>, <span class="comment">// 开启所有严格的类型检查</span></span><br><span class="line">  <span class="string">"alwaysStrict"</span>: <span class="literal">true</span>, <span class="comment">// 在代码中注入'use strict'</span></span><br><span class="line">  <span class="string">"noImplicitAny"</span>: <span class="literal">true</span>, <span class="comment">// 不允许隐式的any类型</span></span><br><span class="line">  <span class="string">"strictNullChecks"</span>: <span class="literal">true</span>, <span class="comment">// 不允许把null、undefined赋值给其他类型的变量</span></span><br><span class="line">  <span class="string">"strictFunctionTypes"</span>: <span class="literal">true</span>, <span class="comment">// 不允许函数参数双向协变</span></span><br><span class="line">  <span class="string">"strictPropertyInitialization"</span>: <span class="literal">true</span>, <span class="comment">// 类的实例属性必须初始化</span></span><br><span class="line">  <span class="string">"strictBindCallApply"</span>: <span class="literal">true</span>, <span class="comment">// 严格的bind/call/apply检查</span></span><br><span class="line">  <span class="string">"noImplicitThis"</span>: <span class="literal">true</span>, <span class="comment">// 不允许this有隐式的any类型</span></span><br><span class="line">  <span class="string">"noUnusedLocals"</span>: <span class="literal">true</span>, <span class="comment">// 检查只声明、未使用的局部变量(只提示不报错)</span></span><br><span class="line">  <span class="string">"noUnusedParameters"</span>: <span class="literal">true</span>, <span class="comment">// 检查未使用的函数参数(只提示不报错)</span></span><br><span class="line">  <span class="string">"noFallthroughCasesInSwitch"</span>: <span class="literal">true</span>, <span class="comment">// 防止switch语句贯穿(即如果没有break语句后面不会执行)</span></span><br><span class="line">  <span class="string">"noImplicitReturns"</span>: <span class="literal">true</span>, <span class="comment">//每个分支都会有返回值</span></span><br><span class="line">  <span class="string">"esModuleInterop"</span>: <span class="literal">true</span>, <span class="comment">// 允许export=导出，由import from 导入</span></span><br><span class="line">  <span class="string">"allowUmdGlobalAccess"</span>: <span class="literal">true</span>, <span class="comment">// 允许在模块中全局变量的方式访问umd模块</span></span><br><span class="line">  <span class="string">"moduleResolution"</span>: <span class="string">"node"</span>, <span class="comment">// 模块解析策略，ts默认用node的解析策略，即相对的方式导入</span></span><br><span class="line">  <span class="string">"baseUrl"</span>: <span class="string">"./"</span>, <span class="comment">// 解析非相对模块的基地址，默认是当前目录</span></span><br><span class="line">  <span class="string">"paths"</span>: &#123; <span class="comment">// 路径映射，相对于baseUrl</span></span><br><span class="line">    <span class="comment">// 如使用jq时不想使用默认版本，而需要手动指定版本，可进行如下配置</span></span><br><span class="line">    <span class="string">"jquery"</span>: [<span class="string">"node_modules/jquery/dist/jquery.min.js"</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"rootDirs"</span>: [<span class="string">"src"</span>,<span class="string">"out"</span>], <span class="comment">// 将多个目录放在一个虚拟目录下，用于运行时，即编译后引入文件的位置可能发生变化，这也设置可以虚拟src和out在同一个目录下，不用再去改变路径也不会报错</span></span><br><span class="line">  <span class="string">"listEmittedFiles"</span>: <span class="literal">true</span>, <span class="comment">// 打印输出文件</span></span><br><span class="line">  <span class="string">"listFiles"</span>: <span class="literal">true</span><span class="comment">// 打印编译的文件(包括引用的声明文件)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nodejs中mongoose模块的使用</title>
      <link href="/2020/05/14/nodejs%E4%B8%ADmongoose%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/05/14/nodejs%E4%B8%ADmongoose%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="1-创建数据"><a href="#1-创建数据" class="headerlink" title="1 创建数据"></a>1 创建数据</h1><h3 id="1-1-连接数据库"><a href="#1-1-连接数据库" class="headerlink" title="1.1 连接数据库"></a>1.1 连接数据库</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入mongoose第三方模块 用来操作数据库</span></span><br><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>)</span><br><span class="line"><span class="comment">// 数据库连接</span></span><br><span class="line">mongoose</span><br><span class="line">  .connect(<span class="string">'mongodb://用户名:密码@主机:端口/数据库名'</span>, &#123;</span><br><span class="line">    useNewUrlParser: <span class="literal">true</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 连接成功</span></span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'数据库连接成功'</span>))</span><br><span class="line">  <span class="comment">// 连接失败</span></span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="built_in">console</span>.log(err, <span class="string">'数据库连接失败'</span>))</span><br></pre></td></tr></table></figure><h3 id="1-2-创建集合"><a href="#1-2-创建集合" class="headerlink" title="1.2 创建集合"></a>1.2 创建集合</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建集合规则</span></span><br><span class="line"><span class="keyword">const</span> userSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">  name: <span class="built_in">String</span>,</span><br><span class="line">  age: <span class="built_in">String</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用规则创建集合</span></span><br><span class="line"><span class="comment">// 1.集合名称</span></span><br><span class="line"><span class="comment">// 2.集合规则</span></span><br><span class="line"><span class="keyword">const</span> User = mongoose.model(<span class="string">'User'</span>, userSchema) <span class="comment">// courses</span></span><br></pre></td></tr></table></figure><h3 id="1-3-创建文档"><a href="#1-3-创建文档" class="headerlink" title="1.3 创建文档"></a>1.3 创建文档</h3><p>方式一，实例化：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建文档</span></span><br><span class="line"><span class="keyword">const</span> user = <span class="keyword">new</span> User(&#123;</span><br><span class="line">  name: <span class="string">'Tom'</span>,</span><br><span class="line">  age: <span class="string">'22'</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 将文档插入到数据库中</span></span><br><span class="line">user.save()</span><br></pre></td></tr></table></figure><p>方式二，creat 函数(异步)：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向User集合中插入文档</span></span><br><span class="line">User.create(&#123; <span class="attr">name</span>: <span class="string">'Sam'</span>, <span class="attr">age</span>: <span class="string">'23'</span> &#125;).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向User集合中插入文档</span></span><br><span class="line">User.create(&#123; <span class="attr">name</span>: <span class="string">'Alice'</span>, <span class="attr">age</span>: <span class="string">'21'</span> &#125;, (err, result) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err)</span><br><span class="line">  <span class="built_in">console</span>.log(result)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="1-4-导入数据"><a href="#1-4-导入数据" class="headerlink" title="1.4 导入数据"></a>1.4 导入数据</h3><p>命令行输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongoimport –d 数据库名称 –c 集合名称 –-file 要导入的数据文件</span><br></pre></td></tr></table></figure><p>mongoimport 在 mongodb 安装目录下</p><h1 id="2-文档查删改"><a href="#2-文档查删改" class="headerlink" title="2 文档查删改"></a>2 文档查删改</h1><h3 id="2-1-文档查找"><a href="#2-1-文档查找" class="headerlink" title="2.1 文档查找"></a>2.1 文档查找</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询用户集合中的所有文档</span></span><br><span class="line">User.find().then(<span class="function">(<span class="params">result</span>) =&gt;</span> <span class="built_in">console</span>.log(result))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 滤掉 name 中的相同数据</span></span><br><span class="line">User.distinct(<span class="string">'name'</span>).then(<span class="function">(<span class="params">result</span>) =&gt;</span> <span class="built_in">console</span>.log(result))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询 name 中包含'张'的数据</span></span><br><span class="line">User.find(&#123; <span class="attr">name</span>: <span class="regexp">/张/</span> &#125;).then(<span class="function">(<span class="params">result</span>) =&gt;</span> <span class="built_in">console</span>.log(result))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询 name = '张三', age = 20 的数据</span></span><br><span class="line">User.find(&#123; <span class="attr">name</span>: <span class="string">'张三'</span>, <span class="attr">age</span>: <span class="number">20</span> &#125;).then(<span class="function">(<span class="params">result</span>) =&gt;</span> <span class="built_in">console</span>.log(result))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询 age = 20 或 age = 32 的数据</span></span><br><span class="line">User.find(&#123; <span class="attr">$or</span>: [&#123; <span class="attr">age</span>: <span class="number">20</span> &#125;, &#123; <span class="attr">age</span>: <span class="number">32</span> &#125;] &#125;).then(<span class="function">(<span class="params">result</span>) =&gt;</span></span><br><span class="line">  <span class="built_in">console</span>.log(result)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过_id字段查找文档</span></span><br><span class="line">User.find(&#123; <span class="attr">_id</span>: <span class="string">'5c09f267aeb04b22f8460968'</span> &#125;).then(<span class="function">(<span class="params">result</span>) =&gt;</span></span><br><span class="line">  <span class="built_in">console</span>.log(result)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// findOne方法返回一条文档 默认返回当前集合中的第一条文档</span></span><br><span class="line">User.findOne(&#123; <span class="attr">name</span>: <span class="string">'李四'</span> &#125;).then(<span class="function">(<span class="params">result</span>) =&gt;</span> <span class="built_in">console</span>.log(result))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询用户集合中年龄字段大于20并且小于等于40的文档</span></span><br><span class="line">User.find(&#123; <span class="attr">age</span>: &#123; <span class="attr">$gt</span>: <span class="number">20</span>, <span class="attr">$lte</span>: <span class="number">40</span> &#125; &#125;).then(<span class="function">(<span class="params">result</span>) =&gt;</span> <span class="built_in">console</span>.log(result))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询用户集合中hobbies字段值包含足球的文档</span></span><br><span class="line">User.find(&#123; <span class="attr">hobbies</span>: &#123; <span class="attr">$in</span>: [<span class="string">'足球'</span>] &#125; &#125;).then(<span class="function">(<span class="params">result</span>) =&gt;</span> <span class="built_in">console</span>.log(result))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择要查询的字段</span></span><br><span class="line">User.find()</span><br><span class="line">  .select(<span class="string">'name email -_id'</span>)</span><br><span class="line">  .then(<span class="function">(<span class="params">result</span>) =&gt;</span> <span class="built_in">console</span>.log(result))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据年龄字段进行升序排列</span></span><br><span class="line">User.find()</span><br><span class="line">  .sort(<span class="string">'age'</span>)</span><br><span class="line">  .then(<span class="function">(<span class="params">result</span>) =&gt;</span> <span class="built_in">console</span>.log(result))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据年龄字段进行降序排列</span></span><br><span class="line">User.find()</span><br><span class="line">  .sort(<span class="string">'-age'</span>)</span><br><span class="line">  .then(<span class="function">(<span class="params">result</span>) =&gt;</span> <span class="built_in">console</span>.log(result))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询年龄小于25岁的文档数量</span></span><br><span class="line">User.find(&#123; <span class="attr">age</span>: &#123; <span class="attr">$gte</span>: <span class="number">25</span> &#125; &#125;)</span><br><span class="line">  .count()</span><br><span class="line">  .then(<span class="function">(<span class="params">result</span>) =&gt;</span> <span class="built_in">console</span>.log(result))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询文档跳过前两条结果 限制显示3条结果</span></span><br><span class="line">User.find()</span><br><span class="line">  .skip(<span class="number">2</span>)</span><br><span class="line">  .limit(<span class="number">3</span>)</span><br><span class="line">  .then(<span class="function">(<span class="params">result</span>) =&gt;</span> <span class="built_in">console</span>.log(result))</span><br></pre></td></tr></table></figure><h3 id="2-2-文档删除"><a href="#2-2-文档删除" class="headerlink" title="2.2 文档删除"></a>2.2 文档删除</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找到一条文档并且删除</span></span><br><span class="line"><span class="comment">// 返回删除的文档</span></span><br><span class="line"><span class="comment">// 如何查询条件匹配了多个文档 那么将会删除第一个匹配的文档</span></span><br><span class="line">User.findOneAndDelete(&#123; <span class="attr">_id</span>: <span class="string">'5c09f267aeb04b22f8460968'</span> &#125;).then(<span class="function">(<span class="params">result</span>) =&gt;</span></span><br><span class="line">  <span class="built_in">console</span>.log(result)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除多条文档</span></span><br><span class="line">User.deleteMany(&#123;&#125;).then(<span class="function">(<span class="params">result</span>) =&gt;</span> <span class="built_in">console</span>.log(result))</span><br></pre></td></tr></table></figure><h3 id="2-3-文档更新"><a href="#2-3-文档更新" class="headerlink" title="2.3 文档更新"></a>2.3 文档更新</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果匹配了多条文档, 只会更新匹配成功的第一条文档</span></span><br><span class="line">User.updateOne(&#123; <span class="attr">name</span>: <span class="string">'李四'</span> &#125;, &#123; <span class="attr">age</span>: <span class="number">120</span>, <span class="attr">name</span>: <span class="string">'李狗蛋'</span> &#125;).then(<span class="function">(<span class="params">result</span>) =&gt;</span></span><br><span class="line">  <span class="built_in">console</span>.log(result)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新多条文档</span></span><br><span class="line">User.updateMany(&#123;&#125;, &#123; <span class="attr">age</span>: <span class="number">300</span> &#125;).then(<span class="function">(<span class="params">result</span>) =&gt;</span> <span class="built_in">console</span>.log(result))</span><br></pre></td></tr></table></figure><h1 id="3-集合验证"><a href="#3-集合验证" class="headerlink" title="3 集合验证"></a>3 集合验证</h1><p>验证字段：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> postSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">  title: &#123;</span><br><span class="line">    type: <span class="built_in">String</span>,</span><br><span class="line">    <span class="comment">// 必选字段</span></span><br><span class="line">    required: [<span class="literal">true</span>, <span class="string">'请传入文章标题'</span>],</span><br><span class="line">    <span class="comment">// 字符串的最小长度</span></span><br><span class="line">    minlength: [<span class="number">2</span>, <span class="string">'文章长度不能小于2'</span>],</span><br><span class="line">    <span class="comment">// 字符串的最大长度</span></span><br><span class="line">    maxlength: [<span class="number">5</span>, <span class="string">'文章长度最大不能超过5'</span>],</span><br><span class="line">    <span class="comment">// 去除字符串两边的空格</span></span><br><span class="line">    trim: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  age: &#123;</span><br><span class="line">    type: <span class="built_in">Number</span>,</span><br><span class="line">    <span class="comment">// 数字的最小范围</span></span><br><span class="line">    min: <span class="number">18</span>,</span><br><span class="line">    <span class="comment">// 数字的最大范围</span></span><br><span class="line">    max: <span class="number">100</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  publishDate: &#123;</span><br><span class="line">    type: <span class="built_in">Date</span>,</span><br><span class="line">    <span class="comment">// 默认值</span></span><br><span class="line">    <span class="keyword">default</span>: <span class="built_in">Date</span>.now,</span><br><span class="line">  &#125;,</span><br><span class="line">  category: &#123;</span><br><span class="line">    type: <span class="built_in">String</span>,</span><br><span class="line">    <span class="comment">// 枚举 列举出当前字段可以拥有的值</span></span><br><span class="line">    enum: &#123;</span><br><span class="line">      values: [<span class="string">'html'</span>, <span class="string">'css'</span>, <span class="string">'javascript'</span>, <span class="string">'node.js'</span>],</span><br><span class="line">      message: <span class="string">'分类名称要在一定的范围内才可以'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  author: &#123;</span><br><span class="line">    type: <span class="built_in">String</span>,</span><br><span class="line">    validate: &#123;</span><br><span class="line">      validator: <span class="function">(<span class="params">v</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 返回布尔值</span></span><br><span class="line">        <span class="comment">// true 验证成功</span></span><br><span class="line">        <span class="comment">// false 验证失败</span></span><br><span class="line">        <span class="comment">// v 要验证的值</span></span><br><span class="line">        <span class="keyword">return</span> v &amp;&amp; v.length &gt; <span class="number">4</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 自定义错误信息</span></span><br><span class="line">      message: <span class="string">'传入的值不符合验证规则'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>错误捕捉：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Post = mongoose.model(<span class="string">'Post'</span>, postSchema)</span><br><span class="line"></span><br><span class="line">Post.create(&#123; <span class="attr">title</span>: <span class="string">'aa'</span>, <span class="attr">age</span>: <span class="number">60</span>, <span class="attr">category</span>: <span class="string">'java'</span>, <span class="attr">author</span>: <span class="string">'bd'</span> &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">result</span>) =&gt;</span> <span class="built_in">console</span>.log(result))</span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 获取错误信息对象</span></span><br><span class="line">    <span class="keyword">const</span> err = error.errors</span><br><span class="line">    <span class="comment">// 循环错误信息对象</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> attr <span class="keyword">in</span> err) &#123;</span><br><span class="line">      <span class="comment">// 将错误信息打印到控制台中</span></span><br><span class="line">      <span class="built_in">console</span>.log(err[attr][<span class="string">'message'</span>])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h1 id="4-集合关联"><a href="#4-集合关联" class="headerlink" title="4 集合关联"></a>4 集合关联</h1><p>建立关联：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用户集合规则</span></span><br><span class="line"><span class="keyword">const</span> userSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">  name: &#123;</span><br><span class="line">    type: <span class="built_in">String</span>,</span><br><span class="line">    required: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 文章集合规则</span></span><br><span class="line"><span class="keyword">const</span> postSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">  title: &#123;</span><br><span class="line">    type: <span class="built_in">String</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  author: &#123;</span><br><span class="line">    type: mongoose.Schema.Types.ObjectId,</span><br><span class="line">    ref: <span class="string">'User'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>查询关联：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Post.find()</span><br><span class="line">  .populate(<span class="string">'author'</span>)</span><br><span class="line">  .then(<span class="function">(<span class="params">result</span>) =&gt;</span> <span class="built_in">console</span>.log(result))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> NodeJS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> NodeJS </tag>
            
            <tag> MongoDB </tag>
            
            <tag> 使用手册 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原生nodejs搭建Web服务器</title>
      <link href="/2020/05/14/%E5%8E%9F%E7%94%9Fnodejs%E6%90%AD%E5%BB%BAWeb%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2020/05/14/%E5%8E%9F%E7%94%9Fnodejs%E6%90%AD%E5%BB%BAWeb%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="1-创建-Web-服务器"><a href="#1-创建-Web-服务器" class="headerlink" title="1 创建 Web 服务器"></a>1 创建 Web 服务器</h3><ol><li>创建服务器<code>app = http.createServer()</code></li><li>监听请求<code>app.on(&#39;request&#39;, (req, res) =&gt; {}</code>，req 为接收的请求信息，res 为发送的响应信息</li><li>监听端口<code>app.listen(3000)</code></li><li>解析 url<code>url.parse(req.url, true)</code></li><li>路由转发</li><li>返回响应<code>res.end()</code></li></ol><p>创建服务器、监听请求、监听端口可简写为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;&#125;).listen(<span class="number">3000</span>)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于创建网站服务器的模块</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="comment">// 用于处理url地址</span></span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>)</span><br><span class="line"><span class="comment">// app对象就是网站服务器对象</span></span><br><span class="line"><span class="keyword">const</span> app = http.createServer()</span><br><span class="line"><span class="comment">// 当客户端有请求来的时候</span></span><br><span class="line">app.on(<span class="string">'request'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 获取请求方式</span></span><br><span class="line">  <span class="comment">// req.method.toLowerCase()</span></span><br><span class="line">  <span class="built_in">console</span>.log(req.method.toLowerCase())</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取请求地址</span></span><br><span class="line">  <span class="comment">// req.url</span></span><br><span class="line">  <span class="built_in">console</span>.log(req.url)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取请求报文信息</span></span><br><span class="line">  <span class="comment">// req.headers</span></span><br><span class="line">  <span class="built_in">console</span>.log(req.headers[<span class="string">'accept'</span>])</span><br><span class="line"></span><br><span class="line">  res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">    <span class="string">'content-type'</span>: <span class="string">'text/html;charset=utf8'</span>,</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(req.url)</span><br><span class="line">  <span class="comment">// 1) 要解析的url地址</span></span><br><span class="line">  <span class="comment">// 2) 将查询参数解析成对象形式</span></span><br><span class="line">  <span class="keyword">let</span> &#123; query, pathname &#125; = url.parse(req.url, <span class="literal">true</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(query.name)</span><br><span class="line">  <span class="built_in">console</span>.log(query.age)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pathname === <span class="string">'/index'</span> || pathname === <span class="string">'/'</span>) &#123;</span><br><span class="line">    res.end(<span class="string">'&lt;h2&gt;欢迎来到首页&lt;/h2&gt;'</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pathname === <span class="string">'/list'</span>) &#123;</span><br><span class="line">    res.end(<span class="string">'welcome to listpage'</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    res.end(<span class="string">'not found'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 监听端口</span></span><br><span class="line">app.listen(<span class="number">3000</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'网站服务器启动成功'</span>)</span><br></pre></td></tr></table></figure><h3 id="2-post-请求"><a href="#2-post-请求" class="headerlink" title="2 post 请求"></a>2 post 请求</h3><ol><li>querystring 模块解析 post 请求主体<code>querystring.parse()</code></li><li>post 主体信息分批抵达服务器，data 事件监听每批到达数据，end 事件监听数据传输完毕事件</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于创建网站服务器的模块</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="comment">// app对象就是网站服务器对象</span></span><br><span class="line"><span class="keyword">const</span> app = http.createServer()</span><br><span class="line"><span class="comment">// 处理请求参数模块</span></span><br><span class="line"><span class="keyword">const</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>)</span><br><span class="line"><span class="comment">// 当客户端有请求来的时候</span></span><br><span class="line">app.on(<span class="string">'request'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="comment">// post参数是通过事件的方式接受的</span></span><br><span class="line">  <span class="comment">// data 当请求参数传递的时候出发data事件</span></span><br><span class="line">  <span class="comment">// end 当参数传递完成的时候出发end事件</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> postParams = <span class="string">''</span></span><br><span class="line"></span><br><span class="line">  req.on(<span class="string">'data'</span>, (params) =&gt; &#123;</span><br><span class="line">    postParams += params</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  req.on(<span class="string">'end'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(querystring.parse(postParams))</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  res.end(<span class="string">'ok'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 监听端口</span></span><br><span class="line">app.listen(<span class="number">3000</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'网站服务器启动成功'</span>)</span><br></pre></td></tr></table></figure><h3 id="3-请求静态资源"><a href="#3-请求静态资源" class="headerlink" title="3 请求静态资源"></a>3 请求静态资源</h3><ol><li>fs 模块获取资源位置</li><li>mime 模块用于根据请求资源后缀名自动获取 content-type</li><li>path 模块连接路径</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="comment">// 用于根据请求资源后缀名自动获取content-type</span></span><br><span class="line"><span class="keyword">const</span> mime = <span class="built_in">require</span>(<span class="string">'mime'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = http.createServer()</span><br><span class="line"></span><br><span class="line">app.on(<span class="string">'request'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 获取用户的请求路径</span></span><br><span class="line">  <span class="keyword">let</span> pathname = url.parse(req.url).pathname</span><br><span class="line"></span><br><span class="line">  pathname = pathname === <span class="string">'/'</span> ? <span class="string">'/default.html'</span> : pathname</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将用户的请求路径转换为实际的服务器硬盘路径</span></span><br><span class="line">  <span class="keyword">let</span> realPath = path.join(__dirname, <span class="string">'public'</span> + pathname)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据请求资源后缀名自动获取content-type</span></span><br><span class="line">  <span class="keyword">let</span> type = mime.getType(realPath)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取文件</span></span><br><span class="line">  fs.readFile(realPath, (error, result) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 如果文件读取失败</span></span><br><span class="line">    <span class="keyword">if</span> (error != <span class="literal">null</span>) &#123;</span><br><span class="line">      res.writeHead(<span class="number">404</span>, &#123;</span><br><span class="line">        <span class="string">'content-type'</span>: <span class="string">'text/html;charset=utf8'</span>,</span><br><span class="line">      &#125;)</span><br><span class="line">      res.end(<span class="string">'文件读取失败'</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">      <span class="string">'content-type'</span>: type,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    res.end(result)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'服务器启动成功'</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> NodeJS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> NodeJS </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nodejs中的fs模块</title>
      <link href="/2020/05/12/nodejs%E4%B8%AD%E7%9A%84fs%E6%A8%A1%E5%9D%97/"/>
      <url>/2020/05/12/nodejs%E4%B8%AD%E7%9A%84fs%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h3 id="1-fs-stat-检测是文件还是目录"><a href="#1-fs-stat-检测是文件还是目录" class="headerlink" title="1 fs.stat 检测是文件还是目录"></a>1 fs.stat 检测是文件还是目录</h3><p>stats.isFile()和stats.isDirectory()返回布尔值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fs.stat(<span class="string">'hello.js'</span>, (error, stats) =&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span>(error)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(error)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(stats)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`文件：<span class="subst">$&#123;stats.isFile()&#125;</span>`</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`目录：<span class="subst">$&#123;stats.isDirectory()&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="2-fs-mkdir-创建目录"><a href="#2-fs-mkdir-创建目录" class="headerlink" title="2 fs.mkdir 创建目录"></a>2 fs.mkdir 创建目录</h3><p>path——–&gt;将创建的目录路径<br>mode——–&gt;目录权限（读写权限），默认777<br>callback—-&gt;回调，传递异常参数err</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fs.mkdir(<span class="string">'logs'</span>, (error) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(error)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(error)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'成功创建目录：logs'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="3-fs-writeFile-创建写入文件"><a href="#3-fs-writeFile-创建写入文件" class="headerlink" title="3 fs.writeFile 创建写入文件"></a>3 fs.writeFile 创建写入文件</h3><p>filename—(String)—文件名称<br>data—(String | Buffer)—将要写入的内容，可以使字符串 或 buffer数据<br>options —(Object)—option数组对象，包含：<br>· encoding—(string)—可选值，默认 ‘utf8′，当data使buffer时，该值应该为 ignored<br>· mode—(Number)—文件读写权限，默认值 438<br>· flag—(String)—默认值 ‘w’<br>callback—{Function}—回调，传递一个异常参数err  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fs.writeFile(<span class="string">'logs/hello.log'</span>, <span class="string">'您好 ~ \n'</span>, (error) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(error) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(error)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'成功写入文件'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="4-fs-appendFile-追加文件"><a href="#4-fs-appendFile-追加文件" class="headerlink" title="4 fs.appendFile 追加文件"></a>4 fs.appendFile 追加文件</h3><p>在原文档后加入文本</p><p>不存在文件则创建文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fs.appendFile(<span class="string">'logs/hello.log'</span>, <span class="string">'hello ~ \n'</span>, (error) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(error) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(error)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'成功写入文件'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="5-fs-readFile-读取文件"><a href="#5-fs-readFile-读取文件" class="headerlink" title="5 fs.readFile 读取文件"></a>5 fs.readFile 读取文件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(<span class="string">'logs/hello.log'</span>, <span class="string">'utf8'</span>, (error, data) =&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(error)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="6-fs-readdir-读取目录"><a href="#6-fs-readdir-读取目录" class="headerlink" title="6 fs.readdir 读取目录"></a>6 fs.readdir 读取目录</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fs.readdir(<span class="string">'logs'</span>, (error, files) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(error)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(files)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="7-fs-rename-重命名"><a href="#7-fs-rename-重命名" class="headerlink" title="7 fs.rename 重命名"></a>7 fs.rename 重命名</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fs.rename(<span class="string">'js/hello.log'</span>, <span class="string">'js/greeting.log'</span>, (error) =&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(error)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'重命名成功'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="8-fs-rmdir-删除目录"><a href="#8-fs-rmdir-删除目录" class="headerlink" title="8 fs.rmdir 删除目录"></a>8 fs.rmdir 删除目录</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fs.rmdir(<span class="string">'logs'</span>, (error) =&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(error)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'成功的删除了目录：logs'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="9-fs-unlink-删除文件"><a href="#9-fs-unlink-删除文件" class="headerlink" title="9 fs.unlink 删除文件"></a>9 fs.unlink 删除文件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fs.unlink(<span class="string">`logs/<span class="subst">$&#123;file&#125;</span>`</span>, (error) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(error)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`成功的删除了文件: <span class="subst">$&#123;file&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="10-fs-createReadStream-从文件流中读取数据"><a href="#10-fs-createReadStream-从文件流中读取数据" class="headerlink" title="10 fs.createReadStream 从文件流中读取数据"></a>10 fs.createReadStream 从文件流中读取数据</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">var</span> fileReadStream = fs.createReadStream(<span class="string">'data.json'</span>)</span><br><span class="line"><span class="keyword">let</span> count=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> str=<span class="string">''</span>;</span><br><span class="line">fileReadStream.on(<span class="string">'data'</span>, (chunk) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123; ++count &#125;</span> 接收到：<span class="subst">$&#123;chunk.length&#125;</span>`</span>);</span><br><span class="line">    str+=chunk</span><br><span class="line">&#125;)</span><br><span class="line">fileReadStream.on(<span class="string">'end'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'--- 结束 ---'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(count);</span><br><span class="line">    <span class="built_in">console</span>.log(str);</span><br><span class="line">&#125;)</span><br><span class="line">fileReadStream.on(<span class="string">'error'</span>, (error) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="11-fs-createWriteStream-写入文件"><a href="#11-fs-createWriteStream-写入文件" class="headerlink" title="11 fs.createWriteStream 写入文件"></a>11 fs.createWriteStream 写入文件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="keyword">var</span> data = <span class="string">'我是从数据库获取的数据，我要保存起来'</span>;</span><br><span class="line"><span class="comment">// 创建一个可以写入的流，写入到文件 output.txt 中</span></span><br><span class="line"><span class="keyword">var</span> writerStream = fs.createWriteStream(<span class="string">'output.txt'</span>);</span><br><span class="line"><span class="comment">// 使用 utf8 编码写入数据</span></span><br><span class="line">writerStream.write(data,<span class="string">'UTF8'</span>);</span><br><span class="line"><span class="comment">// 标记文件末尾</span></span><br><span class="line">writerStream.end();</span><br><span class="line"><span class="comment">// 处理流事件 --&gt; finish 事件</span></span><br><span class="line">writerStream.on(<span class="string">'finish'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">/*finish - 所有数据已被写入到底层系统时触发。*/</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"写入完成。"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">writerStream.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err.stack);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"程序执行完毕"</span>);</span><br></pre></td></tr></table></figure><h3 id="12-管道流"><a href="#12-管道流" class="headerlink" title="12 管道流"></a>12 管道流</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="comment">// 创建一个可读流</span></span><br><span class="line"><span class="keyword">var</span> readerStream = fs.createReadStream(<span class="string">'input.txt'</span>);</span><br><span class="line"><span class="comment">// 创建一个可写流</span></span><br><span class="line"><span class="keyword">var</span> writerStream = fs.createWriteStream(<span class="string">'output.txt'</span>);</span><br><span class="line"><span class="comment">// 管道读写操作</span></span><br><span class="line"><span class="comment">// 读取 input.txt 文件内容，并将内容写入到 output.txt 文件中</span></span><br><span class="line">readerStream.pipe(writerStream);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"程序执行完毕"</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> NodeJS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NodeJS </tag>
            
            <tag> 使用手册 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理学习笔记十-优化和目标代码生成</title>
      <link href="/2020/05/05/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%8D%81-%E4%BC%98%E5%8C%96%E5%92%8C%E7%9B%AE%E6%A0%87%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/"/>
      <url>/2020/05/05/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%8D%81-%E4%BC%98%E5%8C%96%E5%92%8C%E7%9B%AE%E6%A0%87%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/</url>
      
        <content type="html"><![CDATA[<h1 id="第十章-优化和目标代码生成"><a href="#第十章-优化和目标代码生成" class="headerlink" title="第十章 优化和目标代码生成"></a>第十章 优化和目标代码生成</h1><h3 id="第一部分：优化"><a href="#第一部分：优化" class="headerlink" title="第一部分：优化"></a>第一部分：优化</h3><h4 id="1-优化的基本概念"><a href="#1-优化的基本概念" class="headerlink" title="1 优化的基本概念"></a>1 优化的基本概念</h4><p>优化：对程序进行各种等价变换，使得从变换后的程序出发，可以生成更有效的目标代码。<br>优化的特点：等价，有效。<br>优化的级别：局部优化、循环优化、全局优化。<br>优化的种类：删除多余运算、合并已知量、复写传播、删除无用赋值、代码外提、强度消弱（例如乘法换为加法）、变换循环控制条件。</p><h4 id="2-局部优化"><a href="#2-局部优化" class="headerlink" title="2 局部优化"></a>2 局部优化</h4><p>局限于基本块范围内的优化称为基本块内的优化，或称局部优化。  </p><h5 id="2-1-基本块"><a href="#2-1-基本块" class="headerlink" title="2.1 基本块"></a>2.1 基本块</h5><p>基本块是程序中一顺序执行语句序列，其中只有一个入口和一个出口。入口就是其中第一个语句，出口就是其中最后一个语句。<br>对三地址语句为<code>x:=y+z</code>，称对x定值并引用y和z。<br>基本块中的一个名字在程序中的某个给定点是活跃的，是指如果在程序中(包括在本基本块或在其它基本块中)它的值在该点以后被引用。  </p><h5 id="2-2-基本块划分算法和流图"><a href="#2-2-基本块划分算法和流图" class="headerlink" title="2.2 基本块划分算法和流图"></a>2.2 基本块划分算法和流图</h5><p>划分基本块的算法：  </p><ol><li>找出中间语言(三地址语句)程序中各个基本块的入口语句:程序第一个语句，或能由条件转移语句或无条件转移语句转移到的语句，或紧跟在条件转移语句后面的语句；  </li><li>对以上求出的每个入口语句，确定其所属的基本块。它是由该入口语句到下一入口语句(不包括该入口语句)、或到一转移语句(包括该转移语句)、或一停语句(包括该停语句)之间的语句序列组成的；  </li><li>凡未被纳入某一基本块中的语句，可以从程序中删除。  </li></ol><p>流图：<br>以基本块为结点构成流图；<br>如果一个结点的基本块的入口语句是程序的第一条语句，则称此结点为首结点；<br>如果在某个执行顺序中，基本块B2紧接在基本块B1之后执行，则从B1到B2有一条有向边（B1是B2的前驱，B2是B1的后继）。有一个条件或无条件转移语句从B1的最后一条语句转移到B2的第一条语句；或者在程序的序列中，B2紧接在B1的后面，并且B1的最后一条语句不是一个无条件转移语句。  </p><p>示例：<br><img src="/2020/05/05/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%8D%81-%E4%BC%98%E5%8C%96%E5%92%8C%E7%9B%AE%E6%A0%87%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/1.png" alt="基本块划分和流图"></p><h5 id="2-3-四元式的有向无环图-DAG-表示"><a href="#2-3-四元式的有向无环图-DAG-表示" class="headerlink" title="2.3 四元式的有向无环图(DAG)表示"></a>2.3 四元式的有向无环图(DAG)表示</h5><p>在DAG增加标记和附加信息：<br>图的叶结点以一标识符或常数作为标记，表示该结点代表该变量或常数的值；<br>图的内部结点以一运算符作为标记，表示该结点代表应用该运算符对其后继结点所代表的值进行运算的结果；<br>各个结点上可能附加一个或多个标识符(称附加标识符)表示这些变量具有该结点所代表的值。<br>示例：<br><img src="/2020/05/05/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%8D%81-%E4%BC%98%E5%8C%96%E5%92%8C%E7%9B%AE%E6%A0%87%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/2.png" alt="DAG的扩充"></p><p>四元式的DAG表示：<br><img src="/2020/05/05/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%8D%81-%E4%BC%98%E5%8C%96%E5%92%8C%E7%9B%AE%E6%A0%87%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/3.png" alt="四元式的DAG表示"></p><h5 id="2-4-局部优化算法"><a href="#2-4-局部优化算法" class="headerlink" title="2.4 局部优化算法"></a>2.4 局部优化算法</h5><p>一个基本块，可用一个DAG来表示，对基本块中每一条四元式代码，依次构造对应的DAG图，最后基本块中所有四元式构造出来DAG连成整个基本块的DAG。  </p><p>引入一个函数Node，保存和计算DAG中标识符与结点的对应关系：<br><img src="/2020/05/05/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%8D%81-%E4%BC%98%E5%8C%96%E5%92%8C%E7%9B%AE%E6%A0%87%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/4.png" alt="函数Node"></p><p>步骤：  </p><ol><li><p>准备操作数的结点<br>1.1 如果NODE(B)无定义，则构造一标记为B的叶结点并定义NODE(B)为这个结点：<br>   如果当前四元式是0型，则记NODE(B)的值为n，转4；<br>   如果当前四元式是1型，则转2(1)；<br>   如果当前四元式是2型，则(i)如果NODE(C)无定义，则构造一标记为C的叶结点并定义NODE(C)为这个结点；(ii)转2(2)。  </p></li><li><p>合并已知量<br>2.1 如果NODE(B)是标记为常数的叶结点，则转2(3)；否则，转3(1)。<br>2.2 如果NODE(B)和NODE(C)都是标记为常数的叶结点，则转2(4)；否则，转3(2)。<br>2.3 执行op B (即合并已知量)。令得到的新常数为P。如果NODE(B)是处理当前四元式时新构造出来的结点，则删除它。如果NODE(P)无定义，则构造一用P作标记的叶结点n。置NODE(P)=n，转4。<br>2.4 执行B op C (即合并已知量)。令得到的新常数为P。如果NODE(B)或NODE(C)是处理当前四元式时新构造出来的结点，则删除它。如果NODE(P)无定义，则构造一用P作标记的叶结点n。置NODE(P)=n，转4。  </p></li><li><p>删除公共子表达式<br>3.1 检查DAG中是否已有一结点，其唯一后继为NODE(B)且标记为op(即公共子表达式)。如果没有，则构造该结点n，否则，把已有的结点作为它的结点并设该结点为n。转4。<br>3.2 检查DAG中是否已有一结点，其左后继为NODE(B)，右后继为NODE(C)，且标记为op(即公共子表达式)。如果没有，则构造该结点n，否则，把已有的结点作为它的结点并设该结点为n。转4。  </p></li><li><p>删除无用赋值<br>4.1 如果NODE(A)无定义，则把A附加在结点n上并令NODE(A)=n;否则，先把A从NODE(A)结点上的附加标识符集中删除(注意，如果NODE(A)是叶结点，则其A标记不删除)。把A附加到新结点n上并置NODE(A)=n。转处理下一四元式。  </p></li></ol><p>从DAG中得到的优化信息：<br>在基本块外被定值并在基本块内被引用的所有标识符，就是作为叶子结点上标记的那些标识符；<br>在基本块内被定值并且该值在基本块后面可以被引用的所有标识符，就是DAG各结点上的那些标记或者附加标识符。  </p><h4 id="3-循环优化"><a href="#3-循环优化" class="headerlink" title="3 循环优化"></a>3 循环优化</h4><p>可能反复执行的代码序列的优化称为循环优化。</p><h5 id="3-1-循环优化的措施"><a href="#3-1-循环优化的措施" class="headerlink" title="3.1 循环优化的措施"></a>3.1 循环优化的措施</h5><p>对循环中的代码，可以实行：<br>代码外提；<br>强度消弱；<br>删除归纳变量(变换循环控制条件)；<br>循环展开；<br>循环合并。  </p><h5 id="3-2-代码外提"><a href="#3-2-代码外提" class="headerlink" title="3.2 代码外提"></a>3.2 代码外提</h5><p>所谓变量A在某点d的定值到达另一点u（或称变量A的定值点d到达另一点u），是指流图中从d有一通路到达u且该通路上没有A的其它定值。<br>循环不变运算：对四元式A:=B op C,若B和C是常数，或者到达它们的B和C的定值点都在循环外；<br>把循环不变运算提到循环体外。  </p><p>查找循环中不变运算的算法：<br>依次查看L中各基本块的每个四元式，如果它的每个运算对象或为常数，或者定值点在 L外，则将此四元式标记为”不变运算”；<br>重复第3步直至没有新的四元式被标记为”不变运算”为止；<br>依次查看尚未被标记为”不变运算”的四元式，如果它的每个运算对象或为常数，或定值点在L之外，或只有一个到达-定值点且该点上的四元式已被标记为”不变运算”，则把被查看的四元式标记为”不变运算”。  </p><p><img src="/2020/05/05/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%8D%81-%E4%BC%98%E5%8C%96%E5%92%8C%E7%9B%AE%E6%A0%87%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/5.png" alt="代码外提"></p><p>四元式S(A:=B OP C）外提的条件：  </p><ol><li>S所在的结点是L所有出口结点的必经结点；  </li><li>A在L中其他地方未再定值；   </li><li>L中所有A的引用点只有S中的A的定值才能到达。  </li></ol><p>或  </p><ol><li>A在离开L后不再是活跃的；  </li><li>A在L中其他地方未再定值；  </li><li>L中所有A的引用点只有S中的A的定值才能到达。  </li></ol><p>代码外提算法：  </p><ol><li>求出L的所有不变运算；  </li><li>对每个不变运算s:A:=B op C 或 A:=op B 或 A:=B检查是否满足外提的条件；  </li><li>按步骤1所找出不变运算的次序，依次把符合步骤2的条件(1)或(2)的不变运算s外提到L的前置结点中。但是，如果s的运算对象(B或C)是在L中定值的，那么，只有当这些定值四元式都已外提到前置结点中时，才能把s也外提到前置结点中。  </li></ol><h5 id="3-3-强度消弱"><a href="#3-3-强度消弱" class="headerlink" title="3.3 强度消弱"></a>3.3 强度消弱</h5><p>强度消弱是把程序中执行时间较长的运算转换为执行时间较短的运算。<br>强度消弱通常是针对循环控制变量有线性关系的变量赋值进行。<br>经过强度消弱后，循环中可能出现一些新的无用赋值。<br>对于消弱下标变量地址计算的强度非常有效。  </p><h5 id="3-4-删除归纳变量"><a href="#3-4-删除归纳变量" class="headerlink" title="3.4 删除归纳变量"></a>3.4 删除归纳变量</h5><p>如果循环中对变量I只有唯一的形如I:=I±C的赋值，且其中C为循环不变量，则称I为循环中的基本归纳变量；<br>如果I是循环中一基本归纳变量，J在循环中的定值总是可化归为I的同一线性函数，也即J=C1*I±C2，其中C1和C2都是循环不变量，则称J是归纳变量，并称它与I同族。基本归纳变量也是归纳变量。  </p><p>删除归纳变量在强度削弱以后进行，强度削弱和删除归纳变量的统一算法框架：  </p><ol><li>利用循环不变运算信息，找出循环中所有基本归纳变量。</li><li>找出所有其它归纳变量A，并找出A与已知基本归纳变量X的同族线性函数关系FA(X)。</li><li>对2中找出的每一归纳变量A，进行强度削弱。</li><li>删除对归纳变量的无用赋值。</li><li>删除基本归纳变量。如果基本归纳变量B在循环出口之后不是活跃的，并且在循环中，除在其自身的递归赋值中被引用外，只在形如 <code>if B rop Y goto L</code>的语句中被引用，则可选取一与B同族的归纳变量M来替换B进行条件控制。最后删除循环中对B的递归赋值的代码。</li></ol><h3 id="第二部分：目标代码生成"><a href="#第二部分：目标代码生成" class="headerlink" title="第二部分：目标代码生成"></a>第二部分：目标代码生成</h3><h4 id="4-目标代码生成器"><a href="#4-目标代码生成器" class="headerlink" title="4 目标代码生成器"></a>4 目标代码生成器</h4><p>任务：<br>把分析、翻译、优化后的中间代码变换成目标代码。  </p><p>输入：<br>源程序的中间表示，以及符号表中的信息；<br>类型检查。  </p><p>输出：<br>绝对指令代码：能够立即执行的机器语言代码，所有地址已经定位；<br>可重新定位指令代码：待装配的机器语言模块，执行时，由连接装配程序把它们和某些运行程序连接起来，转换成能执行的机器语言代码；<br>汇编指令代码：需要经过汇编程序转换成可执行的机器语言代码。  </p><h4 id="5-目标代码生成需要考虑的问题"><a href="#5-目标代码生成需要考虑的问题" class="headerlink" title="5 目标代码生成需要考虑的问题"></a>5 目标代码生成需要考虑的问题</h4><p>如何充分利用计算机的指令系统的特点；<br>如何充分利用计算机的寄存器，减少目标代码中访问存贮单元的次数。在寄存器分配期间，为程序的某一点选择驻留在寄存器中的一组变量；在随后的寄存器指派阶段，挑出变量将要驻留的具体寄存器。  </p><h4 id="6-目标机器模型"><a href="#6-目标机器模型" class="headerlink" title="6 目标机器模型"></a>6 目标机器模型</h4><p>一个抽象的计算机模型：<br>具有多个通用寄存器，可用作累加器和变址器；<br>运算必须在某个寄存器中进行；<br>含有四种类型的指令形式。</p><p>示例：<br><img src="/2020/05/05/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%8D%81-%E4%BC%98%E5%8C%96%E5%92%8C%E7%9B%AE%E6%A0%87%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/6.png" alt="代码外提">  </p><figure class="image-box">                <img src="/2020/05/05/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%8D%81-%E4%BC%98%E5%8C%96%E5%92%8C%E7%9B%AE%E6%A0%87%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/7.png" alt="代码外提" title class>                <p>代码外提</p>            </figure>  <h4 id="7-带寄存器分配优化的代码生成"><a href="#7-带寄存器分配优化的代码生成" class="headerlink" title="7 带寄存器分配优化的代码生成"></a>7 带寄存器分配优化的代码生成</h4><p>以基本块为单位生成目标代码：<br>依次把四元式的中间代码变换成目标代码；<br>在基本块的范围内考虑如何充分利用寄存器；<br>进入基本块时，所有寄存器空闲；<br>离开基本块时，把存在寄存器中的现行的值存回主存中，释放所有寄存器；<br>不特别说明，所有说明变量在基本块出口之后均为非活跃变量。  </p><p>在一个基本块的范围内考虑充分利用寄存器：  </p><ol><li>要做到<br> 1.1 尽可能留：在生成计算某变量值的目标代码时，尽可能让该变量保留在寄存器中；<br> 1.2 尽可能用：后续的目标代码尽可能引用变量在寄存器中的值，而不访问内存；<br> 1.3 及时腾空：在离开基本块时，把存在寄存器中的现行的值放到主存中。  </li><li>要知道<br> 2.1 四元式指令：每条指令中各变量在将来会被使用的情况；<br> 2.2 变量：每个变量现行值的存放位置；<br> 2.3 寄存器：每个寄存器当前的使用状况。  </li></ol><h4 id="8-待用信息和活跃信息"><a href="#8-待用信息和活跃信息" class="headerlink" title="8 待用信息和活跃信息"></a>8 待用信息和活跃信息</h4><p>如果在一个基本块内，四元式i对A定值，四元式j要引用A值，而从i到j之间没有A的其他定值，那么，我们称j是四元式i的变量A的待用信息，即下一个引用点。<br>变量的符号表登记项中含有记录待用信息和活跃信息的栏。  </p><p>二元组(x, x)表示变量的待用信息和活跃信息：<br>第1元：i表示待用信息， ^表示非待用；<br>第2元：y表示活跃，^表示非活跃；<br>待用信息和活跃信息的变化(x，x)→(x，x)，用后者更新前者。</p><p>计算待用信息和活跃信息的算法：  </p><ol><li>把基本块中各变量的符号表中的待用信息栏填为“非待用”，并根据该变量在基本块出口之后是不是活跃的，把其中的活跃信息栏填为“活跃”或“非活跃”；  </li><li>从基本块出口到入口由后向前依次处理各个四元式i:A:=B op C：<br>2.1 把符号表中变量A的待用信息和活跃信息附加到四元式i上；<br>2.2 把符号表中A的待用信息和活跃信息分别置为“非待用”和“非活跃”；<br>2.3 把符号表中变量B和C的待用信息和活跃信息附加到四元式i上；<br>2.4 把符号表中B和C的待用信息均置为i，活跃信息均置为“活跃”.  </li></ol><h4 id="9-变量地址描述和寄存器描述"><a href="#9-变量地址描述和寄存器描述" class="headerlink" title="9 变量地址描述和寄存器描述"></a>9 变量地址描述和寄存器描述</h4><p>变量地址描述数组<code>AVALUE[A]={R1, R2, A}</code>：动态记录各变量现行值的存放位置。<br>寄存器描述数组<code>RVALUE[R]={A,B}</code>：动态记录各寄存器的使用信息。  </p><p>对于四元式A:=B，如果B的现行值在某寄存器Ri中，则无须生成目标代码，只须在RVALUE(Ri)中增加一个A，(即把Ri同时分配给B和A)，并把AVALUE(A)改为Ri。</p><h4 id="10-代码生成算法"><a href="#10-代码生成算法" class="headerlink" title="10 代码生成算法"></a>10 代码生成算法</h4><p>对每个四元式: i: A:=B op C，依次执行：  </p><ol><li>以四元式: i: A:=B op C 为参数，调用函数过程<code>GETREG(i: A:=B op C)</code>，返回一个寄存器R，用作存放A的寄存器。  </li><li>利用AVALUE[B]和AVALUE[C]，确定B和C现行值的存放位置B’和C’。如果其现行值在寄存器中，则把寄存器取作B’和C’。  </li><li>如果B’≠R，则生成目标代码：   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LD  R,  B’</span><br><span class="line">op  R,  C’</span><br></pre></td></tr></table></figure>否则生成目标代码 <code>op R, C’</code>。如果B’或C’为R，则删除AVALUE[B]或AVALUE[C]中的R。  </li><li>令AVALUE[A]={R}, RVALUE[R]={A}。  </li><li>若B或C的现行值在基本块中不再被引用，也不是基本块出口之后的活跃变量，且其现行值在某寄存器Rk中，则删除RVALUE[Rk]中的B或C以及AVALUE[B]或AVALUE[C] 中的Rk ，使得该寄存器不再为B或C占用。  </li></ol><p>算法中，GETREG(i: A:=B op C) 返回一个用来存放A的值的寄存器。<br>寄存器分配算法：  </p><ol><li>(尽可能用B独占的寄存器)如果B的现行值在某个寄存器Ri中，RVALUE[Ri]中只包含B，此外，或者B与A是同一个标识符，或者B的现行值在执行四元式A:=B op C之后不会再引用，则选取Ri为所需要的寄存器R，并转4；  </li><li>(尽可能用空闲寄存器)如果有尚未分配的寄存器，则从中选取一个Ri为所需要的寄存器R，并转4；  </li><li>(抢占非空闲寄存器)从已分配的寄存器中选取一个Ri为所需要的寄存器R。最好使得Ri满足以下条件：占用Ri的变量的值也同时存放在该变量的贮存单元中，或者在基本块中要在最远的将来才会引用到或不会引用到。为Ri中的变量生成必要的存数指令；  </li><li>给出R，返回。</li></ol><p>寄存器分配算法第三步中，生成存数指令算法如下：<br>对RVALUE[Ri]中每一变量M，如果M不是A，或者如果M是A又是C，但不是B并且B也不在RVALUE[Ri]中，则：  </p><ol><li>如果AVALUE[M]不包含M，则生成目标代码 ST Ri，M；  </li><li>如果M是B，或者M是C但同时B也在RVALUE[Ri]中，则令AVALUE[M]={M， Ri} ，否则令AVALUE[M]={M}；  </li><li>删除RVALUE[Ri]中的M。  </li></ol>]]></content>
      
      
      <categories>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理学习笔记九-程序运行时存储空间的组织</title>
      <link href="/2020/05/05/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%9D-%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%97%B6%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E7%9A%84%E7%BB%84%E7%BB%87/"/>
      <url>/2020/05/05/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%9D-%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%97%B6%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E7%9A%84%E7%BB%84%E7%BB%87/</url>
      
        <content type="html"><![CDATA[<h1 id="第九章-程序运行时存储空间的组织"><a href="#第九章-程序运行时存储空间的组织" class="headerlink" title="第九章 程序运行时存储空间的组织"></a>第九章 程序运行时存储空间的组织</h1><h3 id="第一部分：符号表"><a href="#第一部分：符号表" class="headerlink" title="第一部分：符号表"></a>第一部分：符号表</h3><h4 id="1-符号表的作用"><a href="#1-符号表的作用" class="headerlink" title="1 符号表的作用"></a>1 符号表的作用</h4><p>登记各类名字的信息；<br>编译各阶段都需要使用符号表（一致性检查和作用域分析、辅助代码生成）  </p><h4 id="2-符号表的组织"><a href="#2-符号表的组织" class="headerlink" title="2 符号表的组织"></a>2 符号表的组织</h4><p>符号表的每一项(入口)包含两大栏：名字栏，也称主栏，关键字栏；信息栏，记录相应的不同属性，分为若干子栏。<br>按名字的不同种属建立多张符号表，如常数表、变量名表、过程名表…  </p><p>对符号表的操作：<br>填入名称；<br>查找名字；<br>访问信息；<br>填写修改信息；<br>删除。  </p><p>对符号表进行操作的时机：<br>定义性出现，int index；<br>使用性出现，if  index &lt; 100。  </p><p>栏目的长度：<br>方法一：安排各项各栏的存储单元为固定长度；<br>方法二：用间接方式安排各栏存储单元（存放指针等，会影响效率）。  </p><p>符号表的存放：<br>方法一：把每一项置于连续K存储单元中，构成一张K*N的表(N为符号表的项数)；<br>方法二：把整个符号表分成M个子表，如T1、T2、…、Tm，每个子表含N项。  </p><h4 id="3-符号表的整理和查找"><a href="#3-符号表的整理和查找" class="headerlink" title="3 符号表的整理和查找"></a>3 符号表的整理和查找</h4><p>线性查找：按关键字出现的顺序填写各项。<br>结构简单，节省空间，填表快，<br>查找慢，时间复杂度O(n)。<br>改进：自适应线性表。  </p><p>二分查找：表格中的项按名字的“大小”顺序整理排列。<br>填表慢，查找快，时间复杂度:O(Log2n)。<br>改进：组织成二叉树。  </p><p>杂凑查找(HASH技术)：<br>杂凑函数H(SYM)：0~n-1，n：符号表的项数。<br>填表快，查找快。<br>要求：<br>计算简单高效，<br>函数值分布均匀。  </p><h4 id="4-符号表的内容"><a href="#4-符号表的内容" class="headerlink" title="4 符号表的内容"></a>4 符号表的内容</h4><p>符号表的信息栏中登记了每个名字的有关性质：<br>类型：整、实或布尔等；<br>种属：简单变量、数组、过程、函数等；<br>大小：长度，即所需的存储单元字数；<br>相对数：指分配给该名字的存储单元的相对地址。  </p><p>表格的定义：<br>名字表(nametab)、<br>程序体表(btab)、<br>层次显示表(display)、<br>数组信息表(atab)、<br>中间代码表(code)。</p><p>名字表(nametab)，登记程序中出现的各种名字及其属性：<br>    name，名字标识符；<br>    kind，名字种类，可以是常量(constant)、变量(variable)、类型(type)、过程(procedure)；<br>    lev，名字所在的程序体的静态层次。规定主程序的层次为1，主程序中定义的层次为2，依此类推；<br>    typ，名字的类型，类型有整型(ints)、字符型(chars)、布尔型(bool)、数组(arrays)，对于无类型的名字填入notype；<br>    normal，一个布尔量，用于标明名字是否为变量形参名，当名字是否为变量形参名时填入false，其他情况填入true或不填；<br>    ref，当名字为数组类型或数组变量名时，ref指向该数组在数组信息表中的位置；当名字为过程名时，ref指向该过程在程序体表中的位置；其他情况ref为0；<br>    adr/val/size，adr，当名字为变量名时(包括形参)，存入该变量(或形参)在相应活动记录中分配的存贮单元的相对地址；对于过程名，填入他们相应代码的入口地址，val，当名字为常量名时，填入他们的相应值，size，当名字为类型名时，填入该类型数据所需存贮单元数目；<br>    link，指向同一程序体中定义的上一个名字在nametab中的位置，每个程序体在nametab中登记的第一个名字的link为0，通过link可以方便的进行遍历。  </p><p>程序体表(btab)，记录各程序体的总信息，用于对源程序中定义的名字的作用域进行分析，对名字表进行管理：<br>    lastpar，指向本程序体中最后一个形式参数在nametab中的位置；<br>    last，指向本程序体中最后一个名字在nametab中的位置；<br>    psize，本程序体所有形参所需体积、包括连接数据所占空间；<br>    vsize，本程序体所有局部数据所需空间大小。  </p><p>层次显示表(display)，描述正在处理的各嵌套层，对程序体表进行管理。</p><p>数组信息表(atab)，用于记录每个数组的详细信息：<br>inxtyp，数组的下标类型；<br>eltyp，数组元素类型；<br>elref，当元素为数组时，它指向该元素数组信息在atab表中的位置，其他情况为0；<br>low，数组下限；<br>high，数组上限；<br>elsize，数组元素的体积；<br>size，数组本身的体积。  </p><p>中间代码表(code)，用于存放编译程序所产生的每条中间代码：<br>opcode，操作码；<br>l，第一操作数，程序体层数；<br>a，第二操作数，相对地址。  </p><h4 id="5-名字的作用范围"><a href="#5-名字的作用范围" class="headerlink" title="5 名字的作用范围"></a>5 名字的作用范围</h4><p>在许多程序语言中，允许同一个标识符在不同过程中代表不同的名字，名字都有一个确定的作用范围。<br>作用域：一个名字能被使用的区域范围称作这个名字的作用域。<br>两种程序体结构：<br>并列结构，如FORTRAN；<br>嵌套结构，如PASCAL，PL。  </p><p>并列结构：<br>一个程序由一个主程序段和若干辅程序段组成，每个程序段由一系列的说明语句和执行语句组成，各段可以独立编译，各程序段中的名字相互独立，同一个标识符在不同的程序段中代表不同的名字。</p><p>嵌套结构：<br>最近嵌套原则（作用域链）。</p><h3 id="第二部分：运行时存储空间的组织"><a href="#第二部分：运行时存储空间的组织" class="headerlink" title="第二部分：运行时存储空间的组织"></a>第二部分：运行时存储空间的组织</h3><h4 id="6-参数传递概念"><a href="#6-参数传递概念" class="headerlink" title="6 参数传递概念"></a>6 参数传递概念</h4><p>过程或函数是模块程序设计的主要手段，也是节省程序代码和扩充语言的主要途径。<br>过程定义：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">procedure  add(x, y : integer; var z : integer)  </span><br><span class="line"> begin  </span><br><span class="line">       z :&#x3D; x + y;  </span><br><span class="line"> end;</span><br></pre></td></tr></table></figure><br>过程调用：<br> <code>add(a, b, c);</code>  </p><h4 id="7-参数传递方式"><a href="#7-参数传递方式" class="headerlink" title="7 参数传递方式"></a>7 参数传递方式</h4><p>传地址，把实在参数的地址传递给相应的形式参数。<br>方法：调用程序把实在参数(实参)的地址传递到被调用过程相应的形式单元中。被调用过程中，对形式参数(形参)的引用或赋值被处理成对形式单元的间接访问。<br>示例：PASCAL的变量参数，C/C++传引用。</p><p>得结果，传地址的一种变形。<br>方法：每个形参对应两个形式单元，第一个形式单元存放实参地址，第二个单元存放实参的值，在过程体中对形参的任何引用或赋值都看作对它的第二个单元的直接访问，过程完成返回前，把第二个单元的内容存放到第一个单元所指的实参单元中。<br>示例：有些Fortran采用这种方式。  </p><p>传值，把实在参数的值传递给相应的形式参数。<br>方法：调用程序预先把实在参数的值计算出来，并传递到被调用过程相应的形式单元中，被调用过程中，象引用局部数据一样引用形式参数，直接访问对应的形式单元。<br>示例：PASCAL的值参数，C/C++的省缺参数传递。  </p><p>传名（不常用），过程调用的作用相当于把被调用过程的过程体抄到调用出现的地方，但把其中出现的形式参数都替换成相应的实参。<br>方法：在进入被调用过程的之前不对实在参数预先进行计值，而是让过程体中每当使用到相应的形式参数时才逐次对它实行计值（或计算地址），通常把实在参数处理成一个子程序（称为参数子程序），每当过程体中使用到相应的形式参数时就调用这个子程序。  </p><h4 id="8-过程的活动与生存期"><a href="#8-过程的活动与生存期" class="headerlink" title="8 过程的活动与生存期"></a>8 过程的活动与生存期</h4><p>过程或函数是模块化程序设计的主要手段，也是节省程序代码和扩充语言的主要途径。<br>一个过程的活动指的是该过程的一次执行。<br>过程P一个活动的生存期，指的是从执行该过程体第一步操作到最后一步操作之间的操作序，包括执行P时调用其它过程花费的时间。<br>编译程序必须知道目标程序的运行时存储空间组织。</p><h4 id="9-运行时的存储组织"><a href="#9-运行时的存储组织" class="headerlink" title="9 运行时的存储组织"></a>9 运行时的存储组织</h4><p>一个目标程序运行所需的存储空间包括：<br>存放目标代码的空间；<br>存放数据项目的空间；<br>存放程序运行的控制或连接数据所需单元。</p><p>编译程序组织存储空间须考虑的问题：<br>过程是否允许递归？<br>当控制从一个过程的活动返回时，对局部名称的值如何处理？<br>过程是否允许引用非局部名称？<br>过程调用时如何传递参数；过程是否可以做为参数被传递和做为结果被返回？<br>存储空间可否在程序控制下进行动态分配？<br>存储空间是否必须显式地释放？  </p><p>存储分配策略：静态分配策略和动态分配策略。</p><h4 id="10-静态分配策略"><a href="#10-静态分配策略" class="headerlink" title="10 静态分配策略"></a>10 静态分配策略</h4><p>静态分配策略：在编译时能确定数据空间的大小，并为每个数据项目确定出在运行时刻的存储空间中的位置。<br>示例：FORTRAN等。</p><p>FORTRAN程序的特点：<br>整个程序所需数据空间的总量在编译时完全确定；<br>每个数据名的地址可以静态地进行分配；<br>各程序段可以独立编译，由链接装配程序把各段连成可运行的整体。  </p><p>按数据区组织存储：<br>每个程序段定义一个局部数据区，用来存放程序段中未出现在COMMON里的局部名的值；<br>每个公用块定义一个公用数据区，用来存放公用块里各个名字的值。</p><p>局部数据区：<br>每个数据区有一个编号，地址分配时，在符号表中，对每个数据名登记其所属数据区编号及在该区中的相对位置。<br>局部数据区的内容如下图：<br><img src="/2020/05/05/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%9D-%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%97%B6%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E7%9A%84%E7%BB%84%E7%BB%87/1.png" alt="局部数据区的内容"></p><h4 id="11-动态分配策略"><a href="#11-动态分配策略" class="headerlink" title="11 动态分配策略"></a>11 动态分配策略</h4><p>动态分配策略：在编译时不能确定运行时数据空间的大小，允许递归过程和动态申请释放内存。<br>分为栈式动态分配、堆式动态分配。<br>示例：PASCAL，C/C++等。  </p><p>活动记录：运行时，每当进入一个过程就有一个相应的活动记录累筑于栈顶，此记录含有连接数据、形式单元、局部变量、局部数组的内情向量和临时工作单元等。  </p><p>非嵌套过程语言（如C语言）：<br>特点：允许过程递归调用、也可以允许过程含有可变数组；过程定义不允许嵌套。<br>采用栈式存储分配机制。</p><p>嵌套过程语言（如PASCAL语言）：<br>特点：允许过程递归调用、也可以允许可变数组，过程定义允许嵌套。局部可以访问非局部名字。<br>非局部名字的访问的实现方法：静态链和活动记录；嵌套层次显示表Display。</p><p>嵌套过程语言的静态链方法（在活动记录中增加静态链单元）：<br>过程运行时，必须能知道它的所有外层过程的当前活动记录的起始地址。<br>静态链：指向本过程的直接外层过程的活动记录的起始地址，也称存取链。  </p><p>嵌套过程语言的Display表方法（在活动记录中增加Display表方法）：<br>进入一个过程时，在建立其活动记录的同时建立一张嵌套层次显示表Display，自顶向下依次存放着当前过程、直接外层、…、直至最外层(主程序,0层)过程的最新活动记录的起始地址。  </p>]]></content>
      
      
      <categories>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理学习笔记八-语义分析和中间代码生成</title>
      <link href="/2020/04/17/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AB-%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/"/>
      <url>/2020/04/17/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AB-%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/</url>
      
        <content type="html"><![CDATA[<h1 id="第八章-语义分析和中间代码生成"><a href="#第八章-语义分析和中间代码生成" class="headerlink" title="第八章 语义分析和中间代码生成"></a>第八章 语义分析和中间代码生成</h1><h3 id="第一部分：中间语言"><a href="#第一部分：中间语言" class="headerlink" title="第一部分：中间语言"></a>第一部分：中间语言</h3><h4 id="1-中间语言的特点和作用"><a href="#1-中间语言的特点和作用" class="headerlink" title="1 中间语言的特点和作用"></a>1 中间语言的特点和作用</h4><p>特点：<br>独立于机器；<br>复杂性界于源语言和目标语言之间。<br>引入中间语言的优点：<br>使编译程序的结构在逻辑上更为简单明确 ；<br>便于进行与机器无关的代码优化工作 ；<br>易于移植。</p><figure class="image-box">                <img src="/2020/04/17/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AB-%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/1.png" alt="中间语言的地位" title class>                <p>中间语言的地位</p>            </figure><h4 id="2-常用的中间语言"><a href="#2-常用的中间语言" class="headerlink" title="2 常用的中间语言"></a>2 常用的中间语言</h4><p>后缀式，逆波兰表示。<br>图表示： 抽象语法树(AST)、有向无环图(DAG)。<br>三地址代码：三元式、四元式、间接三元式。</p><h4 id="3-后缀式"><a href="#3-后缀式" class="headerlink" title="3 后缀式"></a>3 后缀式</h4><p>后缀式表示法：Lukasiewicz发明的一种表示表达式的方法，又称逆波兰表示法。  </p><p>一个表达式E的后缀形式可以如下定义：<br>如果E是一个变量或常量，则E的后缀式是E自身；<br>如果E是E1 op E2形式的表达式，其中op是任何二元操作符，则E的后缀式为E1‘ E2’ op，其中E1‘ 和E2’ 分别为E1 和E2的后缀式；<br>如果E是(E1)形式的表达式，则E1 的后缀式就是E的后缀式。</p><p>特点：<br>后缀式表示法不用括号：只要知道每个算符的目数，对于后缀式，不论从哪一端进行扫描，都能对它进行无歧义地分解；<br>后缀式的计算：用一个栈实现，自左至右扫描后缀式，每碰到运算量就把它推进栈。每碰到k目运算符就把它作用于栈顶的k个项，并用运算结果代替这k个项。</p><p>示例：<br><img src="/2020/04/17/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AB-%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/2.png" alt="后缀式"></p><h4 id="4-图表示法"><a href="#4-图表示法" class="headerlink" title="4 图表示法"></a>4 图表示法</h4><p>有向无环图(Directed Acyclic Graph，简称DAG)：<br>对表达式中的每个子表达式，DAG中都有一个结点；<br>一个内部结点代表一个操作符，它的孩子代表操作数；<br>在一个DAG中代表公共子表达式的结点具有多个父结点。</p><figure class="image-box">                <img src="/2020/04/17/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AB-%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/3.png" alt="图表示法" title class>                <p>图表示法</p>            </figure><h4 id="5-三地址代码"><a href="#5-三地址代码" class="headerlink" title="5 三地址代码"></a>5 三地址代码</h4><p>三地址代码：<code>x:=y op z</code><br>可以看成是抽象语法树或有向无环图的一种线性表示。</p><p>三地址语句的种类：<br>x:=y op z<br>x:=op y<br>x:=y<br>goto L<br>if x relop y goto L或if a goto L<br>传参、转子：param x、call p,n<br>返回语句：return y<br>索引赋值：x:=y[i]、x[i]:=y<br>地址和指针赋值：x:=&amp;y、x:=<em>y、</em>x:=y  </p><p>四元式：一个带有四个域的记录结构，这四个域分别称为op, arg1, arg2及result。示例：<br><img src="/2020/04/17/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AB-%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/4.png" alt="四元式"></p><p>三元式：用三个域表示：op、arg1和arg2。</p><p>间接三元式：三元式表+间接码表。<br>间接码表是一张指示器表，按运算的先后次序列出有关三元式在三元式表中的位置。优点是方便优化，节省空间。</p><h3 id="第二部分：赋值语句的翻译"><a href="#第二部分：赋值语句的翻译" class="headerlink" title="第二部分：赋值语句的翻译"></a>第二部分：赋值语句的翻译</h3><h4 id="6-简单算术表达式及赋值语句"><a href="#6-简单算术表达式及赋值语句" class="headerlink" title="6 简单算术表达式及赋值语句"></a>6 简单算术表达式及赋值语句</h4><p>赋值语句的形式：<br>id:=E<br>赋值语句的意义(功能) ：<br>对表达式E求值并置于变量T中，id.place:=T。</p><h4 id="7-产生赋值语句三地址代码的翻译模式"><a href="#7-产生赋值语句三地址代码的翻译模式" class="headerlink" title="7 产生赋值语句三地址代码的翻译模式"></a>7 产生赋值语句三地址代码的翻译模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">S→id:&#x3D;E  </span><br><span class="line">&#123; p:&#x3D;lookup(id.name);  </span><br><span class="line">if p≠nil then  emit(p ‘:&#x3D;’ E.place)  </span><br><span class="line">else error  &#125;</span><br><span class="line"></span><br><span class="line">E→E1+E2  </span><br><span class="line">&#123; E.place:&#x3D;newtemp;  </span><br><span class="line">emit(E.place ‘:&#x3D;’ E1.place ‘+’ E2.place)&#125;  </span><br><span class="line"></span><br><span class="line">E→E1*E2  </span><br><span class="line">&#123; E.place:&#x3D;newtemp;  </span><br><span class="line">emit(E.place ‘:&#x3D;’ E 1.place ‘*’ E 2.place)&#125;</span><br><span class="line"></span><br><span class="line">E→-E1  </span><br><span class="line">&#123; E.place:&#x3D;newtemp;  </span><br><span class="line">emit(E.place‘:&#x3D;’ ‘uminus’ E 1.place) &#125;</span><br><span class="line"></span><br><span class="line">E→(E1)  </span><br><span class="line">&#123; E.place:&#x3D;E1.place &#125;</span><br><span class="line"></span><br><span class="line">E→id  </span><br><span class="line">&#123; p:&#x3D;lookup(id.name);  </span><br><span class="line">if p≠nil then  E.place:&#x3D;p  </span><br><span class="line">else error &#125;</span><br></pre></td></tr></table></figure><h4 id="8-数组元素引用的翻译"><a href="#8-数组元素引用的翻译" class="headerlink" title="8 数组元素引用的翻译"></a>8 数组元素引用的翻译</h4><h4 id="9-类型转换"><a href="#9-类型转换" class="headerlink" title="9 类型转换"></a>9 类型转换</h4><p>示例：<br>x := y＋i*j，其中x、y为实型；i、j为整型，该赋值句产生的三地址代码为：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">T1 :&#x3D; i  int*  j  </span><br><span class="line">T3 :&#x3D; inttoreal  T1  </span><br><span class="line">T2 :&#x3D; y  real+ T3  </span><br><span class="line">x :&#x3D; T2</span><br></pre></td></tr></table></figure><p>用E.type表示非终结符E的类型属性，产生式E→E1 op E2的语义动作中关于E.type的语义规则可定义为：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;  if E1.type&#x3D;integer and E2.type&#x3D;integer  </span><br><span class="line">       E.type:&#x3D;integer  </span><br><span class="line">    else E.type:&#x3D;real  &#125;</span><br></pre></td></tr></table></figure><h3 id="第三部分：布尔表达式的翻译"><a href="#第三部分：布尔表达式的翻译" class="headerlink" title="第三部分：布尔表达式的翻译"></a>第三部分：布尔表达式的翻译</h3><h4 id="10-布尔表达式的简介"><a href="#10-布尔表达式的简介" class="headerlink" title="10 布尔表达式的简介"></a>10 布尔表达式的简介</h4><p>文法：<br> <code>E → E or E | E and E | not E | (E) | i rop i | i</code></p><p>用途：<br>用于逻辑演算，计算逻辑值；用于控制语句的条件式。</p><p>计算布尔表达式的两种方法：<br>数值表示法：如同计算算术表达式一样,一步步算。<br>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 or (not 0 and 0) or 0</span><br><span class="line">&#x3D;1 or (1 and 0) or 0</span><br><span class="line">&#x3D;1 or 0 or 0</span><br><span class="line">&#x3D;1 or 0</span><br><span class="line">&#x3D;1</span><br></pre></td></tr></table></figure><p>带优化的翻译法:<br>把A or B解释成      <code>if A then true else B</code>；<br>把A and B解释成  <code>if A then B else false</code>；<br>把not A解释成    <code>if A then false else true</code>；<br>适合于作为条件表达式的布尔表达式使用。</p><h4 id="11-数值表示法的翻译模式"><a href="#11-数值表示法的翻译模式" class="headerlink" title="11 数值表示法的翻译模式"></a>11 数值表示法的翻译模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">E→E1 or E2     </span><br><span class="line">&#123; E.place:&#x3D;newtemp;</span><br><span class="line">emit(E.place ‘:&#x3D;’ E 1.place ‘or’ E2.place)&#125;</span><br><span class="line"></span><br><span class="line">E→E1 and E2</span><br><span class="line">&#123; E.place:&#x3D;newtemp;</span><br><span class="line">  emit(E.place ‘:&#x3D;’ E 1.place ‘and’ E2.place)&#125;</span><br><span class="line"></span><br><span class="line">E→not E1</span><br><span class="line">&#123; E.place:&#x3D;newtemp;</span><br><span class="line">  emit(E.place ‘:&#x3D;’ ‘not’ E 1.place) &#125;</span><br><span class="line"></span><br><span class="line">E→(E1)</span><br><span class="line">&#123; E.place:&#x3D;E1.place &#125;</span><br><span class="line"></span><br><span class="line">E→id1  relop id2 </span><br><span class="line">&#123; E.place:&#x3D;newtemp;</span><br><span class="line">  emit(‘if’  id1.place  relop.op  id2.place ‘goto’ nextstat+3);</span><br><span class="line">  emit(E.place ‘:&#x3D;’ ‘0’);</span><br><span class="line">  emit(‘goto’ nextstat+2);</span><br><span class="line">  emit(E.place‘:&#x3D;’ ‘1’) &#125;</span><br><span class="line"></span><br><span class="line">E→id </span><br><span class="line">&#123; E.place:&#x3D;id.place &#125;</span><br></pre></td></tr></table></figure><h4 id="12-产生布尔表达式三地址代码的属性文法"><a href="#12-产生布尔表达式三地址代码的属性文法" class="headerlink" title="12 产生布尔表达式三地址代码的属性文法"></a>12 产生布尔表达式三地址代码的属性文法</h4><p>语义函数newlabel，返回一个新的符号标号；<br>对于一个布尔表达式E，设置两个继承属性：E.true是E为‘真’时控制流转向的标号，E.false是E为‘假’时控制流转向的标号；<br>E.code记录E生成的三地址代码序列。</p><p>E→E1 or E2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">E1.true:&#x3D;E.true;</span><br><span class="line">E1.false:&#x3D;newlabel;</span><br><span class="line">E2.true:&#x3D;E.true;</span><br><span class="line">E2.false:&#x3D;E.false;</span><br><span class="line">E.code:&#x3D;E1.code || gen(E1.false ‘:’) || E2.code</span><br></pre></td></tr></table></figure><p>E→E1 and E2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">E1.true:&#x3D;newlabel;</span><br><span class="line">E1.false:&#x3D;E.false;</span><br><span class="line">E2.true:&#x3D;E.true;</span><br><span class="line">E2.false:&#x3D;E.fasle;</span><br><span class="line">E.code:&#x3D;E1.code || gen(E1.true ‘:’) || E2.code</span><br></pre></td></tr></table></figure><p>E→not E1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">E1.true:&#x3D;E.false;</span><br><span class="line">E1.false:&#x3D;E.true;</span><br><span class="line">E.code:&#x3D;E1.code</span><br></pre></td></tr></table></figure><p>E→ (E1)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">E1.true:&#x3D;E.true;</span><br><span class="line">E1.false:&#x3D;E.false;</span><br><span class="line">E.code:&#x3D;E1.code</span><br></pre></td></tr></table></figure><p>E→id1 relop id2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">E.code:&#x3D;gen(‘if ’ id1.place relop.op id2.place ‘goto’ E.true) </span><br><span class="line">        || gen(‘goto’  E.false)</span><br></pre></td></tr></table></figure><p>E→true：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E.code:&#x3D;gen(‘goto’  E.true)</span><br></pre></td></tr></table></figure><p>E→false：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E.code:&#x3D;gen(‘goto’  E.false)</span><br></pre></td></tr></table></figure><h4 id="13-一遍扫描翻译模式"><a href="#13-一遍扫描翻译模式" class="headerlink" title="13 一遍扫描翻译模式"></a>13 一遍扫描翻译模式</h4><p>以四元式为中间语言。<br>四元式存入一个数组中，数组下标代表四元式的标号。<br>约定：<br>四元式(jnz, a, -, p)    表示    <code>if  a  goto  p</code> ；<br>四元式(jrop, x, y, p) 表示    <code>if  x rop y  goto  p</code>；<br>四元式(j, -, -, p) 表示    <code>goto  p</code>。</p><p>产生跳转四元式时，它的转移地址无法立即知道，需要以后扫描到特定位置时才能回过头来确定，把这些未完成的四元式地址作为E的语义值保存,待机“回填”。</p><p>为非终结符E赋予两个综合属性E.truelist和E.falselist。它们分别记录布尔表达式E所对应的四元式中需回填“真”、“假”出口的四元式的标号所构成的链表。   </p><p>引入语义变量和过程：<br>变量nextquad，它指向下一条将要产生但尚未形成的四元式的地址(标号)。nextquad的初值为1，每当执行一次emit之后，nextquad将自动增1；<br>函数makelist(i)，它将创建一个仅含i的新链表，其中i是四元式数组的一个下标(标号)；函数返回指向这个链的指针；<br>函数merge(p1,p2)， 把以p1和p2为链首的两条链合并为一，作为函数值，回送合并后的链首；<br>过程backpatch(p, t)，其功能是完成“回填”，把p所链接的每个四元式的第四区段都填为t。</p><p>布尔表达式的文法：<br>(1) E → E1 or M E2<br>(2) E → E1 and M E2<br>(3)     E → not E1<br>(4)     E → (E1)<br>(5) E → id1 relop id2<br>(6)     E → id<br>(7) M→𝜀  </p><p>E→E1 or M E2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; backpatch(E1.falselist, M.quad);</span><br><span class="line">  E.truelist:&#x3D;merge(E1.truelist, E2.truelist);</span><br><span class="line">  E.falselist:&#x3D;E2.falselist &#125;</span><br></pre></td></tr></table></figure><p>E→E1 and M E2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; backpatch(E1.truelist, M.quad);</span><br><span class="line">  E.truelist:&#x3D;E2.truelist;</span><br><span class="line">  E.falselist:&#x3D;merge(E1.falselist,E2.falselist) &#125;</span><br></pre></td></tr></table></figure><p>E→not E1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123; E.truelist:&#x3D;E1.falselist;</span><br><span class="line">  E.falselist:&#x3D;E1.truelist&#125;</span><br></pre></td></tr></table></figure><p>E→ (E1)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123; E.truelist:&#x3D;E1.truelist;</span><br><span class="line">  E.falselist:&#x3D;E1.falselist&#125;</span><br></pre></td></tr></table></figure><p>E→id1 relop id2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123; E.truelist:&#x3D;makelist(nextquad);</span><br><span class="line">  E.falselist:&#x3D;makelist(nextquad+1);</span><br><span class="line">  emit(‘j’ relop.op ‘,’ id 1.place ‘,’ id 2.place‘,’　‘0’);</span><br><span class="line">  emit(‘j, －, －, 0’) &#125;</span><br></pre></td></tr></table></figure><p>E→id：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123; E.truelist:&#x3D;makelist(nextquad);</span><br><span class="line">  E.falselist:&#x3D;makelist(nextquad+1);</span><br><span class="line">  emit(‘jnz’ ‘,’ id .place ‘,’ ‘－’ ‘,’　‘0’)；</span><br><span class="line">  emit(‘ j, -, -, 0’) &#125;</span><br></pre></td></tr></table></figure><h3 id="第四部分：控制语句的翻译"><a href="#第四部分：控制语句的翻译" class="headerlink" title="第四部分：控制语句的翻译"></a>第四部分：控制语句的翻译</h3><h4 id="14-常用的控制语句"><a href="#14-常用的控制语句" class="headerlink" title="14 常用的控制语句"></a>14 常用的控制语句</h4><p>S → if E then S1<br>S → if E then S1 else S2<br>S → while E do S1<br>其中E为布尔表达式。</p><h4 id="15-if语句的属性文法"><a href="#15-if语句的属性文法" class="headerlink" title="15 if语句的属性文法"></a>15 if语句的属性文法</h4><p>S→if E then S1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">E.true:&#x3D;newlabel;</span><br><span class="line">E.flase:&#x3D;S.next;</span><br><span class="line">S1.next:&#x3D;S.next</span><br><span class="line">S.code:&#x3D;E.code || gen(E.true ‘:’) || S1.code</span><br></pre></td></tr></table></figure><p>S→if E then S1 else S2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">E.true:&#x3D;newlabel;</span><br><span class="line">E.false:&#x3D;newlabel;</span><br><span class="line">S1.next:&#x3D;S.next</span><br><span class="line">S2.next:&#x3D;S.next;</span><br><span class="line">S.code:&#x3D;E.code || </span><br><span class="line">        gen(E.true ‘:’) || S1.code ||</span><br><span class="line">        gen(‘goto’  S.next) ||</span><br><span class="line">        gen(E.false ‘:’) || S2.code</span><br></pre></td></tr></table></figure><h4 id="16-while语句的属性文法"><a href="#16-while语句的属性文法" class="headerlink" title="16 while语句的属性文法"></a>16 while语句的属性文法</h4><p>S→while E do S1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">S.begin:&#x3D;newlabel;</span><br><span class="line">E.true:&#x3D;newlabel;</span><br><span class="line">E.false:&#x3D;S.next;</span><br><span class="line">S1.next:&#x3D;S.begin;</span><br><span class="line">S.code:&#x3D;gen(S.begin ‘:’) || E.code || </span><br><span class="line">        gen(E.true ‘:’) || S1.code ||</span><br><span class="line">        gen(‘goto’  S.begin)</span><br></pre></td></tr></table></figure><h4 id="17-一遍扫描翻译控制语句"><a href="#17-一遍扫描翻译控制语句" class="headerlink" title="17 一遍扫描翻译控制语句"></a>17 一遍扫描翻译控制语句</h4><p>控制语句的文法：<br>(1) S → if E then S<br>(2) S → if E then S else S<br>(3)    S → while E do S<br>(4) S → begin L end<br>(5)    S → A<br>(6) L → L;S<br>(7)    L → S  </p><p>if 语句的翻译模式：<br>S→if E then M S1：        </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123; backpatch(E.truelist, M.quad);</span><br><span class="line">  S.nextlist:&#x3D;merge(E.falselist, S1.nextlist) &#125;</span><br></pre></td></tr></table></figure><p>S→if E then M1 S1 N else M2 S2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; backpatch(E.truelist, M1.quad);</span><br><span class="line">  backpatch(E.falselist, M2.quad);</span><br><span class="line">  S.nextlist:&#x3D;merge(S1.nextlist, N.nextlist, S2.nextlist) &#125;</span><br></pre></td></tr></table></figure><p>M→𝜀：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; M.quad:&#x3D;nextquad &#125;</span><br></pre></td></tr></table></figure><p>N→𝜀：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123; N.nextlist:&#x3D;makelist(nextquad);</span><br><span class="line">  emit(‘j,－,－,－’) &#125;</span><br></pre></td></tr></table></figure><p>while-do语句的翻译模式：<br>S → while M1 E do M2 S1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123; backpatch(E.truelist, M2.quad);</span><br><span class="line">  backpatch(S1.nextlist, M1.quad);</span><br><span class="line">  S.nextlist :&#x3D; E.falselist;</span><br><span class="line">  emit(‘j,－,－,’ M1.quad)  &#125;</span><br></pre></td></tr></table></figure><p>M → 𝜀：    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  M.quad :&#x3D; nextquad  &#125;</span><br></pre></td></tr></table></figure><p>复合语句的翻译模式：<br>S → begin L end：        </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; S.nextlist :&#x3D; L.nextlist &#125;</span><br></pre></td></tr></table></figure><p>L → L1; M S：            </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123; backpatch(L1.nextlist, M.quad);</span><br><span class="line">  L.nextlist :&#x3D; S.nextlist &#125;</span><br></pre></td></tr></table></figure><p>M → 𝜀：     </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; M.quad :&#x3D; nextquad &#125;</span><br></pre></td></tr></table></figure><p>其它几个语句的翻译：<br>S → A：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; S.nextlist :&#x3D; makelist( ) &#125;</span><br></pre></td></tr></table></figure><p>L → S：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; L.nextlist :&#x3D; S.nextlist &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理学习笔记七-属性文法和语法制导翻译</title>
      <link href="/2020/04/05/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%83-%E5%B1%9E%E6%80%A7%E6%96%87%E6%B3%95%E5%92%8C%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%BF%BB%E8%AF%91/"/>
      <url>/2020/04/05/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%83-%E5%B1%9E%E6%80%A7%E6%96%87%E6%B3%95%E5%92%8C%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%BF%BB%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<h1 id="第七章-属性文法和语法制导翻译"><a href="#第七章-属性文法和语法制导翻译" class="headerlink" title="第七章 属性文法和语法制导翻译"></a>第七章 属性文法和语法制导翻译</h1><h3 id="第一部分：属性文法及属性计算方法"><a href="#第一部分：属性文法及属性计算方法" class="headerlink" title="第一部分：属性文法及属性计算方法"></a>第一部分：属性文法及属性计算方法</h3><h4 id="1-属性文法"><a href="#1-属性文法" class="headerlink" title="1 属性文法"></a>1 属性文法</h4><p>以上下文无关文法为基础；<br>为每个文法符号（终结符或非终结符）配备若干相关的“值”（称为属性），代表与文法符号相关信息，如类型、值、代码序列、符号表内容等；<br>对于文法的每个产生式都配备了一组属性的语义规则，对属性进行计算和传递。</p><h4 id="2-综合属性"><a href="#2-综合属性" class="headerlink" title="2 综合属性"></a>2 综合属性</h4><p>自下而上传递信息；<br>语法规则：根据右部候选式中的符号的属性计算左部被定义符号的综合属性；<br>语法树：根据子结点的属性和父结点自身的属性计算父节点的综合属性。</p><h4 id="3-继承属性"><a href="#3-继承属性" class="headerlink" title="3 继承属性"></a>3 继承属性</h4><p>自上而下传递信息；<br>语法规则：根据右部候选式中的符号的属性和左部被定义符号的属性计算右部候选式中的符号的继承属性；<br>语法树：根据父结点和兄弟节点的属性计算子结点的继承属性。</p><h4 id="4-属性依赖"><a href="#4-属性依赖" class="headerlink" title="4 属性依赖"></a>4 属性依赖</h4><p>对应于每个产生式A→α都有一套与之相关联的语义规则，每条规则的形式为(f是一个函数)：<br>b:=f(c1,c2,…,ck)<br>属性b依赖于属性c1,c2,…,ck：<br>b是A的一个综合属性并且c1,c2,…,ck是产生式右边文法符号的属性，或者<br>b是产生式右边某个文法符号的一个继承属性并且c1,c2,…,ck是A或产生式右边任何文法符号的属性。</p><p>终结符只有综合属性，由词法分析器提供；<br>非终结符既可有综合属性也可有继承属性，文法开始符号的所有继承属性作为属性计算前的初始值。</p><h4 id="5-语义规则"><a href="#5-语义规则" class="headerlink" title="5 语义规则"></a>5 语义规则</h4><p>对出现在产生式右边的继承属性和出现在产生式左边的综合属性都必须提供一个计算规则。属性计算规则中只能使用相应产生式中的文法符号的属性。</p><p>出现在产生式左边的继承属性和出现在产生式右边的综合属性不由所给的产生式的属性计算规则进行计算，由其它产生式的属性规则计算或者由属性计算器的参数提供。</p><p>语义规则所描述的工作可以包括属性计算、静态语义检查、符号表操作、代码生成等。</p><h4 id="6-带注释的语法树"><a href="#6-带注释的语法树" class="headerlink" title="6 带注释的语法树"></a>6 带注释的语法树</h4><p>在语法树中，一个结点的综合属性的值由其子结点和它本身的属性值确定，使用自底向上的方法在每一个结点处使用语义规则计算综合属性的值，仅使用综合属性的属性文法称S－属性文法。</p><p>在语法树中，一个结点的继承属性由其父结点、其兄弟结点和其本身的某些属性确定，用继承属性来表示程序设计语言结构中的上下文依赖关系很方便。</p><h4 id="7-基于属性文法的处理方法"><a href="#7-基于属性文法的处理方法" class="headerlink" title="7 基于属性文法的处理方法"></a>7 基于属性文法的处理方法</h4><p>语义规则的计算：<br>产生代码；<br>在符号表中存放信息；<br>给出错误信息；<br>执行任何其它动作。  </p><p>对输入串的翻译就是根据语义规则进行计算。<br>由源程序的语法结构所驱动的处理办法就是语法制导翻译法。  </p><p>基于属性文法的处理方法有依赖图、 树遍历、一遍扫描。</p><h4 id="8-依赖图"><a href="#8-依赖图" class="headerlink" title="8 依赖图"></a>8 依赖图</h4><p>在一棵语法树中的结点的继承属性和综合属性之间的相互依赖关系可以由依赖图(有向图)来描述。<br>为每一个包含过程调用的语义规则引入一个虚综合属性b，这样把每一个语义规则都写成b:=f(c1,c2,…,ck)的形式。<br>依赖图中为每一个属性设置一个结点，如果属性b依赖于属性c，则从属性c的结点有一条有向边连到属性b的结点。</p><p>依赖图的构建算法：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for   语法树中每一结点n  do</span><br><span class="line">   for  结点n的文法符号的每一个属性a  do</span><br><span class="line">         为a在依赖图中建立一个结点；</span><br><span class="line">for 语法树中每一个结点n  do</span><br><span class="line">   for  结点n所用产生式对应的每一个语义规则</span><br><span class="line">b:&#x3D;f(c1,c2,…,ck )  do</span><br><span class="line">         for  i:&#x3D;1 to k  do</span><br><span class="line">               从ci结点到b结点构造一条有向边；</span><br></pre></td></tr></table></figure><p>依赖图示例:<br><img src="/2020/04/05/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%83-%E5%B1%9E%E6%80%A7%E6%96%87%E6%B3%95%E5%92%8C%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%BF%BB%E8%AF%91/1.png" alt="依赖图示例"></p><p>如果一属性文法不存在属性之间的循环依赖关系，则称该文法为良定义的；<br>一个依赖图的任何拓扑排序都给出一个语法树中结点的语义规则计算的有效顺序。</p><p>属性的计算次序：<br>基础文法用于建立输入符号串的语法分析树；<br>根据语义规则建立依赖图；<br>根据依赖图的拓扑排序，得到计算语义规则的顺序。  </p><h4 id="9-树遍历"><a href="#9-树遍历" class="headerlink" title="9 树遍历"></a>9 树遍历</h4><p>通过树遍历的方法计算属性的值：<br>假设语法树已建立，且树中已带有开始符号的继承属性和终结符的综合属性，以某种次序遍历语法树，直至计算出所有属性。<br>深度优先，从左到右的遍历。 </p><p>树遍历算法：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">While  还有未被计算的属性  do</span><br><span class="line">VisitNode(S)   &#x2F;*S是开始符号*&#x2F;</span><br><span class="line"></span><br><span class="line">procedure VisitNode (N:Node) ;</span><br><span class="line">begin</span><br><span class="line">     if N是一个非终结符 then  &#x2F;*假设其产生式为N→X1…Xm*&#x2F;</span><br><span class="line">     for i :&#x3D;1 to  m  do</span><br><span class="line">              if Xi∈VN  then &#x2F;*即Xi是非终结符*&#x2F;</span><br><span class="line">         begin</span><br><span class="line">              计算Xi的所有能够计算的继承属性；</span><br><span class="line">              VisitNode (Xi)</span><br><span class="line">              end;</span><br><span class="line">     计算N的所有能够计算的综合属性</span><br></pre></td></tr></table></figure><p>树遍历算法示例：<br>考虑属性的文法G(S)，其中，<br>S有继承属性a，综合属性b，<br>X有继承属性c、综合属性d，<br>Y有继承属性e、综合属性f，<br>Z有继承属性h、综合属性g。  </p><p><img src="/2020/04/05/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%83-%E5%B1%9E%E6%80%A7%E6%96%87%E6%B3%95%E5%92%8C%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%BF%BB%E8%AF%91/2.png" alt="树遍历示例"></p><h4 id="10-一遍扫描（效率较高）"><a href="#10-一遍扫描（效率较高）" class="headerlink" title="10 一遍扫描（效率较高）"></a>10 一遍扫描（效率较高）</h4><p>一遍扫描在语法分析的同时计算属性值，取决于所采用的语法分析方法和属性的计算次序。<br>所谓语法制导翻译法，直观上说就是为文法中每个产生式配上一组语义规则，并且在语法分析的同时执行这些语义规则。<br>语义规则被计算的时机：<br>自上而下分析，一个产生式匹配输入串成功时；<br>自下而上分析，一个产生式被用于进行归约时 。</p><p>抽象语法树：<br>抽象语法树(Abstract Syntax Tree，AST)，在语法树中去掉那些对翻译不必要的信息，从而获得更有效的源程序中间表示。<br><img src="/2020/04/05/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%83-%E5%B1%9E%E6%80%A7%E6%96%87%E6%B3%95%E5%92%8C%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%BF%BB%E8%AF%91/3.png" alt="抽象语法树"></p><p>建立表达式的抽象语法树：<br>mknode(op, left, right) 建立一个运算符号结点，标号是op，两个域left和right分别指向左子树和右子树；<br>mkleaf(id, entry) 建立一个标识符结点，标号为id，一个域entry指向标识符在符号表中的入口；<br>mkleaf(num, val) 建立一个数结点，标号为num，一个域val用于存放数的值。</p><p>建立抽象语法树的语义规则：<br>E→E1+T 转换为 <code>E.nptr := mknode(&#39;+&#39;, E1.nptr, T.nptr )</code><br>E→E1-T 转换为 <code>E.nptr := mknode(&#39;-&#39;, E1.nptr, T.nptr )</code><br>E→T 转换为 <code>E.nptr := T.nptr</code><br>T→id 转换为 <code>T.nptr := mkleaf ( id, id.entry )</code><br>T→num 转换为 <code>T.nptr := mkleaf ( num, num.val )</code>   </p><p>示例：<br><img src="/2020/04/05/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%83-%E5%B1%9E%E6%80%A7%E6%96%87%E6%B3%95%E5%92%8C%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%BF%BB%E8%AF%91/4.png" alt="一遍扫描"></p><h3 id="第二部分：语法制导翻译方法和翻译模式的设计"><a href="#第二部分：语法制导翻译方法和翻译模式的设计" class="headerlink" title="第二部分：语法制导翻译方法和翻译模式的设计"></a>第二部分：语法制导翻译方法和翻译模式的设计</h3><h4 id="11-S-属性文法"><a href="#11-S-属性文法" class="headerlink" title="11 S-属性文法"></a>11 S-属性文法</h4><p>S-属性文法：只含有综合属性。<br>在自下而上的分析器分析输入符号串的同时计算综合属性，<br>分析栈中保存语法符号和有关的综合属性值，<br>每当进行归约时，新的语法符号的属性值就由栈中正在归约的产生式右边符号的属性值来计算。</p><p>示例：<br><img src="/2020/04/05/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%83-%E5%B1%9E%E6%80%A7%E6%96%87%E6%B3%95%E5%92%8C%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%BF%BB%E8%AF%91/5.png" alt="S-属性文法"></p><h4 id="12-L-属性文法"><a href="#12-L-属性文法" class="headerlink" title="12 L-属性文法"></a>12 L-属性文法</h4><p>S－属性文法适合一遍扫描的自下而上分析；<br>L－属性文法适合一遍扫描的自上而下分析。</p><p>一个属性文法称为L-属性文法，如果对于每个产生式A→X1X2…Xn，其每个语义规则中的每个属性或者是综合属性，或者是Xi(1≤i≤n)的一个继承属性且这个继承属性仅依赖于：<br>(1) 产生式中Xi左边符号X1，X2，…，Xi-1的属性；<br>(2) A的继承属性。<br>S-属性文法一定是L-属性文法</p><p>L－属性文法按照深度优先遍历语法树，计算所有属性值，与LL(1) 自上而下分析方法结合，深度优先建立语法树，按照语义规则计算属性。</p><h4 id="13-翻译模式"><a href="#13-翻译模式" class="headerlink" title="13 翻译模式"></a>13 翻译模式</h4><p>语义规则：给出了属性计算的定义，没有属性计算的次序等实现细节。<br>翻译模式：给出使用语义规则进行计算的次序，把实现细节表示出来。<br>在翻译模式中，和文法符号相关的属性和语义规则（也称语义动作），用花括号{ }括起来，插入到产生式右部的合适位置上。</p><p>设计翻译模式的原则：<br>设计翻译模式时，必须保证当某个动作引用一个属性时它必须是有定义的，L-属性文法本身就能确保每个动作不会引用尚未计算出来的属性。  </p><p>当只需要综合属性时，为每一个语义规则建立一个包含赋值的动作，并把这个动作放在相应的产生式右边的末尾。</p><p>如果既有综合属性又有继承属性，在建立翻译模式时就必须保证：</p><ol><li>产生式右边的符号的继承属性必须在这个符号以前的动作中计算出来；  </li><li>一个动作不能引用这个动作右边的符号的综合属性；  </li><li>产生式左边非终结符的综合属性只有在它所引用的所有属性都计算出来以后才能计算，计算这种属性的动作通常可放在产生式右端的末尾。</li></ol><h4 id="14-语义动作执行时机统一"><a href="#14-语义动作执行时机统一" class="headerlink" title="14 语义动作执行时机统一"></a>14 语义动作执行时机统一</h4><p>把所有的语义动作都放在产生式的末尾，语义动作的执行时机统一。<br>转换方法：<br>加入新产生式M→𝜀，<br>把嵌入在产生式中的每个语义动作用不同的非终结符M代替，并把这个动作放在产生式M→的末尾。 </p><h4 id="15-消除翻译模式中的左递归"><a href="#15-消除翻译模式中的左递归" class="headerlink" title="15 消除翻译模式中的左递归"></a>15 消除翻译模式中的左递归</h4><p>语义动作是在相同位置上的符号被展开（匹配成功）时执行的，为了构造不带回溯的自顶向下语法分析，必须消除文法中的左递归。<br>当消除一个翻译模式的基本文法的左递归时同时考虑属性计算，适合带综合属性的翻译模式。</p><p>假设有翻译模式：<br>A → A1Y    {A.a:=g(A1.a, Y.y) }<br>A → X {A.a:=f(X.x) }<br>它的每个文法符号都有一个综合属性，用小写字母表示，g和f是任意函数。<br>基础文法消除左递归：<br>A → XR<br>R → YR<br>翻译模式消除左递归：<br>A →  X    {R.i:=f (X.x) }<br>         R    {A.a:=R.s}<br>R →  Y {R1.i:=g(R.i, Y.y) } R1 {R.s:=R1.s}<br>R →  𝜀 {R.s:=R.i}  </p><h4 id="16-递归下降翻译器的设计"><a href="#16-递归下降翻译器的设计" class="headerlink" title="16 递归下降翻译器的设计"></a>16 递归下降翻译器的设计</h4><p>分析程序由一组递归子程序(函数)组成，每个非终结符对应一个子程序(函数)。</p><p>对每个非终结符A构造一个函数过程：<br>A的属性实现为参数和变量：<br>继承属性：对A的每个继承属性设置为函数的一个形式参数；<br>综合属性：实现为函数的返回值，若有多个综合属性，打包成作为结构或记录记录返回，为了简单，我们假设每个非终结只有一个综合属性；<br>A的产生式中的每一个文法符号的每一个属性：实现为A对应的函数过程中的局部变量。</p><p>非终结符A对应的函数过程中，根据当前的输入符号决定使用哪个产生式候选。</p><p>按照产生式右部从左到右的，对于单词符号（终结符）、非终结符和语义动作，分别实现：<br>对于带有综合属性x的终结符X，把x的值存入为X.x设置的变量中。然后产生一个匹配X的调用，并继续读入一个输入符号。<br>对于每个非终结符B，产生一个右边带有函数调用的赋值语句c=B(b1,b2,…,bk)，其中，b1,b2,…,bk是为B的继承属性设置的变量，c是为B的综合属性设置的变量。<br>对于语义动作，把动作的代码抄进分析器中，用代表属性的变量来代替对属性的每一次引用。</p>]]></content>
      
      
      <categories>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统课程学习笔记九-文件管理</title>
      <link href="/2020/03/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%9D-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
      <url>/2020/03/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%9D-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="第九章-文件管理"><a href="#第九章-文件管理" class="headerlink" title="第九章 文件管理"></a>第九章 文件管理</h1><h4 id="9-1-什么是文件，什么是文件系统？"><a href="#9-1-什么是文件，什么是文件系统？" class="headerlink" title="9.1 什么是文件，什么是文件系统？"></a>9.1 什么是文件，什么是文件系统？</h4><p>文件是计算机信息存取的一种重要组织形式。<br>文件由若干信息项有序构成，信息项可以是字节，可以是结构化数据。用户通过读写指针存取文件的信息项。文件具有文件名，用户通过文件名存取文件。<br>负责管理文件的机构称为文件系统。负责文件的创立、撤销、读写、修改、复制、存取控制等，并管理存放文件的存储设备。</p><h4 id="9-2-什么是文件的逻辑结构？有哪二种典型的逻辑结构？"><a href="#9-2-什么是文件的逻辑结构？有哪二种典型的逻辑结构？" class="headerlink" title="9.2 什么是文件的逻辑结构？有哪二种典型的逻辑结构？"></a>9.2 什么是文件的逻辑结构？有哪二种典型的逻辑结构？</h4><p>文件的逻辑结构是用户的观点，为用户提供逻辑结构清晰、使用方便的文件，强调文件信息项的构成方式和用户的存取方式。有两种典型逻辑结构：<br>记录式文件，信息项是记录，结构化数据，文件中需要保存记录长度和数量等说明信息，浪费存储空间；<br>流式文件，信息项是字节，文件长度就是字节的数量，文件无需额外说明信息，节省存储空间。</p><h4 id="9-3-什么是文件的物理结构？有哪三种典型的物理结构？"><a href="#9-3-什么是文件的物理结构？有哪三种典型的物理结构？" class="headerlink" title="9.3 什么是文件的物理结构？有哪三种典型的物理结构？"></a>9.3 什么是文件的物理结构？有哪三种典型的物理结构？</h4><p>文件的物理结构是系统的观点，文件在存储设备上的存储结构，强调合理利用存储空间，缩短I/O存取时间。有三种典型物理结构：<br>连续文件，文件按逻辑块的顺序存放在硬盘连续的物理存储块中，文件目录记录文件长度（块数）和第一个储存块的块号，简单，支持顺序存取和随机存取，顺序存取速度快，但文件不易动态增长，不利于文件插入、删除，有外部碎片问题；<br>索引文件，文件存放在不连续的存储块中，靠索引表记录文件逻辑块和物理存储块的对应联系，先访问索引再访问数据，支持顺序存储和随机存储，支持文件动态增长、插入、删除；<br>串联文件，文件存放在不连续的存储块中，是靠链表的形式将储存块联系起来。适用于顺序存取，随机存取较为困难，提高了磁盘空间利用率，不存在外部碎片问题，有利于文件动态扩充、插入、删除。</p><h4 id="9-4-文件还原工具的工作原理是什么？"><a href="#9-4-文件还原工具的工作原理是什么？" class="headerlink" title="9.4 文件还原工具的工作原理是什么？"></a>9.4 文件还原工具的工作原理是什么？</h4><p>删除文件后文件并未真正清空，只是文件在硬盘中首字节改变，fat表中对应簇的信息被清空；<br>FAT32文件系统数据删除后，会将描述文件存放地址的高位字节清零，文件分配表也清空，文件还原工具就是找到位置并恢复信息，但并不能百分百找到。</p><h4 id="9-5-何为空闲文件，何为空闲文件目录？"><a href="#9-5-何为空闲文件，何为空闲文件目录？" class="headerlink" title="9.5 何为空闲文件，何为空闲文件目录？"></a>9.5 何为空闲文件，何为空闲文件目录？</h4><p>空闲文件：把连续空闲区看作一个特殊文件，由多个连续空闲块组成。<br>空闲文件目录：所有空闲文件代表存储设备全部空闲空间，为每个空闲文件建立的专门目录，每个表项对应一个空闲文件，包括第一个空闲块号，空闲块个数等信息。</p><h4 id="9-6-何为文件目录，其作用是什么？何为目录文件？"><a href="#9-6-何为文件目录，其作用是什么？何为目录文件？" class="headerlink" title="9.6 何为文件目录，其作用是什么？何为目录文件？"></a>9.6 何为文件目录，其作用是什么？何为目录文件？</h4><p>文件目录是文件名址录，记录文件名和存放地址的目录表，具有将文件名转换为外存物理位置的功能，文件属性也记录在目录中。<br>文件目录以文件形式存于外存，这个文件叫目录文件。</p><h4 id="9-7-研究FAT16文件系统的结构。"><a href="#9-7-研究FAT16文件系统的结构。" class="headerlink" title="9.7 研究FAT16文件系统的结构。"></a>9.7 研究FAT16文件系统的结构。</h4><p><a href="http://blog.chinaunix.net/uid-23215128-id-2521274.html" target="_blank" rel="noopener">http://blog.chinaunix.net/uid-23215128-id-2521274.html</a></p><h4 id="9-8-了解Linux虚拟文件系统的概念和作用。"><a href="#9-8-了解Linux虚拟文件系统的概念和作用。" class="headerlink" title="9.8 了解Linux虚拟文件系统的概念和作用。"></a>9.8 了解Linux虚拟文件系统的概念和作用。</h4><p><a href="https://blog.csdn.net/jy54264946/article/details/61925853" target="_blank" rel="noopener">https://blog.csdn.net/jy54264946/article/details/61925853</a></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统课程学习笔记八-设备管理</title>
      <link href="/2020/03/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AB-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/"/>
      <url>/2020/03/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AB-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="第八章-设备管理"><a href="#第八章-设备管理" class="headerlink" title="第八章 设备管理"></a>第八章 设备管理</h1><h4 id="8-1-操作系统公司会不会去专门花精力编写外设的控制程序-驱动程序呢？"><a href="#8-1-操作系统公司会不会去专门花精力编写外设的控制程序-驱动程序呢？" class="headerlink" title="8.1 操作系统公司会不会去专门花精力编写外设的控制程序/驱动程序呢？"></a>8.1 操作系统公司会不会去专门花精力编写外设的控制程序/驱动程序呢？</h4><p>不会，操作系统公司只需要做好接口标准就行，外设的驱动程序交给外设生产商去做。毕竟外设种类样式繁多。</p><h4 id="8-2-什么是设备映射？"><a href="#8-2-什么是设备映射？" class="headerlink" title="8.2 什么是设备映射？"></a>8.2 什么是设备映射？</h4><p>物理设备是指实际安装的设备，逻辑设备是指应用软件使用的设备（逻辑名）。物理设备是逻辑设备的实例，逻辑设备是物理设备的抽象。设备管理模块将逻辑设备映射到物理设备。</p><h4 id="8-3-什么是设备的独立性？"><a href="#8-3-什么是设备的独立性？" class="headerlink" title="8.3 什么是设备的独立性？"></a>8.3 什么是设备的独立性？</h4><p>物理设备对用户透明，用户使用统一规范的方式使用设备。用户编程时使用设备逻辑名，由系统实现逻辑设备到物理设备的转换。</p><h4 id="8-4-什么是设备驱动？"><a href="#8-4-什么是设备驱动？" class="headerlink" title="8.4 什么是设备驱动？"></a>8.4 什么是设备驱动？</h4><p>设备驱动对物理设备进行控制，实现I/O操作，接收应用的服务请求，转换为具体的I/O指令，控制设备完成相关操作，向用户提供统一接口。</p><h4 id="8-5-什么虚拟分配？什么是Spooling技术？"><a href="#8-5-什么虚拟分配？什么是Spooling技术？" class="headerlink" title="8.5 什么虚拟分配？什么是Spooling技术？"></a>8.5 什么虚拟分配？什么是Spooling技术？</h4><p>虚拟分配是指，当进程需要与独占设备交换信息时，采用虚拟技术将与该独占设备所对应的虚拟设备分配给它。<br>Spooling系统是虚拟技术与虚拟分配的一种实现：输入井和输出井是磁盘上开辟的两个存储区域，模拟脱机输入输出时的磁盘；输入缓冲区和输出缓冲区是内存中开辟的存储区域，暂存输入输出数据，便于将来传入输入井或输出设备；输入输出监控进程模拟脱机输入输出的卫星机。</p><h4 id="8-6-SPOOLing系统的工作原理是什么？"><a href="#8-6-SPOOLing系统的工作原理是什么？" class="headerlink" title="8.6 SPOOLing系统的工作原理是什么？"></a>8.6 SPOOLing系统的工作原理是什么？</h4><p>任务执行前，预先将程序和数据输入到输入井；<br>任务运行时，要使用数据，从输入井取出，要输出数据，写入输出井；<br>任务运行完，外设空闲时输出全部数据和信息。</p><h4 id="8-7-什么是LINUX模块机制？"><a href="#8-7-什么是LINUX模块机制？" class="headerlink" title="8.7 什么是LINUX模块机制？"></a>8.7 什么是LINUX模块机制？</h4><p>LINUX模块机制就是把功能模块化，外部代码经过装载即可成为内核的一部分，模块也可以动态卸载、动态加载、动态更新。</p><h4 id="8-8-Linux设备主要有哪三类？"><a href="#8-8-Linux设备主要有哪三类？" class="headerlink" title="8.8 Linux设备主要有哪三类？"></a>8.8 Linux设备主要有哪三类？</h4><p>字符设备：以字节为单位逐个进行I/O操作，如串口设备，可以看成是用字节流存取的文件；<br>块设备：存取通过buffer、cache进行，可以随机访问，支持可安装文件系统，如IDE硬盘，可以看成是可以任意存取字节数的字符设备，在应用上只是内核管理数据方式不同；<br>网络设备：通过BSD套接口访问（SOCKET），没有相应的read write，它是面向流的一种特殊设备。</p><h4 id="8-9-什么叫设备文件，如何读写，有何作用？"><a href="#8-9-什么叫设备文件，如何读写，有何作用？" class="headerlink" title="8.9 什么叫设备文件，如何读写，有何作用？"></a>8.9 什么叫设备文件，如何读写，有何作用？</h4><p>所有的设备都是以文件的形式描述，这类文件称为设备文件。<br>要操作一个设备，就是对一个对应的文件进行读写。可以按照文件一样对设备文件进行 open / read / write 等操作。当应用程序对一个设备文件调用这些系统调用时，驱动将收到这个操作的请求，然后调用相对应的操作进行处理，这样就可以和kernel层的dev设备关联起来。</p><h4 id="8-10-Linux中如何把驱动程序中自定义的接口与文件操作的标准接口关联起来"><a href="#8-10-Linux中如何把驱动程序中自定义的接口与文件操作的标准接口关联起来" class="headerlink" title="8.10 Linux中如何把驱动程序中自定义的接口与文件操作的标准接口关联起来?"></a>8.10 Linux中如何把驱动程序中自定义的接口与文件操作的标准接口关联起来?</h4><p>在结构file_operations里，指出了设备驱动程序所提供的入口点位置，设备驱动程序所提供的入口点在设备驱动程序初始化的时候向系统进行登记，以便系统在适当的时候调用。<br>通过在file_operations结构体中为open、write、release等变量赋值，可以将自定义接口与标准接口相关联。</p><h4 id="8-11-Windows中应用程序访问设备对象的一种方法？"><a href="#8-11-Windows中应用程序访问设备对象的一种方法？" class="headerlink" title="8.11 Windows中应用程序访问设备对象的一种方法？"></a>8.11 Windows中应用程序访问设备对象的一种方法？</h4><p>驱动程序中创建设备对象并命名，应用程序通过符号链接访问设备对象。</p><h4 id="8-12-了解Linux下，网络驱动程序的例子和开发过程。"><a href="#8-12-了解Linux下，网络驱动程序的例子和开发过程。" class="headerlink" title="8.12 了解Linux下，网络驱动程序的例子和开发过程。"></a>8.12 了解Linux下，网络驱动程序的例子和开发过程。</h4><p><a href="https://blog.csdn.net/qq_44884706/article/details/89454082" target="_blank" rel="noopener">https://blog.csdn.net/qq_44884706/article/details/89454082</a></p><h4 id="8-13-在Linux下，如何把新编写的驱动程序（或设备）编译到内核中？"><a href="#8-13-在Linux下，如何把新编写的驱动程序（或设备）编译到内核中？" class="headerlink" title="8.13 在Linux下，如何把新编写的驱动程序（或设备）编译到内核中？"></a>8.13 在Linux下，如何把新编写的驱动程序（或设备）编译到内核中？</h4><p><a href="https://blog.csdn.net/chinazhangzhong123/article/details/51527116" target="_blank" rel="noopener">https://blog.csdn.net/chinazhangzhong123/article/details/51527116</a></p><h4 id="8-14-了解Windows下“过滤驱动”程序的例子和开发过程。"><a href="#8-14-了解Windows下“过滤驱动”程序的例子和开发过程。" class="headerlink" title="8.14 了解Windows下“过滤驱动”程序的例子和开发过程。"></a>8.14 了解Windows下“过滤驱动”程序的例子和开发过程。</h4><p><a href="https://blog.csdn.net/nanjun520/article/details/46913307" target="_blank" rel="noopener">https://blog.csdn.net/nanjun520/article/details/46913307</a></p><h4 id="8-15-对比Windows-98，WinXP，WIN7三种典型操作系统下驱动程序结构差异，开发环境的差异。"><a href="#8-15-对比Windows-98，WinXP，WIN7三种典型操作系统下驱动程序结构差异，开发环境的差异。" class="headerlink" title="8.15 对比Windows 98，WinXP，WIN7三种典型操作系统下驱动程序结构差异，开发环境的差异。"></a>8.15 对比Windows 98，WinXP，WIN7三种典型操作系统下驱动程序结构差异，开发环境的差异。</h4><p>WIN98：<a href="https://www.docin.com/p-1403517143.html" target="_blank" rel="noopener">https://www.docin.com/p-1403517143.html</a><br>WINXP：<a href="https://blog.csdn.net/chenyujing1234/article/details/7587227" target="_blank" rel="noopener">https://blog.csdn.net/chenyujing1234/article/details/7587227</a><br>WIN7：<a href="https://blog.csdn.net/ikerpeng/article/details/38822657" target="_blank" rel="noopener">https://blog.csdn.net/ikerpeng/article/details/38822657</a></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统课程学习笔记七-存储管理</title>
      <link href="/2020/03/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%83-%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/"/>
      <url>/2020/03/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%83-%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="第七章-存储管理"><a href="#第七章-存储管理" class="headerlink" title="第七章 存储管理"></a>第七章 存储管理</h1><h4 id="7-1-简述实际的三级存储器体系的结构（组成）和基本原理？"><a href="#7-1-简述实际的三级存储器体系的结构（组成）和基本原理？" class="headerlink" title="7.1 简述实际的三级存储器体系的结构（组成）和基本原理？"></a>7.1 简述实际的三级存储器体系的结构（组成）和基本原理？</h4><figure class="image-box">                <img src="/2020/03/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%83-%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/2.png" alt="三级存储器体系的结构" title class>                <p>三级存储器体系的结构</p>            </figure><p>三级存储体系包括Cache(快、小、贵)、内存(适中)、外存(慢、大、廉)。<br>基本原理：当内存太小不够用时，用外存来支援内存；暂时不运行的模块换出到外存上，必要时再换入内存。</p><h4 id="7-2-存储管理有哪四大功能"><a href="#7-2-存储管理有哪四大功能" class="headerlink" title="7.2 存储管理有哪四大功能?"></a>7.2 存储管理有哪四大功能?</h4><p>地址映射：把程序中的地址（虚拟地址/虚地址/逻辑地址）变换成内存的真实地址（实地址/物理地址）的过程；<br>虚拟存储：解决内存过大造成的内存不够和多程序并发时的地址冲突问题；<br>内存分配：为程序运行分配足够内存空间；<br>存储保护：保证内存中的多道程序只能在给定的存储区域中活动并互不干扰。</p><h4 id="7-3-有哪三种地址映射方式？"><a href="#7-3-有哪三种地址映射方式？" class="headerlink" title="7.3 有哪三种地址映射方式？"></a>7.3 有哪三种地址映射方式？</h4><p>固定地址映射：编程或编译时确定逻辑地址和物理地址映射关系，程序加载时必须放在指定的内存区域，容易产生地址冲突、运行失败，程序装入后不能移动，程序占用连续的内存空间。<br>静态地址映射：程序装入时由操作系统完成逻辑地址到物理地址的映射，程序运行前确定映射关系，程序装入后不能移动，程序占用连续的内存空间。<br>动态地址映射：程序执行过程中把逻辑地址转换为物理地址，程序占用的内存空间可动态变化，不要求占用连续空间，便于多个进程共享，但需要内存管理单元的硬件支持，软件复杂。</p><h4 id="7-4-为何需要地址映射功能或者它的的作用是什么？在VS（C-C-）开发环境中，我们用”int-i-j-”-定义的i-j变量与地址是什么关系？"><a href="#7-4-为何需要地址映射功能或者它的的作用是什么？在VS（C-C-）开发环境中，我们用”int-i-j-”-定义的i-j变量与地址是什么关系？" class="headerlink" title="7.4 为何需要地址映射功能或者它的的作用是什么？在VS（C/C++）开发环境中，我们用”int i,j ;” 定义的i,j变量与地址是什么关系？"></a>7.4 为何需要地址映射功能或者它的的作用是什么？在VS（C/C++）开发环境中，我们用”int i,j ;” 定义的i,j变量与地址是什么关系？</h4><p>地址映射可以让用户方便的读写物理地址，直接使用物理地址比较繁琐，而且不安全。<br>在VS（C/C++）开发环境执行”int i,j ;”时，编译器将为其分配两块大小为 int型数据所占的内存空间，编译器自动的将其存放在空闲内存空间中。</p><h4 id="7-5-何为动态地址映射？有什么特点"><a href="#7-5-何为动态地址映射？有什么特点" class="headerlink" title="7.5 何为动态地址映射？有什么特点?"></a>7.5 何为动态地址映射？有什么特点?</h4><p>动态地址映射是指程序执行过程中把逻辑地址转换为物理地址。<br>将地址分为逻辑地址VA和基址BA，物理地址MA等于VA+BA，如果程序移动，根据移动后的BA自动计算MA，从而实现动态映射。<br>程序占用的内存空间可动态变化，不要求占用连续空间，便于多个进程共享，但需要内存管理单元的硬件支持，软件复杂。</p><h4 id="7-6-什么是分区存储管理？有哪些类型？"><a href="#7-6-什么是分区存储管理？有哪些类型？" class="headerlink" title="7.6 什么是分区存储管理？有哪些类型？"></a>7.6 什么是分区存储管理？有哪些类型？</h4><p>分区存储管理是指把用户区内存划分为若干大小不等的分区供不同程序使用，分为两种类型。<br>固定分区：把内存固定地划分为若干个大小不等的分区供各个程序使用，每个分区的大小和位置都固定，系统运行期间不再重新划分。<br>动态分区：在程序装入时创建分区，使分区大小刚好与程序的大小相等，分区动态建立，分区个数和大小可变，存在内存碎片。</p><h4 id="7-7-虚拟内存管理的目标是什么？"><a href="#7-7-虚拟内存管理的目标是什么？" class="headerlink" title="7.7 虚拟内存管理的目标是什么？"></a>7.7 虚拟内存管理的目标是什么？</h4><p>使大程序可以在小内存中运行；<br>使多个程序可以在小内存中运行；<br>使多个程序并发运行时地址不冲突；<br>使内存利用率高：无碎片，共享方便。</p><h4 id="7-8-使用虚拟存储管理功能的操作系统，还需不需要真是的内存？"><a href="#7-8-使用虚拟存储管理功能的操作系统，还需不需要真是的内存？" class="headerlink" title="7.8 使用虚拟存储管理功能的操作系统，还需不需要真是的内存？"></a>7.8 使用虚拟存储管理功能的操作系统，还需不需要真是的内存？</h4><p>虚拟内存技术，即匀出一部分硬盘空间来充当内存使用。当内存耗尽时，电脑就会自动调用硬盘来充当内存，以缓解内存的紧张。<br>而计算机并不能自己访问硬盘，只能访问内存或者Cache，虚拟内存技术将程序部分内容放到内存中。本质上还是储存在内存上被CPU使用。</p><h4 id="7-9-分区存储管理用在专用的，具有特定工作任务的，嵌入式系统中，可不可行？"><a href="#7-9-分区存储管理用在专用的，具有特定工作任务的，嵌入式系统中，可不可行？" class="headerlink" title="7.9 分区存储管理用在专用的，具有特定工作任务的，嵌入式系统中，可不可行？"></a>7.9 分区存储管理用在专用的，具有特定工作任务的，嵌入式系统中，可不可行？</h4><p>可以。如果嵌入式系统大多数时间执行单任务，那就适合不分区，简单，无需复杂硬件支持，也提高了内存利用率。</p><h4 id="7-10-何为放置策略？有哪些防止策略？各种防止策略的特点或优点是什么？"><a href="#7-10-何为放置策略？有哪些防止策略？各种防止策略的特点或优点是什么？" class="headerlink" title="7.10 何为放置策略？有哪些防止策略？各种防止策略的特点或优点是什么？"></a>7.10 何为放置策略？有哪些防止策略？各种防止策略的特点或优点是什么？</h4><p>放置策略是指空前区表排序原则。<br>最佳适应法将空闲区表按大小递增排序，优点是尽可能先使用较小空闲区，当需要较大分区时有较大的满足可能性。但在内存中留下许多难以利用的碎片。<br>最坏适应法将空闲区表按大小递减排序，优点是大空闲区分割后剩余部分还是很大，还能装下较大的分区，仅一次查找就可找到所有分区，不易产生碎片，对中小型文件分配分区操作有利。但造成存储器中缺乏大的空闲区，对大型文件的分区分配不利。<br>首次适应法将空闲区表按首址递增排序，尽可能先使用低地址空间，当需要较大分区时在高地址空间有较大的满足可能性，方法易于实现，但每次查找都从低址开始，增加查找开销。</p><h4 id="7-11-何为内存覆盖技术（Overlay）？有何缺点？"><a href="#7-11-何为内存覆盖技术（Overlay）？有何缺点？" class="headerlink" title="7.11 何为内存覆盖技术（Overlay）？有何缺点？"></a>7.11 何为内存覆盖技术（Overlay）？有何缺点？</h4><p>内存覆盖技术将内存分为多个区间，将程序的不同段按需取用，解决大程序在小内存中的运行问题。<br>缺点：<br>编程复杂，程序员划分程序模块并确定覆盖关系，模块过大无法运行；<br>程序执行时间长，程序从外存装入内存，涉及I/O操作耗时长。 </p><h4 id="7-12-何为内存交换技术（Swapping）？有何优缺点？"><a href="#7-12-何为内存交换技术（Swapping）？有何优缺点？" class="headerlink" title="7.12 何为内存交换技术（Swapping）？有何优缺点？"></a>7.12 何为内存交换技术（Swapping）？有何优缺点？</h4><p>内存交换技术是指当内存不够时将进程写到磁盘(称为换出过程)，当进程要运行时重新写回内存(称为换入过程)。<br>优点：增加程序并发数，不考虑程序结构。<br>缺点：换入和换出增加CPU开销，交换单位太大，为整个进程。</p><h4 id="7-13-内存交换技术在实现过程，为何要考虑地址重定位的问题？"><a href="#7-13-内存交换技术在实现过程，为何要考虑地址重定位的问题？" class="headerlink" title="7.13 内存交换技术在实现过程，为何要考虑地址重定位的问题？"></a>7.13 内存交换技术在实现过程，为何要考虑地址重定位的问题？</h4><p>因为旧模块取出后新模块换入前，原内存位置可能被其他程序占用，所以新模块换入要重新分配内存空间。</p><h4 id="7-14-内存在分配过程中产生碎片的本质是什么？有哪些方法可以消除或减轻碎片问题？"><a href="#7-14-内存在分配过程中产生碎片的本质是什么？有哪些方法可以消除或减轻碎片问题？" class="headerlink" title="7.14 内存在分配过程中产生碎片的本质是什么？有哪些方法可以消除或减轻碎片问题？"></a>7.14 内存在分配过程中产生碎片的本质是什么？有哪些方法可以消除或减轻碎片问题？</h4><p>产生碎片的本质是: 过小的空闲区满足不了程序所需内存, 而一直得不到利用, 形成了内存碎片。<br>解决办法:<br>规定门限值：分配空闲区时, 如果剩余部分小于门限值, 则将此空闲区整体分配给此程序。<br>内存拼接技术：将内存碎片(所有的空闲区)拼接成一个大的空闲区，但这种方法消耗系统资源。<br>让程序能够在不同内存分区进行运行：把程序分开装入不同的空闲区, 充分利用空闲区，避免造成碎片。</p><h4 id="7-15-何为程序运行的局部性？"><a href="#7-15-何为程序运行的局部性？" class="headerlink" title="7.15 何为程序运行的局部性？"></a>7.15 何为程序运行的局部性？</h4><p>程序在一个有限的时间段内访问的代码和数据往往集中在有限的地址范围内，把程序的一部分装入内存在较大概率上足够让其运行一小段时间。</p><h4 id="7-16-试述页式内存管理方案的概念，进程装入和使用内存的原则？"><a href="#7-16-试述页式内存管理方案的概念，进程装入和使用内存的原则？" class="headerlink" title="7.16 试述页式内存管理方案的概念，进程装入和使用内存的原则？"></a>7.16 试述页式内存管理方案的概念，进程装入和使用内存的原则？</h4><p>页式虚拟内存管理把进程空间和内存空间划分成等大小的小片，进程的小片称为页，内存的小片称为页框。<br>进程装入和使用内存的原则：只把程序部分页装入内存便可运行，页在内存中占用的页框不必相邻，需要新页时按需从硬盘中调入内存，不再运行的页及时删除。</p><h4 id="7-17-何为页表？描述利用页表完成页式地址映射的过程。"><a href="#7-17-何为页表？描述利用页表完成页式地址映射的过程。" class="headerlink" title="7.17 何为页表？描述利用页表完成页式地址映射的过程。"></a>7.17 何为页表？描述利用页表完成页式地址映射的过程。</h4><p>页表记录页与页框的对应关系（起索引作用）。<br>地址映射过程分为三步：从VA分离页号P和页内偏移W；查页表，以P为索引查页框号P’；计算物理地址MA，MA=P’×页大小+W。</p><h4 id="7-18-何为快表？描述有快表的情况下页式地址的映射过程。"><a href="#7-18-何为快表？描述有快表的情况下页式地址的映射过程。" class="headerlink" title="7.18 何为快表？描述有快表的情况下页式地址的映射过程。"></a>7.18 何为快表？描述有快表的情况下页式地址的映射过程。</h4><p>快表是指页表放在Cache中。<br><img src="/2020/03/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%83-%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/1.png" alt="页式地址的映射过程"></p><h4 id="7-19-在有快表的存储管理系统中，一条访存指令要访问到真正的数据，需要访问内存几次？"><a href="#7-19-在有快表的存储管理系统中，一条访存指令要访问到真正的数据，需要访问内存几次？" class="headerlink" title="7.19 在有快表的存储管理系统中，一条访存指令要访问到真正的数据，需要访问内存几次？"></a>7.19 在有快表的存储管理系统中，一条访存指令要访问到真正的数据，需要访问内存几次？</h4><p>一次或三次。<br>如果命中Cache中的快表的情况下，从Cache中得到地址，直接去内存取数据，只需访存一次。<br>如果没有命中，需要得到内存中页表的地址，从页表中得到物理地址，最后得到数据，共三次。</p><h4 id="7-20-试述页式存储管理系统的页面共享原理。"><a href="#7-20-试述页式存储管理系统的页面共享原理。" class="headerlink" title="7.20 试述页式存储管理系统的页面共享原理。"></a>7.20 试述页式存储管理系统的页面共享原理。</h4><p>在不同进程的页表中填上相同的页框号，多个进程能访问相同的内存空间，从而实现页面共享。共享页面在内存中只有一份真实存储，节省内存。</p><h4 id="7-21-试述缺页中断的概念和缺页中断响应的过程。"><a href="#7-21-试述缺页中断的概念和缺页中断响应的过程。" class="headerlink" title="7.21 试述缺页中断的概念和缺页中断响应的过程。"></a>7.21 试述缺页中断的概念和缺页中断响应的过程。</h4><p>在地址映射过程中，当要访问的目的页不在内存中时，则系统产生异常中断——缺页中断。<br>缺页中断处理程序把所缺的页从页表指出的外存地址调入内存的某个页框中，并更新页表中该页对应的页框号以及修改中断位I。</p><h4 id="7-22-页式虚拟内存管理是否适合实时操作系统采用？"><a href="#7-22-页式虚拟内存管理是否适合实时操作系统采用？" class="headerlink" title="7.22 页式虚拟内存管理是否适合实时操作系统采用？"></a>7.22 页式虚拟内存管理是否适合实时操作系统采用？</h4><p>不适合。<br>因为采用页式虚拟内存管理时，操作系统所需指令会储存在三种不同的存储介质中，访问时间大小关系：cache&lt;内存&lt;外存（硬盘）。<br>这样给每条指令或过程的完成时间添加了很大的不确定性，不符合“实时操作系统：每条指令或过程的完成时间是确定的或有上限”的要求。</p><h4 id="7-23-何为页面淘汰？页面淘汰的主要算法有哪些？"><a href="#7-23-何为页面淘汰？页面淘汰的主要算法有哪些？" class="headerlink" title="7.23 何为页面淘汰？页面淘汰的主要算法有哪些？"></a>7.23 何为页面淘汰？页面淘汰的主要算法有哪些？</h4><p>当发生缺页中断时，如果操作系统内存中没有空闲页面，则操作系统必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间，这一过程称为页面淘汰。而用来选择淘汰哪一页的规则叫做淘汰策略。<br>主要有以下几种淘汰策略：<br>最佳算法（OPT）：从主存中移出永远不再需要或最长时间不需要访问的页面，实践中无法实现。<br>先进先出淘汰算法（FIFO）：淘汰在内存中停留时间最长的页面，实现简单，对于一些特定的访问序列缺页率很高。<br>最近最久未使用淘汰算法（LRU）：淘汰最长时间未被使用的页面。<br>最不经常使用算法（LFU）：选择到当前时间被访问次数最少的页面。</p><h4 id="7-24-影响缺页的因素有哪些？"><a href="#7-24-影响缺页的因素有哪些？" class="headerlink" title="7.24 影响缺页的因素有哪些？"></a>7.24 影响缺页的因素有哪些？</h4><p>淘汰算法、分配给进程的页框数、页本身的大小、程序的编制方法。</p><h4 id="7-25-试述段页式存储管理的主要概念和地址映射过程。"><a href="#7-25-试述段页式存储管理的主要概念和地址映射过程。" class="headerlink" title="7.25 试述段页式存储管理的主要概念和地址映射过程。"></a>7.25 试述段页式存储管理的主要概念和地址映射过程。</h4><p>段页式存储管理是在段式存储管理中结合页式存储管理技术，在段中划分页面。<br>同时采用段表和页表实现地址映射。系统为每个进程建立一个段表； 系统为每个段建立一个页表； 段表给出每段的页表基地址及页表长度（段长）。页表给出每页对应的页框。逻辑地址：段号S、页号P和页内位移W。</p><h4 id="7-26-X86-CPU-架构下有哪三种地址？"><a href="#7-26-X86-CPU-架构下有哪三种地址？" class="headerlink" title="7.26 X86 CPU 架构下有哪三种地址？"></a>7.26 X86 CPU 架构下有哪三种地址？</h4><p>逻辑地址、线性地址、物理地址。<br>逻辑地址为汇编语言的段偏移，线性地址由逻辑地址转换得到。<br>逻辑地址到线性地址为段机制，线性地址到物理地址为分页机制。</p><h4 id="7-27-何为段描述符，其结构中主要包括哪些内容？"><a href="#7-27-何为段描述符，其结构中主要包括哪些内容？" class="headerlink" title="7.27 何为段描述符，其结构中主要包括哪些内容？"></a>7.27 何为段描述符，其结构中主要包括哪些内容？</h4><p>段描述符用于描述段的属性，8字节，包括段基址、段界限、段属性、段类型、访问该段最小特权级、是否在内存等信息。</p><h4 id="7-28-在何为选择子？选择子的结构是什么？选择子的作用是什么？"><a href="#7-28-在何为选择子？选择子的结构是什么？选择子的作用是什么？" class="headerlink" title="7.28 在何为选择子？选择子的结构是什么？选择子的作用是什么？"></a>7.28 在何为选择子？选择子的结构是什么？选择子的作用是什么？</h4><p>选择子用于选择GDT/LDT中的某个描述符，存放在段寄存器中。<br>高13位是整数索引，给出段描述符的位置；<br>下面1位是TI域，1表示LDT中，0表示GDT中；<br>下面2位是特权级别域，从0到3。</p><h4 id="7-29-逻辑地址如何通过选择子-描述符表转化为线性地址？"><a href="#7-29-逻辑地址如何通过选择子-描述符表转化为线性地址？" class="headerlink" title="7.29 逻辑地址如何通过选择子/描述符表转化为线性地址？"></a>7.29 逻辑地址如何通过选择子/描述符表转化为线性地址？</h4><p>根据选择子在GDT/LDT表中找到对应描述符，然后根据偏移地址得出线性地址。</p><figure class="image-box">                <img src="/2020/03/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%83-%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/3.png" alt="偏移地址-线性地址" title class>                <p>偏移地址-线性地址</p>            </figure><h4 id="7-30-Windows和Linux为何不用普通页表，而要用二级或三级页表结构？（即如果直接使用普通页表会有哪些问题？）"><a href="#7-30-Windows和Linux为何不用普通页表，而要用二级或三级页表结构？（即如果直接使用普通页表会有哪些问题？）" class="headerlink" title="7.30 Windows和Linux为何不用普通页表，而要用二级或三级页表结构？（即如果直接使用普通页表会有哪些问题？）"></a>7.30 Windows和Linux为何不用普通页表，而要用二级或三级页表结构？（即如果直接使用普通页表会有哪些问题？）</h4><p>对于大容量内存，直接使用普通页表，会占很大内存。例如4G空间，每页4K，页表每个记录占4字节，共需要4M内存储存页表，难以找到连续1K个页框存放页表。</p><h4 id="7-31-Linux本质上采用的是二级页表结构。为何它在形式上要采用三级页表结构？"><a href="#7-31-Linux本质上采用的是二级页表结构。为何它在形式上要采用三级页表结构？" class="headerlink" title="7.31 Linux本质上采用的是二级页表结构。为何它在形式上要采用三级页表结构？"></a>7.31 Linux本质上采用的是二级页表结构。为何它在形式上要采用三级页表结构？</h4><p>增加Linux对硬件的适应性。</p><h4 id="7-32-Linux中段机制的作用什么？"><a href="#7-32-Linux中段机制的作用什么？" class="headerlink" title="7.32 Linux中段机制的作用什么？"></a>7.32 Linux中段机制的作用什么？</h4><p>利用段机制隔离用户数据和系统数据；<br>避免逻辑地址到线性地址的转换。</p><h4 id="7-33-Linux内存管理的基本框架和典型算法。"><a href="#7-33-Linux内存管理的基本框架和典型算法。" class="headerlink" title="7.33 Linux内存管理的基本框架和典型算法。"></a>7.33 Linux内存管理的基本框架和典型算法。</h4><p><a href="https://www.cnblogs.com/ralap7/p/9184773.html" target="_blank" rel="noopener">https://www.cnblogs.com/ralap7/p/9184773.html</a></p><h4 id="7-34-了解“页式虚拟内存管理”的实时性？"><a href="#7-34-了解“页式虚拟内存管理”的实时性？" class="headerlink" title="7.34 了解“页式虚拟内存管理”的实时性？"></a>7.34 了解“页式虚拟内存管理”的实时性？</h4><p><a href="https://blog.csdn.net/lxc19861120/article/details/8449981" target="_blank" rel="noopener">https://blog.csdn.net/lxc19861120/article/details/8449981</a></p><h4 id="7-35-了解关于Intel-CPU的保护模式的概念，了解段描述符，描述符特权级（DPL），请求特权级-RPL-等概念。"><a href="#7-35-了解关于Intel-CPU的保护模式的概念，了解段描述符，描述符特权级（DPL），请求特权级-RPL-等概念。" class="headerlink" title="7.35 了解关于Intel CPU的保护模式的概念，了解段描述符，描述符特权级（DPL），请求特权级(RPL)等概念。"></a>7.35 了解关于Intel CPU的保护模式的概念，了解段描述符，描述符特权级（DPL），请求特权级(RPL)等概念。</h4><p><a href="https://blog.csdn.net/chuanwang66/article/details/84410042" target="_blank" rel="noopener">https://blog.csdn.net/chuanwang66/article/details/84410042</a></p><h4 id="7-36-Linux段机制的实现过程。"><a href="#7-36-Linux段机制的实现过程。" class="headerlink" title="7.36 Linux段机制的实现过程。"></a>7.36 Linux段机制的实现过程。</h4><p><a href="https://blog.csdn.net/hzrandd/article/details/50898817?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">https://blog.csdn.net/hzrandd/article/details/50898817?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task</a></p><h4 id="7-37-Linux是如何解析ELF文件并加载其中内容到内存中的？"><a href="#7-37-Linux是如何解析ELF文件并加载其中内容到内存中的？" class="headerlink" title="7.37 Linux是如何解析ELF文件并加载其中内容到内存中的？"></a>7.37 Linux是如何解析ELF文件并加载其中内容到内存中的？</h4><p><a href="https://blog.csdn.net/gatieme/article/details/51628257?utm_source=blogxgwz1" target="_blank" rel="noopener">https://blog.csdn.net/gatieme/article/details/51628257?utm_source=blogxgwz1</a></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理学习笔记六-自下而上的语法分析</title>
      <link href="/2020/03/25/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AD-%E8%87%AA%E4%B8%8B%E8%80%8C%E4%B8%8A%E7%9A%84%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/"/>
      <url>/2020/03/25/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AD-%E8%87%AA%E4%B8%8B%E8%80%8C%E4%B8%8A%E7%9A%84%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="第六章-自下而上的语法分析"><a href="#第六章-自下而上的语法分析" class="headerlink" title="第六章 自下而上的语法分析"></a>第六章 自下而上的语法分析</h1><h4 id="自下而上"><a href="#自下而上" class="headerlink" title="自下而上"></a>自下而上</h4><p>从输入串开始，逐步进行归约，直到文法的开始符号。<br>归约：根据文法的产生式规则，把串中出现的产生式的右部替换成左部符号。<br>从树叶节点开始，构造语法树。<br>算符优先分析法、LR分析法。  </p><h3 id="第一部分：算符优先文法"><a href="#第一部分：算符优先文法" class="headerlink" title="第一部分：算符优先文法"></a>第一部分：算符优先文法</h3><h4 id="1-自下而上分析的基本思想-“移进－归约”"><a href="#1-自下而上分析的基本思想-“移进－归约”" class="headerlink" title="1 自下而上分析的基本思想-“移进－归约”"></a>1 自下而上分析的基本思想-“移进－归约”</h4><p>用一个寄存符号的先进后出栈，把输入符号一个一个地移进到栈里，当栈顶形成某个产生式的候选式时，即把栈顶的这一部分替换成(归约为)该产生式的左部符号。</p><h4 id="2-短语和直接短语"><a href="#2-短语和直接短语" class="headerlink" title="2 短语和直接短语"></a>2 短语和直接短语</h4><p>以某非终结符为根的两代以上的子树的所有末端结点从左到右排列就是相对于该非终结符的一个短语；<br>如果子树只有两代，则该短语就是直接短语。</p><h4 id="3-算符文法"><a href="#3-算符文法" class="headerlink" title="3 算符文法"></a>3 算符文法</h4><p>一个文法，如果它的任一产生式的右部都不含两个相继(并列)的非终结符，即不含…QR…形式的产生式右部，则我们称该文法为算符文法。</p><h4 id="4-算符优先文法的概念"><a href="#4-算符优先文法的概念" class="headerlink" title="4 算符优先文法的概念"></a>4 算符优先文法的概念</h4><p>假定G是一个不含𝜀-产生式的算符文法。对于任何一对终结符a、b，我们说：  </p><ol><li>a的优先级等于b，当且仅当文法G中含有形如P→…ab…或P→…aQb…的产生式；  </li><li>a的优先级小于b，当且仅当G中含有形如P→…aR…的产生式， 而R⇒b…或R⇒Qb…；  </li><li>a的优先级大于b，当且仅当G中含有形如P→…Rb…的产生式，而 R⇒…a或R⇒…aQ。  </li></ol><p>如果一个算符文法G中的任何终结符对(a，b)至多只满足a的优先级大于b、a的优先级等于b和 a的优先级小于b这三个关系之一，则称G是一个算符优先文法。</p><p>例子：<br>文法G(E)：<br>(1)  E→E+T | T<br>(2)  T→T*F | F<br>(3)  F→P ↑ F | P<br>(4)  P→(E) | i<br>的优先关系表:  </p><p><img src="/2020/03/25/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AD-%E8%87%AA%E4%B8%8B%E8%80%8C%E4%B8%8A%E7%9A%84%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/1.png" alt="优先关系表"></p><h4 id="5-FIRSTVT和LASTVT集合"><a href="#5-FIRSTVT和LASTVT集合" class="headerlink" title="5 FIRSTVT和LASTVT集合"></a>5 FIRSTVT和LASTVT集合</h4><p>FIRSTVT集合：FIRSTVT(P) = {𝑎 | P ⇒ 𝑎… 或 P ⇒ Q𝑎…， 𝑎 ∈ V<sub>T</sub>且Q ∈ V<sub>N</sub> }<br>LASTVT集合：LASTVT(P) = {𝑎 | P ⇒ …𝑎 或 P ⇒ …𝑎Q， 𝑎 ∈ V<sub>T</sub>且Q ∈ V<sub>N</sub> }</p><p>假定有个产生式的一个候选形为…aP…， 那么，对任何b∈FIRSTVT(P)，有 a的优先级小于b<br>假定有个产生式的一个候选形为…Pb…， 那么，对任何a∈LASTVT(P)，有 a的优先级大于b   </p><h4 id="6-构造集合FIRSTVT-P-和LASTVT-P-的算法"><a href="#6-构造集合FIRSTVT-P-和LASTVT-P-的算法" class="headerlink" title="6 构造集合FIRSTVT(P)和LASTVT(P)的算法"></a>6 构造集合FIRSTVT(P)和LASTVT(P)的算法</h4><p>FIRSTVT(P)：  </p><ol><li>若有产生式P→a…或P→Qa…，则a∈FIRSTVT(P)</li><li>若a∈FIRSTVT(Q)，且有产生式P→Q…，则a∈FIRSTVT(P)  </li></ol><p>LASTVT(P)：  </p><ol><li>若有产生式P→… a或P→ … aQ，则 a∈LASTVT(P)</li><li>若a∈LASTVT(Q)，且有产生式P→… Q，则a∈LASTVT(P)  </li></ol><p>例子：<br>考虑下面的文法G(E)：<br>   (1)  E→E+T | T<br>   (2)  T→T*F | F<br>   (3)  F→P ↑ F | P<br>   (4)  P→(E) | i  </p><p>FIRSTVT(E)={ +, *, ↑, (, i }<br>FIRSTVT(T)={ *, ↑, (, i }<br>FIRSTVT(F)={ ↑, (, i }<br>FIRSTVT(P)={ (, i }  </p><p>LASTVT(E)={ +, *, ↑, ), i }<br>LASTVT(T)={ *, ↑, ), i }<br>LASTVT(F)={ ↑, ), i }<br>LASTVT(P)={ ), i }  </p><h4 id="7-构造优先关系表的算法"><a href="#7-构造优先关系表的算法" class="headerlink" title="7 构造优先关系表的算法"></a>7 构造优先关系表的算法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">FOR  每条产生式P→X1X2…Xn  DO</span><br><span class="line">  FOR  i:&#x3D;1  TO  n-1 DO</span><br><span class="line">    BEGIN</span><br><span class="line">        IF  Xi和Xi+1均为终结符  THEN  置Xi的优先级等于Xi+1</span><br><span class="line">        IF  i≤n-2且Xi和Xi+2都为终结符, 但Xi+1为非终结符  THEN  </span><br><span class="line">            置Xi的优先级等于Xi+2；</span><br><span class="line">        IF  Xi为终结符而Xi+1为非终结符  THEN</span><br><span class="line">            FOR  FIRSTVT(Xi+1)中的每个a  DO</span><br><span class="line">                置 Xi的优先级小于a；</span><br><span class="line">        IF  Xi为非终结符而Xi+1为终结符  THEN</span><br><span class="line">            FOR  LASTVT(Xi)中的每个a   DO</span><br><span class="line">                置  a的优先级大于Xi+1</span><br><span class="line">    END</span><br></pre></td></tr></table></figure><h4 id="8-最左素短语"><a href="#8-最左素短语" class="headerlink" title="8 最左素短语"></a>8 最左素短语</h4><p>一个文法G的句型的素短语是指这样一个短语，它至少含有一个终结符，并且，除它自身之外不再含任何更小的素短语。<br>最左素短语是指处于句型最左边的那个素短语。</p><h4 id="9-最左素短语定理"><a href="#9-最左素短语定理" class="headerlink" title="9 最左素短语定理"></a>9 最左素短语定理</h4><p>算符优先文法句型(括在两个＃之间)的一般形式：<br>  #N1a1N2a2…NnanNn+1#<br>其中，ai都是终结符，Ni是可有可无的非终结符。<br>定理：一个算符优先文法G的任何句型的最左素短语是满足如下条件的最左子串 Njaj…NiaiNi+1，<br>aj-1的优先级小于aj<br>aj的优先级等于 aj+1，…，ai-1的优先级等于ai<br>ai的优先级大于ai+1</p><h4 id="10-算符优先分析算法"><a href="#10-算符优先分析算法" class="headerlink" title="10 算符优先分析算法"></a>10 算符优先分析算法</h4><p>使用一个符号栈S，用它寄存终结符和非终结符，k代表符号栈S的使用深度。<br>在正确的情况下，算法工作完毕时，符号栈S应呈现：# N #  。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">k:&#x3D;1;</span><br><span class="line">S[k]:&#x3D;‘#’;</span><br><span class="line">REPEAT</span><br><span class="line">把下一个输入符号读进a中；</span><br><span class="line">IF S[k]∈VT THEN  j:&#x3D;k  ELSE  j:&#x3D;k-1;</span><br><span class="line">WHILE S[j]的优先级大于a DO</span><br><span class="line">BEGIN</span><br><span class="line">   REPEAT</span><br><span class="line">         Q:&#x3D;S[j];</span><br><span class="line">IF S[j-1]∈VT THEN j:&#x3D;j-1 </span><br><span class="line">ELSE j:&#x3D;j-2</span><br><span class="line">     UNTIL S[j]的优先级小于Q;</span><br><span class="line">   把S[j+1]…S[k]归约为某个N；</span><br><span class="line">   k:&#x3D;j+1;</span><br><span class="line">   S[k]:&#x3D;N</span><br><span class="line">END OF WHILE;</span><br><span class="line">IF S[j]的优先级小于a OR S[j]的优先级等于a THEN</span><br><span class="line">BEGIN k:&#x3D;k+1;S[k]:&#x3D;a END</span><br><span class="line">ELSE ERROR &#x2F;*调用出错诊察程序*&#x2F;</span><br><span class="line">UNTIL a&#x3D;‘#’</span><br></pre></td></tr></table></figure><p>算符优先分析结果不一定是语法树。</p><h4 id="11-算符优先分析程序构成"><a href="#11-算符优先分析程序构成" class="headerlink" title="11 算符优先分析程序构成"></a>11 算符优先分析程序构成</h4><p>总控程序，根据现行栈顶符号和当前输入符号，执行动作；<br>优先关系表，用于指导总控程序进行移进-归约；<br>分析栈 STACK，用于存放文法符号。  </p><p>特点：<br>优点: 简单，快速；<br>缺点: 可能错误接受非法句子。<br>使用广泛，用于分析各类表达式，ALGOL 60。</p><h3 id="第二部分：LR分析法"><a href="#第二部分：LR分析法" class="headerlink" title="第二部分：LR分析法"></a>第二部分：LR分析法</h3><p>L：从左到右扫描输入串；<br>R：自下而上进行归约。</p><h4 id="12-句柄"><a href="#12-句柄" class="headerlink" title="12 句柄"></a>12 句柄</h4><p>一个句型的最左直接短语称为该句型的句柄。<br>可用句柄来对句子进行归约。</p><h4 id="13-规范归约与规范句型"><a href="#13-规范归约与规范句型" class="headerlink" title="13 规范归约与规范句型"></a>13 规范归约与规范句型</h4><p>定义：假定α是文法G的一个句子，我们称序列 αn， αn-1，… ，α0  是α的一个规范归约，如果此序列满足：  </p><ol><li>αn= α</li><li>α0为文法的开始符号，即α0=S</li><li>对任何i，0 ≤ i ≤ n， αi-1是从αi经把句柄替换成为相应产生式左部符号而得到的</li></ol><p>算符优先分析一般并不等价于规范归约。</p><p>规范归约是最左归约，规范归约的逆过程就是最右推导。<br>S ⇒ aAcBe ⇒ aAcde ⇒ aAbcde ⇒ abbcde<br>最右推导也称为规范推导，由规范推导推出的句型称为规范句型。</p><p>规范归约的关键问题是寻找句柄。</p><h4 id="14-LR分析"><a href="#14-LR分析" class="headerlink" title="14 LR分析"></a>14 LR分析</h4><figure class="image-box">                <img src="/2020/03/25/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AD-%E8%87%AA%E4%B8%8B%E8%80%8C%E4%B8%8A%E7%9A%84%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/2.png" alt="LR分析器的结构" title class>                <p>LR分析器的结构</p>            </figure><p>历史：已移入符号栈的内容；<br>展望：根据产生式推测未来可能遇到的输入符号；<br>现实：当前的输入符号。<br>LR分析方法是把”历史”及”展望”综合抽象成状态，由栈顶的状态和现行的输入符号唯一确定每一步工作。</p><p>LR分析器的核心是一张分析表：<br>ACTION[s，a]：当状态s面临输入符号a时，应采取什么动作；<br>GOTO[s，X]：状态s面对文法符号X时，下一状态是什么。</p><p>例子：<br>根据文法G(E)：<br>(1) E→E＋T<br>(2) E→T<br>(3) T→T*F<br>(4) T→F<br>(5) F→(E)<br>(6) F→I<br>分析输入串i*i+i。<br><img src="/2020/03/25/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AD-%E8%87%AA%E4%B8%8B%E8%80%8C%E4%B8%8A%E7%9A%84%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/3.png" alt="LR分析例子"></p><p>表中s表示移进(shift)：把(s，a)的下一状态s’和输入符号a推进栈，下一输入符号变成现行输入符号；<br>表中r表示归约(reduce)：用某产生式A→β进行归约。  假若β的长度为r， 去除栈顶r个项，使状态sm-r变成栈顶状态，然后把下一状态s’=GOTO[sm-r, A]和文法符号A推进栈；<br>表中acc表示接受：宣布分析成功，停止分析器工作；<br>表中空白表示错误。</p><h4 id="15-LR文法"><a href="#15-LR文法" class="headerlink" title="15 LR文法"></a>15 LR文法</h4><p>对于一个文法，如果能够构造一张分析表，使得它的每个入口均是唯一确定的，则这个文法就称为LR文法。<br>定义：一个文法，如果能用一个每步顶多向前检查k个输入符号的LR分析器进行分析，则这个文法就称为LR(k)文法。  </p><p>LR文法不是二义的，二义文法肯定不会是LR的；<br>LR文法 ⊂ 无二义文法。</p><h3 id="第三部分：-LR-0-分析表的构造"><a href="#第三部分：-LR-0-分析表的构造" class="headerlink" title="第三部分： LR(0)分析表的构造"></a>第三部分： LR(0)分析表的构造</h3><h4 id="16-字的前缀、活前缀"><a href="#16-字的前缀、活前缀" class="headerlink" title="16 字的前缀、活前缀"></a>16 字的前缀、活前缀</h4><p>字的前缀：是指字的任意首部，如字abc的前缀有𝜀，a，ab，abc。<br>活前缀：是指规范句型的一个前缀，这种前缀不含句柄之后的任何符号。即，对于规范句型αβδ，β为句柄，如果αβ=u1u2…ur，则符号串u1u2…ui(1≤i≤r)是αβδ的活前缀。(δ必为终结符串)。<br>规范归约过程中，保证分析栈中总是活前缀，就说明分析采取的移进/归约动作是正确的。</p><h4 id="17-构造识别活前缀的DFA"><a href="#17-构造识别活前缀的DFA" class="headerlink" title="17 构造识别活前缀的DFA"></a>17 构造识别活前缀的DFA</h4><p>将文法G(S)拓广为G’(S’)：<br>构造文法G’，它包含了整个G，并引进不出现在G中的非终结符S’、以及产生式S’→S，S’是G’的开始符号。称G’是G的拓广文法。  </p><p>LR(0)项目：<br>在每个产生式的右部添加一个圆点，表示我们在分析过程中看到了产生式多大部分。<br>A → XYZ有四个项目：A → •XYZ，A → X•YZ，A → XY•Z，A → XYZ• 。<br>A → α• 称为”归约项目”。<br>归约项目 S’→ α • 称为”接受项目”。<br>A → α•aβ (a∈VT)  称为”移进项目”。<br>A → α•Bβ (B∈VN) 称为”待约项目”。  </p><p>构造识别文法所有活前缀的NFA：<br>若状态i为X → X1 … Xi-1•Xi … Xn，状态j为X → X1 … Xi-1Xi•Xi+1 … Xn，则从状态i画一条标志为Xi的有向边到状态j；<br>若状态i为X → α•Aβ，A为非终结符，则从状态i画一条𝜀边到所有状态A → •γ。  </p><p>例子：<br>文法G(S’)<br>S’→E<br>E→aA|bB<br>A→cA|d<br>B→cB|d   </p><p><img src="/2020/03/25/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AD-%E8%87%AA%E4%B8%8B%E8%80%8C%E4%B8%8A%E7%9A%84%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/4.png" alt="识别文法所有活前缀的DFA">  </p><p>构成识别一个文法活前缀的DFA的项目集(状态)的全体称为文法的LR(0)项目集规范族。</p><h4 id="18-通过计算项目集规范族构造识别活前缀的DFA"><a href="#18-通过计算项目集规范族构造识别活前缀的DFA" class="headerlink" title="18 通过计算项目集规范族构造识别活前缀的DFA"></a>18 通过计算项目集规范族构造识别活前缀的DFA</h4><p>有效项目：<br>项目A → β1•β2对活前缀αβ1是有效的，其条件是存在规范推导S’⇒<sub>R</sub>𝛼𝐴𝜔⇒<sub>R</sub>𝛼𝛽1𝛽2𝜔。<br>在任何时候，分析栈中的活前缀X1X2 … Xm的有效项目集正是从识别活前缀的DFA的初态出发，读出X1X2 … Xm后到达的那个项目集(状态)。<br>若项目A → α•Bβ对活前缀η=δα是有效的且 B → γ 是一个产生式，则项目B → •γ 对η=δα 也是有效的。  </p><p>状态转换函数：<br>为了识别活前缀，我们定义一个状态转换函数GO是一个状态转换函数。I是一个项目集，X是一个文法符号。函数值GO(I，X)定义为：GO(I，X)＝CLOSURE(J)。其中J＝{任何形如A→αX•β的项目| A→α•Xβ属于I}。直观上说，若I是对某个活前缀 γ  有效的项目集，那么，GO(I，X)便是对 γX 有效的项目集。  </p><p>项目集的转移函数计算：<br>项目集I的闭包CLOSURE(I)：</p><ol><li>I的任何项目都属于CLOSURE(I)；  </li><li>若A→αB•β属于CLOSURE(I)，那么，对任何关于A的产生式B→γ，项目B→•γ也属于CLOSURE(I)；  </li><li>重复执行上述两步骤直至CLOSURE(I) 不再增大为止。  </li></ol><p>两种构造识别活前缀的DFA的方法：<br>项目 → NFA → DFA<br>Closure → GO → DFA  </p><h4 id="19-LR-0-分析表的构造"><a href="#19-LR-0-分析表的构造" class="headerlink" title="19 LR(0)分析表的构造"></a>19 LR(0)分析表的构造</h4><p>假若一个文法G的拓广文法G’的活前缀识别自动机中的每个状态(项目集)不存在下述情况：<br>既含移进项目又含归约项目、含有多个归约项目，则称G是一个LR(0)文法。  </p><p>令每个项目集Ik的下标k作为分析器的状态，包含项目S’→•S的集合Ik的下标k为分析器的初态。<br>构造LR(0)分析表的ACTION和GOTO子表。  </p><ol><li>若项目A→α•aβ属于Ik且GO(Ik, a)＝Ij，a为终结符，则置ACTION[k, a] 为“sj”。</li><li>若项目A→α•属于Ik，那么，对任何终结符a(或结束符#)，置ACTION[k, a]为 “rj”(假定产生式A→α是文法G’的第j个产生式)。</li><li>若项目S’→S•属于Ik，则置ACTION[k,#]为“acc”。</li><li>若GO(Ik, A)＝Ij，A为非终结符，则置GOTO[k, A]=j。</li><li>分析表中凡不能用规则1至4填入信息的空白格均置上“报错标志”。</li></ol><h3 id="第四部分：-SLR-1-和LR-1"><a href="#第四部分：-SLR-1-和LR-1" class="headerlink" title="第四部分： SLR(1)和LR(1)"></a>第四部分： SLR(1)和LR(1)</h3><h4 id="20-SLR-1-冲突解决办法"><a href="#20-SLR-1-冲突解决办法" class="headerlink" title="20 SLR(1)冲突解决办法"></a>20 SLR(1)冲突解决办法</h4><p>含有“移进－归约”冲突，导致LR(0)失效。  </p><p>假定LR(0)规范族的一个项目集I={A1→α•a1β1，A2→α•a2β2，…，Am→α•amβm，B1→α•，B2→α•，…，Bn→α• } 如果集合{a1，…，am}，FOLLOW(B1)，…，FOLLOW(Bn)两两不相交(包括不得有两个FOLLOW集合有#)，则当状态I面临任何输入符号a时：  </p><ol><li>若a是某个ai，i=1,2,…,m，则移进；  </li><li>若a∈FOLLOW(Bi)，i=1,2,…,n，则用产生式Bi→α进行归约；  </li><li>此外，报错。  </li></ol><p>SLR(1)解决办法：最多向前看一个单词。</p><h4 id="21-SLR-1-分析表的构造"><a href="#21-SLR-1-分析表的构造" class="headerlink" title="21 SLR(1)分析表的构造"></a>21 SLR(1)分析表的构造</h4><p>与LR(0)的分析表的构造步骤仅第二步不同：<br>若项目A→α•属于Ik，那么，对任何终结符a∈FOLLOW(A)，置ACTION[k,a]为 “rj”；其中，假定A→α为文法G’的第j个产生式。</p><p>例子：<br>拓广文法G(S’)：<br>(0) S’→E<br>(1) E→E+T<br>(2) E→T<br>(3) T→T*F<br>(4) T→F<br>(5) F→(E)<br>(6) F→i      </p><p><img src="/2020/03/25/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AD-%E8%87%AA%E4%B8%8B%E8%80%8C%E4%B8%8A%E7%9A%84%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/5.png" alt="LR(0)活前缀的DFA"><br><img src="/2020/03/25/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AD-%E8%87%AA%E4%B8%8B%E8%80%8C%E4%B8%8A%E7%9A%84%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/6.png" alt="LR(0)项目集规范族">  </p><p>I1、I2和I9都含有“移进－归约”冲突，FOLLOW(S’)＝{ # }，FOLLOW(E)＝{ +, ), # }，FOLLOW(T)＝{ +, *, ), # }，FOLLOW(F)＝{ +, *, ), # }。  </p><p><img src="/2020/03/25/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AD-%E8%87%AA%E4%B8%8B%E8%80%8C%E4%B8%8A%E7%9A%84%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/7.png" alt="SLR(1)分析表">  </p><h4 id="22-SLR-1-冲突消解存在的问题"><a href="#22-SLR-1-冲突消解存在的问题" class="headerlink" title="22 SLR(1)冲突消解存在的问题"></a>22 SLR(1)冲突消解存在的问题</h4><p>SLR在方法中，如果项目集Ii含项目A → α• 而且下一输入符号a∈FOLLOW(A)，则状态i面临a时，可选用“用A → α归约”动作。<br>但在有些情况下，当状态i显现于栈顶时，当前单词是a，栈里的活前缀βα未必允许把α归约为A，因为可能根本就不存在一个形如“βAa”的规范句型。在这种情况下，用“A → α”归约不一定合适。<br>这是因为FOLLOW集合提供的信息太泛。</p><h4 id="23-LR-k-项目"><a href="#23-LR-k-项目" class="headerlink" title="23 LR(k)项目"></a>23 LR(k)项目</h4><p>LR(k)项目：扩展LR(0)项目，附带有k个终结符[A→α•β, a1a2…ak]，a1a2…ak 称为向前搜索符串(或展望串)。<br>归约项目[A→α•，a1a2…ak]的意义：当它所属的状态呈现在栈顶且后续的k个输入符号为 a1a2…ak 时，才可以把栈顶上的α归约为A。<br>对于任何移进或待约项目[A→α•β, a1a2…ak], β≠𝜀，搜索符串 a1a2…ak 没有直接作用。</p><h4 id="24-LR-1-分析表"><a href="#24-LR-1-分析表" class="headerlink" title="24 LR(1)分析表"></a>24 LR(1)分析表</h4><p>与LR(0)和SLR(1)的分析表的构造步骤仅第二步不同：<br>若项目[A→α•，a]属于Ik，则置ACTION[k, a]为 “rj”；其中假定A→α为文法G’的第j个产生式。</p><p>按上述算法构造的分析表，若不存在多重定义的入口(即，动作冲突)的情形，则称它是文法G的一张规范的LR(1)分析表。<br>具有规范的LR(1)分析表的文法称为一个LR(1)文法。<br>使用LR(1)分析表的分析器叫做一个规范的LR分析器。<br>LR(0) ⊂ SLR(1) ⊂ LR(1) ⊂ 无二义文法</p>]]></content>
      
      
      <categories>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统课程学习笔记六-进程调度</title>
      <link href="/2020/03/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AD-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/"/>
      <url>/2020/03/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AD-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="第六章-进程调度"><a href="#第六章-进程调度" class="headerlink" title="第六章 进程调度"></a>第六章 进程调度</h1><h4 id="6-1-进程调度的目标有哪些？"><a href="#6-1-进程调度的目标有哪些？" class="headerlink" title="6.1 进程调度的目标有哪些？"></a>6.1 进程调度的目标有哪些？</h4><p>响应速度尽可能快；<br>进程处理的时间尽可能短；<br>系统吞吐量尽可能大；<br>资源利用率尽可能高；<br>对所有进程要公平；<br>避免饥饿；<br>避免死锁。</p><h4 id="6-2-进程调度的7个目标中，你觉得windows或Linux重点在于满足哪些目标？为什么这么认为？"><a href="#6-2-进程调度的7个目标中，你觉得windows或Linux重点在于满足哪些目标？为什么这么认为？" class="headerlink" title="6.2 进程调度的7个目标中，你觉得windows或Linux重点在于满足哪些目标？为什么这么认为？"></a>6.2 进程调度的7个目标中，你觉得windows或Linux重点在于满足哪些目标？为什么这么认为？</h4><p>个人觉得与操作系统是linux还是windows关系不大，每种操作系统都有不同的版本用于不同的需求，如果偏向服务器会要求系统吞吐量、资源利用率高，如果偏向家庭办公的多任务交互场景会要求响应快、避免饥饿。windows有家庭版、工作站版等版本，linux也有很多版本，甚至可以自己修改内核。</p><h4 id="6-3-什么是周转时间，什么是带权周转时间？"><a href="#6-3-什么是周转时间，什么是带权周转时间？" class="headerlink" title="6.3 什么是周转时间，什么是带权周转时间？"></a>6.3 什么是周转时间，什么是带权周转时间？</h4><p>周转时间是指进程提交给计算机到最终用完成所花费的时间，说明了进程在系统中停留时间的长短。<br>带权周转时间是指进程的周转时间与运行时间的比值，说明了进程在系统的相对停留时间。</p><h4 id="6-4-什么是响应比？响应比高者优先调度算法有什么特点？"><a href="#6-4-什么是响应比？响应比高者优先调度算法有什么特点？" class="headerlink" title="6.4 什么是响应比？响应比高者优先调度算法有什么特点？"></a>6.4 什么是响应比？响应比高者优先调度算法有什么特点？</h4><p>响应比是指作业的响应时间与运行时间的比值，响应时间为等待时间加运行时间。<br>相同等待时间，运行时间越短的作业响应比越高；相同作业时间，等待时间越长的作业响应比越高。<br>响应比高者优先调度算法有利于短作业和等候长的作业。</p><h4 id="6-5-试述优先数调度的算法概念？何为静态优先数，何为动态优先数？"><a href="#6-5-试述优先数调度的算法概念？何为静态优先数，何为动态优先数？" class="headerlink" title="6.5 试述优先数调度的算法概念？何为静态优先数，何为动态优先数？"></a>6.5 试述优先数调度的算法概念？何为静态优先数，何为动态优先数？</h4><p>优先数调度算法根据进程的优先数，把CPU分配给最高的进程。<br>进程优先数等于静态优先数加动态优先数。<br>静态优先数在创建进程时确定，基于进程所需的资源多少、运行时间长短、进程类型(IO/CPU、前台/后台、核心/用户)。<br>动态优先数在进程运行期间可以改变，基于使用CPU时长、I/O操作、等待时长。</p><h4 id="6-6-静态优先数如何确定的？譬如：进程所需的资源多（或少），就分配较小（或较多）的静态优先数？"><a href="#6-6-静态优先数如何确定的？譬如：进程所需的资源多（或少），就分配较小（或较多）的静态优先数？" class="headerlink" title="6.6 静态优先数如何确定的？譬如：进程所需的资源多（或少），就分配较小（或较多）的静态优先数？"></a>6.6 静态优先数如何确定的？譬如：进程所需的资源多（或少），就分配较小（或较多）的静态优先数？</h4><p>1、进程所需的资源多，就分配较小的静态优先数，降低优先级，降低进程占用CPU时间；<br>2、基于程序运行时间的短，分配较多静态优先数，提高优先级，优先使用CPU；<br>3、进程的类型[IO/CPU,前台/后台,核心/用户]，核心进程分配较多优先数优先运行，用户进程分配优先数少排队运行。</p><h4 id="6-7-动态优先数如何确定的？譬如：当使用CPU超过一定时长时，就减少（或增加）的动态优先数？"><a href="#6-7-动态优先数如何确定的？譬如：当使用CPU超过一定时长时，就减少（或增加）的动态优先数？" class="headerlink" title="6.7 动态优先数如何确定的？譬如：当使用CPU超过一定时长时，就减少（或增加）的动态优先数？"></a>6.7 动态优先数如何确定的？譬如：当使用CPU超过一定时长时，就减少（或增加）的动态优先数？</h4><p>与静态优先数的理念相同，本质上都是在基于进程类型分配优先级，额外处理了静态优先级可能存在的饥饿现象。<br>1、当使用CPU超过一定时长时，就减少的动态优先数，降低进程优先级，目的是保证不阻碍其他IO任务的处理；<br>2、当进行I/O操作后，就增加的动态优先数，主观上认为这个进程可能与IO操作有关，日后大概率还会需要IO操作提高进程优先级进程I/O操作；<br>3、当进程等待超过一定时长时，就增加的动态优先数，处理了可能出现的饥饿现象。</p><h4 id="6-8-试述循环轮转调度的概念和其优点。"><a href="#6-8-试述循环轮转调度的概念和其优点。" class="headerlink" title="6.8 试述循环轮转调度的概念和其优点。"></a>6.8 试述循环轮转调度的概念和其优点。</h4><p>循环轮转调度是指把所有就绪进程按先进先出的原则排成队列，所有进程按时间片为单位轮流使用CPU，运行过但没结束的进程排队到队列末尾，等候下一轮运行。<br>该调度方式保证了进程调度的公平性和交互性。</p><h4 id="6-9-Linux创建子进程时，其COUNTER值为什么只继承父进程的一半，原因何在？"><a href="#6-9-Linux创建子进程时，其COUNTER值为什么只继承父进程的一半，原因何在？" class="headerlink" title="6.9 Linux创建子进程时，其COUNTER值为什么只继承父进程的一半，原因何在？"></a>6.9 Linux创建子进程时，其COUNTER值为什么只继承父进程的一半，原因何在？</h4><p>为保证进程调度的对所有进程要公平的原则。如果一个进程的子进程都按照父进程的COUNTER值继承，那该进程理论上可以通过无限创建子进程的方式长期占用CPU资源，不利于系统正常运行。</p><h4 id="6-10-描述Linux（以早期的0-11内核为参考）两个进程A-B切换的基本过程。"><a href="#6-10-描述Linux（以早期的0-11内核为参考）两个进程A-B切换的基本过程。" class="headerlink" title="6.10 描述Linux（以早期的0.11内核为参考）两个进程A,B切换的基本过程。"></a>6.10 描述Linux（以早期的0.11内核为参考）两个进程A,B切换的基本过程。</h4><p>进程切换时，首先是保护现场，中断程序调用了schedule()，其中的switch_to做了进程上下文切换，执行完毕后再恢复现场，中断返回。</p><p>进程切换switch_to()源代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/****************************************************************************/  </span><br><span class="line">/* 功能：切换到任务号（即task[]数组下标）为n的任务                          */  </span><br><span class="line">/* 参数：n 任务号                                                         */  </span><br><span class="line">/* 返回：（无）                                                               */  </span><br><span class="line">/****************************************************************************/  </span><br><span class="line">// 整个宏定义利用ljmp指令跳转到TSS段选择符来实现任务切换  </span><br><span class="line"><span class="comment">#define switch_to(n) &#123;/  </span></span><br><span class="line">// __tmp用来构造ljmp的操作数。该操作数由4字节偏移和2字节选择符组成。当选择符  </span><br><span class="line">// 是TSS选择符时，指令忽略4字节偏移。  </span><br><span class="line">// __tmp.a存放的是偏移，__tmp.b的低2字节存放TSS选择符。高两字节为0。  </span><br><span class="line">// ljmp跳转到TSS段选择符会造成任务切换到TSS选择符对应的进程。  </span><br><span class="line">// ljmp指令格式是 ljmp 16位段选择符：32位偏移，但如果操作数在内存中，顺序正好相反。  </span><br><span class="line">// %0   内存地址    __tmp.a的地址，用来放偏移  </span><br><span class="line">// %1   内存地址    __tmp.b的地址，用来放TSS选择符  </span><br><span class="line">// %2   edx         任务号为n的TSS选择符  </span><br><span class="line">// %3   ecx         task[n]  </span><br><span class="line">struct &#123;long a,b;&#125; __tmp; /  </span><br><span class="line">__asm__(<span class="string">"cmpl %%ecx,current/n/t"</span> /  // 如果要切换的任务是当前任务  </span><br><span class="line">    <span class="string">"je 1f/n/t"</span> /                   // 直接退出  </span><br><span class="line">    <span class="string">"movw %%dx,%1/n/t"</span> /            // 把TSS选择符放入__tmp.b中  </span><br><span class="line">    <span class="string">"xchgl %%ecx,current/n/t"</span> /     // 让current指向新进程的task_struct  </span><br><span class="line">    <span class="string">"ljmp *%0/n/t"</span> /                // 任务切换在这里发生，CPU会搞定一切  </span><br><span class="line">    <span class="string">"cmpl %%ecx,last_task_used_math/n/t"</span> /  // 除进程第一次被调度外，以后进程从就绪  </span><br><span class="line">                                        // 态返回运行态后，都从这里开始运行。因  </span><br><span class="line">                                        // 而返回到的是内核运行态。  </span><br><span class="line">    <span class="string">"jne 1f/n/t"</span> /  </span><br><span class="line">    <span class="string">"clts/n"</span> /  </span><br><span class="line">    <span class="string">"1:"</span> /  </span><br><span class="line">    ::<span class="string">"m"</span> (*&amp;__tmp.a),<span class="string">"m"</span> (*&amp;__tmp.b), /  </span><br><span class="line">    <span class="string">"d"</span> (_TSS(n)),<span class="string">"c"</span> ((long) task[n])); /  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要流程是判断当前任务是否是要切换的任务，是则跳到标号1，即不做任何事；交换；调整等。。。</p><p>比较关键的是_TSS(n) 和ljmp %0。</p><p>第7行是理解任务切换机制的关键。长跳转至 <em>&amp;tmp，造成任务的切换。AT&amp;T语法的ljmp相当于Intel语法的 jmp far SECTION : OFFSET，在这里就是将（IP）&lt;-<strong>tmp.a,(CS)&lt;-</strong>tmp.b,它的绝对地址之前加星号（”</em>“）。当段间指令jmp所含指针的选择符指示一个可用任务状态段的TSS描述符时，将造成任务切换。那么CPU怎么识别描述符是TSS描述符而不是其他描述符呢？这是因为所有描述符（一个描述符是64位）中都有4位用来指示该描述符的类型，如描述符类型值是9或11都表示该描述符是TSS描述符。好了，CPU得到TSS描述符后，就会将其加载到任务寄存器TR中，然后根据TSS描述符的信息（主要是基址）找到任务的tss内容（包括所有的寄存器信息，如eip），根据其内容就可以开始新任务的运行。我们暂且把这个恢复所有寄存器状态的过程称为恢复寄存器现场。在第7行执行后，完成任务切换（即切换到新的任务里执行）；当任务切换回来后才会继续执行第8行！下面详解其原因。既然任务切换时CPU会恢复寄存器现场，那么它当然也会保存寄存器现场了。这些寄存器现场都会被写入原任务的tss结构里，值得注意的是，EIP会指向引起任务切换指令（第7行）的下一条指令（第8行），所以，很明显，当原任务有朝一日再次被调度运行时，它将从EIP所指的地方（第8行）开始运行。</p><p>​<figure class="image-box">                <img src="/2020/03/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AD-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/1.png" alt="ljmp %0" title class>                <p>ljmp %0</p>            </figure></p><h4 id="6-11-描述Linux（以早期的0-11内核为参考）中普通进程的调度过程。"><a href="#6-11-描述Linux（以早期的0-11内核为参考）中普通进程的调度过程。" class="headerlink" title="6.11 描述Linux（以早期的0.11内核为参考）中普通进程的调度过程。"></a>6.11 描述Linux（以早期的0.11内核为参考）中普通进程的调度过程。</h4><p>linux系统中，一个进程有5种可能状态，在sched.c第19行处定义了状态的标识：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define TASK_RUNNING 0 // 正在运行或可被运行状态</span></span><br><span class="line"><span class="comment">#define TASK_INTERRUPTIBLE 1 // 可被中断睡眠状态</span></span><br><span class="line"><span class="comment">#define TASK_UNINTERRUPTIBLE 2 // 不可中断睡眠状态</span></span><br><span class="line"><span class="comment">#define TASK_ZOMBIE 3 // 僵死状态</span></span><br><span class="line"><span class="comment">#define TASK_STOPPED 4 // 停止状态</span></span><br></pre></td></tr></table></figure><p>各种状态的转换图如下：</p><p>​<figure class="image-box">                <img src="/2020/03/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AD-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/2.png" alt="状态的转换图" title class>                <p>状态的转换图</p>            </figure></p><p>普通进程的调度发生在用户态。当时钟中断产生时，如果进程运行在用户态时并且时间片用完，中断处理函数do_timer()会调用schedule()函数，这相当于用户态的运行被抢断了。如果进程处在内核态时发生时钟中断，do_timer()不会调用schedule()函数，也就是内核态是不能被抢断的。当一个进程运行在内核态，除非它自愿调用schedule()函数而放弃CPU的使用权，它将永远占用CPU。由于schedule()不是系统调用，用户程序不能调用，所以在时钟中断中调用schedule()是必要的，这样保证用户态的程序不会独占CPU。</p><p>schedule()函数代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">/****************************************************************************/  </span><br><span class="line">/* 功能：进程调度。                                                         */  </span><br><span class="line">/*       先对alarm和信号进行处理，如果某个进程处于可中断睡眠状态，并且收 */  </span><br><span class="line">/*       到信号，则把进程状态改成可运行。之后在处可运行状态的进程中挑选一个  */  </span><br><span class="line">/*       并用switch_to()切换到那个进程                                       */  </span><br><span class="line">/* 参数：（无）                                                               */  </span><br><span class="line">/* 返回：（无）                                                               */  </span><br><span class="line">/****************************************************************************/  </span><br><span class="line">void schedule(void)  </span><br><span class="line">&#123;  </span><br><span class="line">    int i,next,c;  </span><br><span class="line">    struct task_struct ** p;  </span><br><span class="line">/* check alarm, wake up any interruptible tasks that have got a signal */  </span><br><span class="line">// 首先处理alarm信号，唤醒所有收到信号的可中断睡眠进程  </span><br><span class="line">    <span class="keyword">for</span>(p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p)  </span><br><span class="line">        <span class="keyword">if</span> (*p) &#123;  </span><br><span class="line">            // 如果进程设置了alarm，并且alarm已经到时间了  </span><br><span class="line">            <span class="keyword">if</span> ((*p)-&gt;alarm &amp;&amp; (*p)-&gt;alarm &lt; jiffies) &#123;  </span><br><span class="line">                    // 向该进程发送SIGALRM信号  </span><br><span class="line">                    (*p)-&gt;signal |= (1&lt;&lt;(SIGALRM-1));  </span><br><span class="line">                    (*p)-&gt;alarm = 0; // 清除alarm  </span><br><span class="line">                &#125;  </span><br><span class="line">//可屏蔽信号位图BLOCKABLE定义在sched.c第24行，(~(_S(SIGKILL) | _S(SIGSTOP)))  </span><br><span class="line">// 说明SIGKILL和SIGSTOP是不能被屏蔽的。  </span><br><span class="line">// 可屏蔽信号位图 &amp; 当前进程屏蔽的信号位图 = 当前进程实际屏蔽的信号位图  </span><br><span class="line">// 当前进程收到的信号位图 &amp; ~当前进程实际屏蔽的信号位图   </span><br><span class="line">//                          = 当前进程收到的允许相应的信号位图  </span><br><span class="line">// 如果当前进程收到允许相应的信号，并且当前进程处于可中断睡眠态  </span><br><span class="line">// 则把状态改成运行态，参与下面的选择过程  </span><br><span class="line">            <span class="keyword">if</span> (((*p)-&gt;signal &amp; ~(_BLOCKABLE &amp; (*p)-&gt;blocked)) &amp;&amp;  </span><br><span class="line">            (*p)-&gt;state==TASK_INTERRUPTIBLE)  </span><br><span class="line">                (*p)-&gt;state=TASK_RUNNING;  </span><br><span class="line">        &#125;  </span><br><span class="line">/* this is the scheduler proper: */  </span><br><span class="line">// 下面是进程调度的主要部分  </span><br><span class="line">    <span class="keyword">while</span> (1) &#123;  </span><br><span class="line">        c = -1;  </span><br><span class="line">        next = 0;  </span><br><span class="line">        i = NR_TASKS;  </span><br><span class="line">        p = &amp;task[NR_TASKS];  </span><br><span class="line">        <span class="keyword">while</span> (--i) &#123;       // 遍历整个task[]数组  </span><br><span class="line">            <span class="keyword">if</span> (!*--p)      // 跳过task[]中的空项  </span><br><span class="line">                <span class="built_in">continue</span>;  </span><br><span class="line">            // 寻找剩余时间片最长的可运行进程，  </span><br><span class="line">//  c记录目前找到的最长时间片  </span><br><span class="line">// next记录目前最长时间片进程的任务号  </span><br><span class="line">            <span class="keyword">if</span> ((*p)-&gt;state == TASK_RUNNING &amp;&amp; (*p)-&gt;counter &gt; c)  </span><br><span class="line">                c = (*p)-&gt;counter, next = i;  </span><br><span class="line">        &#125;  </span><br><span class="line">    // 如果有进程时间片没有用完c一定大于0。这时退出循环，执行 switch_to任务切换  </span><br><span class="line">        <span class="keyword">if</span> (c) <span class="built_in">break</span>;  </span><br><span class="line">    // 到这里说明所有可运行进程的时间片都用完了，则利用任务优先级重新分配时间片。  </span><br><span class="line">    // 这里需要重新设置所有任务的时间片，而不光是可运行任务的时间片。  </span><br><span class="line">    // 利用公式：counter = counter/2 + priority  </span><br><span class="line">        <span class="keyword">for</span>(p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p)  </span><br><span class="line">            <span class="keyword">if</span> (*p)  </span><br><span class="line">                (*p)-&gt;counter = ((*p)-&gt;counter &gt;&gt; 1) +  </span><br><span class="line">                        (*p)-&gt;priority;  </span><br><span class="line">    // 整个设置时间片过程结束后，重新进入进程选择过程  </span><br><span class="line">    &#125;  </span><br><span class="line">    // 当的上面的循环退出时，说明找到了可以切换的任务  </span><br><span class="line">    switch_to(next);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当前进程只有调用了schedule()后才能发生进程切换，因此当进程再次被选中执行后，都是从switch_to()中ljmp后一条语句开始执行，即从”cmpl %%ecx,last_task_used_math/n/t”语句继续，这时进程位于内核态。因此进程从就绪态进入的都是内核运行态。但有一个例外，进程产生后第一次被调度执行。</p><p>fork()产生的子进程会把父进程原cs、原eip当作初始的cs、eip，所以子进程刚刚创建时处于用户态。第一次进程被调度时，从就绪态进入的是用户运行态。以后进入的都是内核运行态。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统课程学习笔记五-死锁</title>
      <link href="/2020/03/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%94-%E6%AD%BB%E9%94%81/"/>
      <url>/2020/03/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%94-%E6%AD%BB%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1 id="第五章-死锁"><a href="#第五章-死锁" class="headerlink" title="第五章 死锁"></a>第五章 死锁</h1><h4 id="5-1-什么是死锁或死锁的定义是什么？"><a href="#5-1-什么是死锁或死锁的定义是什么？" class="headerlink" title="5.1 什么是死锁或死锁的定义是什么？"></a>5.1 什么是死锁或死锁的定义是什么？</h4><p>​两个或多个进程中，每个进程都持有某种资源，但又继续申请其他进程已持有的某种资源，此时每个进程都拥有其运行所需的一部分资源但又都不够，结果每个进程永远陷入阻塞。这种状况成为死锁。</p><h4 id="5-2-在Linux或Windows的实际应用中，用户常说的“死机”或“宕机”或“程序卡住”或“系统卡住，键鼠没有任何响应”与本章的“死锁”是同一问题吗？"><a href="#5-2-在Linux或Windows的实际应用中，用户常说的“死机”或“宕机”或“程序卡住”或“系统卡住，键鼠没有任何响应”与本章的“死锁”是同一问题吗？" class="headerlink" title="5.2 在Linux或Windows的实际应用中，用户常说的“死机”或“宕机”或“程序卡住”或“系统卡住，键鼠没有任何响应”与本章的“死锁”是同一问题吗？"></a>5.2 在Linux或Windows的实际应用中，用户常说的“死机”或“宕机”或“程序卡住”或“系统卡住，键鼠没有任何响应”与本章的“死锁”是同一问题吗？</h4><p>不是。<br>“死机”或“宕机”或“系统卡住，键鼠没有任何响应”可能由于多种原因引起，比如由于进程死锁、程序运行错误导致进程长期陷入阻塞、操作系统无法满足进程申请的资源等因素引起。<br>死锁受影响的仅仅是死锁的进程以及所涉及的部分资源，未必会引起“死机”或“宕机”。</p><h4 id="5-3-如何证明“参与死锁的进程至少有2个已经占有资源”？"><a href="#5-3-如何证明“参与死锁的进程至少有2个已经占有资源”？" class="headerlink" title="5.3 如何证明“参与死锁的进程至少有2个已经占有资源”？"></a>5.3 如何证明“参与死锁的进程至少有2个已经占有资源”？</h4><p>反证法。只有一个资源的话，占有该资源的进程不会由于等待其他资源而陷入死锁，因此发生死锁必须有两个以上资源。</p><h4 id="5-4-死锁的四个必要条件是哪些？"><a href="#5-4-死锁的四个必要条件是哪些？" class="headerlink" title="5.4 死锁的四个必要条件是哪些？"></a>5.4 死锁的四个必要条件是哪些？</h4><p>互斥条件：进程互斥使用资源，资源具有独占性。<br>不剥夺条件：进程在访问完资源前不能被其他进程强行剥夺。<br>部分分配条件：进程边运行边申请资源，临时需要临时分配。<br>环路条件：多个进程构成环路，环中每个已占用资源被前一进程申请，自己所申请资源被后一进程占用。</p><h4 id="5-4-如何证明“按有序资源分配法分配资源并发进程不会死锁”？"><a href="#5-4-如何证明“按有序资源分配法分配资源并发进程不会死锁”？" class="headerlink" title="5.4 如何证明“按有序资源分配法分配资源并发进程不会死锁”？"></a>5.4 如何证明“按有序资源分配法分配资源并发进程不会死锁”？</h4><p>有序资源分配法实质上是为不同进程的资源申请标注了优先级，按先到先得的顺序排列，保证了最靠前的进程对所需的资源有最高访问权限，不会出现每个进程都拥有其运行所需的一部分资源但另一部分资源被其他进程占用的情况。</p><h4 id="5-5-在Linux或Windows是如何处理死锁的？"><a href="#5-5-在Linux或Windows是如何处理死锁的？" class="headerlink" title="5.5 在Linux或Windows是如何处理死锁的？"></a>5.5 在Linux或Windows是如何处理死锁的？</h4><p>由于目前没有一种高效稳定处理死锁的方法，因此Linux或Windows并没有对死锁进行预防和处理的功能，需要使用者主动避免。</p><h4 id="5-6-了解“避免死锁”策略，并了解“银行家算法”的概念和原理"><a href="#5-6-了解“避免死锁”策略，并了解“银行家算法”的概念和原理" class="headerlink" title="5.6 了解“避免死锁”策略，并了解“银行家算法”的概念和原理?"></a>5.6 了解“避免死锁”策略，并了解“银行家算法”的概念和原理?</h4><p>避免死锁是指不采取限制破坏产生死锁的条件，而是在资源分配过程中用某种方式评估分配资源是否会让系统进入死锁状态，若会导致陷入死锁则拒绝分配资源，从而避免死锁。实现难度较大。</p><p>银行家算法：在银行中，客户申请贷款的数量是有限的，每个客户在第一次申请贷款时要声明完成该项目所需的最大资金量，在满足所有贷款要求时，客户应及时归还。银行家在客户申请的贷款数量不超过自己拥有的最大值时，都应尽量满足客户的需要。在这样的描述中，银行家就好比操作系统，资金就是资源，客户就相当于要申请资源的进程。</p><p>银行家算法是一种最有代表性的避免死锁的算法。在避免死锁方法中允许进程动态地申请资源，但系统在进行资源分配之前，应先计算此次分配资源的安全性，若分配不会导致系统进入不安全状态，则分配，否则等待。为实现银行家算法，系统必须设置若干数据结构。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理学习笔记五-自上而下的语法分析</title>
      <link href="/2020/03/16/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%94-%E8%87%AA%E4%B8%8A%E8%80%8C%E4%B8%8B%E7%9A%84%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/"/>
      <url>/2020/03/16/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%94-%E8%87%AA%E4%B8%8A%E8%80%8C%E4%B8%8B%E7%9A%84%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="第五章-自上而下的语法分析"><a href="#第五章-自上而下的语法分析" class="headerlink" title="第五章 自上而下的语法分析"></a>第五章 自上而下的语法分析</h1><h4 id="自上而下"><a href="#自上而下" class="headerlink" title="自上而下"></a>自上而下</h4><p>从文法的开始符号出发，反复使用各种产生式，寻找”匹配”的推导；<br>推导：根据文法的产生式规则，把串中出现的产生式的左部符号替换成右部；<br>针对输入串，试图用一切可能的办法，从文法开始符号(根结点)出发，自上而下地为输入串建立一棵语法树；<br>递归下降分析法、预测分析程序。</p><h3 id="第一部分：LL-1-文法"><a href="#第一部分：LL-1-文法" class="headerlink" title="第一部分：LL(1)文法"></a>第一部分：LL(1)文法</h3><h4 id="1-多个产生式候选带来的问题"><a href="#1-多个产生式候选带来的问题" class="headerlink" title="1 多个产生式候选带来的问题"></a>1 多个产生式候选带来的问题</h4><p>回溯问题：分析过程中，当一个非终结符用某一个候选匹配成功时，这种匹配可能是暂时的，出错时，不得不“回溯”；<br>文法左递归问题：左递归的文法可能由于语法错误导致陷入死循环。</p><h4 id="2-直接左递归的消除"><a href="#2-直接左递归的消除" class="headerlink" title="2 直接左递归的消除"></a>2 直接左递归的消除</h4><figure class="image-box">                <img src="/2020/03/16/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%94-%E8%87%AA%E4%B8%8A%E8%80%8C%E4%B8%8B%E7%9A%84%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/1.png" alt="直接左递归的消除" title class>                <p>直接左递归的消除</p>            </figure><p><strong>公式</strong>：<br>P→Pα1 | Pα2 |……| Pαm |β1 |β2 |……|βn<br>推导为：<br>P→β1P’|β2P’|…|βnP’<br>P’→α1P’|α2P’|…|αmP’|ε  </p><p><strong>例子</strong>：<br>给定文法G(E):<br>E→E＋T | T<br>T→T<em>F | F<br>F→(E) | i<br>推导为：<br>G(E):<br>E→TE’<br>E’→+TE’ | ε<br>T→FT’<br>T’→</em>FT’ | ε<br>F→(E) | i    </p><h4 id="3-间接左递归的消除"><a href="#3-间接左递归的消除" class="headerlink" title="3 间接左递归的消除"></a>3 间接左递归的消除</h4><figure class="image-box">                <img src="/2020/03/16/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%94-%E8%87%AA%E4%B8%8A%E8%80%8C%E4%B8%8B%E7%9A%84%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/2.png" alt="间接左递归的消除" title class>                <p>间接左递归的消除</p>            </figure><h4 id="4-消除回溯"><a href="#4-消除回溯" class="headerlink" title="4 消除回溯"></a>4 消除回溯</h4><p>为了消除回溯必须保证对文法的任何非终结符，当要它去匹配输入串时，能够根据它所面临的输入符号准确地指派它的一个候选去执行任务，并且此候选的工作结果应是确信无疑的。</p><h4 id="5-𝐹𝐼𝑅𝑆𝑇集合"><a href="#5-𝐹𝐼𝑅𝑆𝑇集合" class="headerlink" title="5 𝐹𝐼𝑅𝑆𝑇集合"></a>5 𝐹𝐼𝑅𝑆𝑇集合</h4><p>令G是一个不含左递归的文法，对G的所有非终结符的每个候选𝛼定义它的终结首符集FIRST(𝛼)为：<br>𝐹𝐼𝑅𝑆𝑇(𝛼)={𝑎│𝛼∗⇒ 𝑎…, 𝑎∈𝑉𝑇}<br>特别是，若𝛼∗⇒ 𝜀，则规定𝜀∈𝐹𝐼𝑅𝑆𝑇(𝛼)。</p><h4 id="6-𝐹𝑂𝐿𝐿𝑂𝑊集合"><a href="#6-𝐹𝑂𝐿𝐿𝑂𝑊集合" class="headerlink" title="6 𝐹𝑂𝐿𝐿𝑂𝑊集合"></a>6 𝐹𝑂𝐿𝐿𝑂𝑊集合</h4><p>假定S是文法G的开始符号，对于G的任何非终结符A，我们定义A的FOLLOW集合：<br>𝐹𝑂𝐿𝐿𝑂𝑊(𝐴)={𝑎│𝑆∗⇒…𝐴𝑎…, 𝑎∈𝑉𝑇 }<br>特别是，若𝑆∗⇒…𝐴，则规定#∈𝐹𝑂𝐿𝐿𝑂𝑊(𝐴)</p><h4 id="7-LL-1-文法"><a href="#7-LL-1-文法" class="headerlink" title="7 LL(1)文法"></a>7 LL(1)文法</h4><p>特点：</p><ol><li>文法不含左递归  </li><li>对于文法中每一个非终结符A的各个产生式的候选首符集两两不相交。  </li><li>对文法中的每个非终结符A，若它存在某个候选首符集包含𝜀，则<br>FIRST(𝛼i)∩FOLLOW(A)=#，i=1,2,…,n</li></ol><p>对于LL(1)文法，可以对其输入串进行有效的无回溯的自上而下分析。<br>假设要用非终结符A进行匹配，面临的输入符号为a：  </p><ol><li>若a∈FIRST(𝛼i)，则指派𝛼i执行匹配任务；  </li><li>若a不属于任何一个候选首符集，则：<br>(1) 若𝛼属于某个FIRST(𝛼i)且 a∈FOLLOW(A)，则让A与𝛼自动匹配。<br>(2) 否则，a的出现是一种语法错误。</li></ol><h3 id="第二部分：递归下降分析程序"><a href="#第二部分：递归下降分析程序" class="headerlink" title="第二部分：递归下降分析程序"></a>第二部分：递归下降分析程序</h3><h4 id="8-递归下降分析器"><a href="#8-递归下降分析器" class="headerlink" title="8 递归下降分析器"></a>8 递归下降分析器</h4><p>分析程序由一组子程序组成， 对每一语法单位(非终结符)构造一个相应的子程序，识别对应的语法单位；<br>通过子程序间的相互调用实现对输入串的识别；<br>例如，A → B c D；<br>文法的定义通常是递归的，通常具有递归结构。</p><p>每个非终结符有对应的子程序的定义，在分析过程中，当需要从某个非终结符出发进行展开(推导)时，就调用这个非终结符对应的子程序。</p><p>例子：<br>定义全局过程和变量：<br>ADVANCE，把输入串指示器IP指向下一个输入符号，即读入一个单词符号；<br>SYM，IP当前所指的输入符号；<br>ERROR，出错处理子程序。<br>A→TE’ | BC | 𝜀    对应的递归下降子程序为：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PROCEDURE  A；</span><br><span class="line">BEGIN</span><br><span class="line">  IF  SYM ∈FIRST(TE&#39;) THEN</span><br><span class="line">    BEGIN  T；E&#39; END</span><br><span class="line">  ELSE IF  SYM ∈FIRST(BC) THEN</span><br><span class="line">    BEGIN  B; C  END</span><br><span class="line">  ELSE IF  SYM ∈FOLLOW(A) THEN</span><br><span class="line">    ERROR</span><br><span class="line">END；</span><br></pre></td></tr></table></figure><h4 id="9-扩充的巴科斯范式"><a href="#9-扩充的巴科斯范式" class="headerlink" title="9 扩充的巴科斯范式"></a>9 扩充的巴科斯范式</h4><p>在元符号“→”或“::=”和“|”的基础上，扩充几个元语言符号：<br>用花括号{α}表示闭包运算α*。<br>用表示{α}<sub>0</sub><sup>n</sup>可任意重复0次至n次。<br>用方括号[α]表示{α}<sub>0</sub><sup>1</sup>，即表示α的出现可有可无(等价于α|𝜀)。  </p><p>例如实数可定义为：<br>   Decimal→[Sign]Integer.{digit}[Exponent]<br>   Exponent→E[Sign]Integer<br>   Integer→digit{digit}<br>   Sign→ + | -</p><p>用扩充的巴科斯范式来描述语法，直观易懂，便于表示左递归消去和因子提取。</p><h3 id="第二部分：预测分析程序"><a href="#第二部分：预测分析程序" class="headerlink" title="第二部分：预测分析程序"></a>第二部分：预测分析程序</h3><h4 id="10-预测分析程序构成"><a href="#10-预测分析程序构成" class="headerlink" title="10 预测分析程序构成"></a>10 预测分析程序构成</h4><p>总控程序，根据现行栈顶符号和当前输入符号，执行动作；<br>分析表 M[A，a]矩阵，A ∈ V<sub>N</sub> ，a ∈ V<sub>T</sub> 是终结符或‘＃’；<br>分析栈 STACK  用于存放文法符号。</p><figure class="image-box">                <img src="/2020/03/16/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%94-%E8%87%AA%E4%B8%8A%E8%80%8C%E4%B8%8B%E7%9A%84%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/3.png" alt="预测分析程序构成" title class>                <p>预测分析程序构成</p>            </figure><h4 id="11-预测分析过程"><a href="#11-预测分析过程" class="headerlink" title="11 预测分析过程"></a>11 预测分析过程</h4><p>总控程序根据当前栈顶符号X和输入符号a，执行下列三动作之一：  </p><ol><li>若X＝a＝‘＃’，则宣布分析成功，停止分析。  </li><li>若X＝a ≠‘＃’，则把X从STACK栈顶逐出，让a指向下一个输入符号。  </li><li>若X是一个非终结符，则查看分析表M。<br>若M[X，a]中存放着关于X的一个产生式，把X逐出STACK栈顶，把产生式的右部符号串按反序一一推进STACK栈(若右部符号为𝜀，则意味不推什么东西进栈)。<br>若M[X，a]中存放着“出错标志”，则调用出错诊察程序ERROR。</li></ol><h4 id="12-总控程序实现"><a href="#12-总控程序实现" class="headerlink" title="12 总控程序实现"></a>12 总控程序实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">BEGIN</span><br><span class="line">  首先把‘＃’然后把文法开始符号推进STACK栈；</span><br><span class="line">  把第一个输入符号读进a；</span><br><span class="line">  FLAG:&#x3D;TRUE;</span><br><span class="line">  WHILE  FLAG  DO</span><br><span class="line">  BEGIN</span><br><span class="line">    把STACK栈顶符号上托出去并放在X中；</span><br><span class="line">    IF X属于VT THEN</span><br><span class="line">      IF X&#x3D; a  THEN 把下一输入符号读进a</span><br><span class="line">        ELSE   ERROR</span><br><span class="line">      ELSE IF X&#x3D;‘#’ THEN</span><br><span class="line">        IF X&#x3D;a THEN FLAG:&#x3D;FALSE </span><br><span class="line">          ELSE ERROR</span><br><span class="line">      ELSE IF M[X,a]&#x3D;&#123;X→X1X2…Xk&#125;THEN</span><br><span class="line">      把Xk,Xk-1,…,X1一一推进STACK栈</span><br><span class="line">      &#x2F;* 若X1X2…Xk&#x3D;𝜀，不推什么进栈 *&#x2F;</span><br><span class="line">      ELSE ERROR</span><br><span class="line">    END OF WHILE;</span><br><span class="line">  STOP &#x2F;*分析成功，过程完毕*&#x2F;</span><br><span class="line">END</span><br></pre></td></tr></table></figure><h4 id="13-预测分析示例"><a href="#13-预测分析示例" class="headerlink" title="13 预测分析示例"></a>13 预测分析示例</h4><figure class="image-box">                <img src="/2020/03/16/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%94-%E8%87%AA%E4%B8%8A%E8%80%8C%E4%B8%8B%E7%9A%84%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/4.png" alt="预测分析示例" title class>                <p>预测分析示例</p>            </figure><h4 id="13-分析表M-A，a-的构造算法"><a href="#13-分析表M-A，a-的构造算法" class="headerlink" title="13 分析表M[A，a]的构造算法"></a>13 分析表M[A，a]的构造算法</h4><p>构造G的分析表M[A，a]， 确定每个产生式A→α在表中的位置  </p><ol><li>对文法G的每个产生式A→α执行第2步和第3步；  </li><li>对每个终结符a ∈ FIRST(α)，把A→α加至M[A，a]中；  </li><li>若𝜀 ∈ FIRST(α)，则对任何b ∈ FOLLOW(A)把A→α加至M[A，b]中；  </li><li>把所有无定义的M[A，a]标上“出错标志”。  </li></ol><h4 id="14-LL-1-文法与二义性"><a href="#14-LL-1-文法与二义性" class="headerlink" title="14 LL(1)文法与二义性"></a>14 LL(1)文法与二义性</h4><p>如果G是左递归或二义的，那么，M至少含有一个多重定义入口。因此，消除左递归和提取左因子将有助于获得无多重定义的分析表M。<br>可以证明，一个文法G的预测分析表M不含多重定义入口，当且仅当该文法为LL(1)的。<br>LL(1)文法不是二义的。</p>]]></content>
      
      
      <categories>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法课程笔记-图论</title>
      <link href="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%9B%BE%E8%AE%BA/"/>
      <url>/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%9B%BE%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><p>分为无向图和有向图<br>分为有权图和无权图（边的值）<br>图的连通性<br><img src="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%9B%BE%E8%AE%BA/1.png" alt="自环边和平行边">  </p><h4 id="1-图的表示"><a href="#1-图的表示" class="headerlink" title="1 图的表示"></a>1 图的表示</h4><figure class="image-box">                <img src="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%9B%BE%E8%AE%BA/2.png" alt="邻接矩阵" title class>                <p>邻接矩阵</p>            </figure>  <p><img src="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%9B%BE%E8%AE%BA/3.png" alt="邻接表1">  </p><figure class="image-box">                <img src="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%9B%BE%E8%AE%BA/4.png" alt="邻接表2" title class>                <p>邻接表2</p>            </figure>  <p>邻接矩阵适合表示稠密图，邻接表适合表示稀疏图。稠密与稀疏取决于边（edge）的数量。</p><h4 id="2-深度优先遍历（dfs）与连通分量（Components）"><a href="#2-深度优先遍历（dfs）与连通分量（Components）" class="headerlink" title="2 深度优先遍历（dfs）与连通分量（Components）"></a>2 深度优先遍历（dfs）与连通分量（Components）</h4><p>深度优先遍历与树的前序遍历类似，但需要记录该节点是否遍历过<br><img src="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%9B%BE%E8%AE%BA/5.png" alt="连通分量"> </p><h4 id="3-寻路"><a href="#3-寻路" class="headerlink" title="3 寻路"></a>3 寻路</h4><p>与dfs相似</p><h4 id="4-广度优先遍历（bfs）与最短路径"><a href="#4-广度优先遍历（bfs）与最短路径" class="headerlink" title="4 广度优先遍历（bfs）与最短路径"></a>4 广度优先遍历（bfs）与最短路径</h4><p>广度优先遍历与树的层序遍历类似，利用队列，一个节点出队，将所有相连节点加入队列，需要记录该节点是否遍历过。<br>广度优先遍历的特点在于先遍历的元素距离起点近（无权图）。</p><h4 id="5-有权图（weighted-graph）"><a href="#5-有权图（weighted-graph）" class="headerlink" title="5 有权图（weighted graph）"></a>5 有权图（weighted graph）</h4><figure class="image-box">                <img src="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%9B%BE%E8%AE%BA/6.png" alt="有权图" title class>                <p>有权图</p>            </figure>  <figure class="image-box">                <img src="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%9B%BE%E8%AE%BA/7.png" alt="有权图邻接矩阵" title class>                <p>有权图邻接矩阵</p>            </figure>  <figure class="image-box">                <img src="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%9B%BE%E8%AE%BA/8.png" alt="有权图邻接表" title class>                <p>有权图邻接表</p>            </figure>  <h4 id="6-最小生成树和切分定理（cut-property）"><a href="#6-最小生成树和切分定理（cut-property）" class="headerlink" title="6 最小生成树和切分定理（cut property）"></a>6 最小生成树和切分定理（cut property）</h4><p>n-1条边连接了n个节点，称为生成树。若总权值最小，称为最小生成树。<br>将图进行切分，边的两个节点分属两半称为横切边。<br>切分定理：对于任意切分，横切边中权值最小的边属于最小生成树。  </p><h4 id="7-prim算法"><a href="#7-prim算法" class="headerlink" title="7 prim算法"></a>7 prim算法</h4><figure class="image-box">                <img src="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%9B%BE%E8%AE%BA/9.png" alt="有权图邻接表" title class>                <p>有权图邻接表</p>            </figure>  <h4 id="8-kruskal算法"><a href="#8-kruskal算法" class="headerlink" title="8 kruskal算法"></a>8 kruskal算法</h4><h4 id="9-最短路径问题与松弛操作（relaxation）"><a href="#9-最短路径问题与松弛操作（relaxation）" class="headerlink" title="9 最短路径问题与松弛操作（relaxation）"></a>9 最短路径问题与松弛操作（relaxation）</h4><p>松弛操作是最短路径问题的核心。</p><h4 id="10-dijkstra算法"><a href="#10-dijkstra算法" class="headerlink" title="10 dijkstra算法"></a>10 dijkstra算法</h4><p>前提：没有负权边。<br><img src="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%9B%BE%E8%AE%BA/10.png" alt="dijkstra算法"><br>如图所示，0到2的路径最短，因此0到2的最短路径可以确定为2。  </p><p><img src="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%9B%BE%E8%AE%BA/11.png" alt="dijkstra算法"><br>如图所示，2到1的距离是1，则0到1的最短距离更新为3，距离为5的边被废弃，这一操作为松弛操作。  </p><p>通过上述两种操作，可得到如下结果。<br><img src="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%9B%BE%E8%AE%BA/12.png" alt="dijkstra算法">   </p><h4 id="11-负权边与bellman-ford算法"><a href="#11-负权边与bellman-ford算法" class="headerlink" title="11 负权边与bellman-ford算法"></a>11 负权边与bellman-ford算法</h4><p>如果有负权环，则没有最短路径。<br>bellman-ford算法可解决负权边最短路径问题。<br>最短路径最多经过n个节点，否则就有负权环。<br>一个点的一次松弛操作就是找到经过这个点的另外一条路径，多一条边，权值更小。从一点到另外一点最多有n-1条边。对所有的点进行n-1次松弛操作，找到最短路径。如果n-1次松弛操作后还可以继续松弛，则有负权环。  </p><h4 id="12-拓扑排序"><a href="#12-拓扑排序" class="headerlink" title="12 拓扑排序"></a>12 拓扑排序</h4><p>用于有向无环图</p><h4 id="13-课程用到的算法思想"><a href="#13-课程用到的算法思想" class="headerlink" title="13 课程用到的算法思想"></a>13 课程用到的算法思想</h4><figure class="image-box">                <img src="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%9B%BE%E8%AE%BA/13.png" alt="总结" title class>                <p>总结</p>            </figure>  ]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
            <tag> 算法与数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法课程笔记-并查集</title>
      <link href="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
      <url>/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p>用于解决连接问题<br><img src="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%B9%B6%E6%9F%A5%E9%9B%86/1.png" alt="并查集">  </p><h4 id="1-树结构并查集"><a href="#1-树结构并查集" class="headerlink" title="1 树结构并查集"></a>1 树结构并查集</h4><p>初始条件下所有结点都为根节点，根节点指向自己。连接时，将一节点的根节点指向另一节点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> UF2&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span>&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">// 使用一个数组构建一棵指向父节点的树</span></span><br><span class="line">        <span class="comment">// parent[i]表示第一个元素所指向的父节点</span></span><br><span class="line">        <span class="keyword">int</span>* parent;</span><br><span class="line">        <span class="keyword">int</span> count;  <span class="comment">// 数据个数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 构造函数</span></span><br><span class="line">        UnionFind(<span class="keyword">int</span> count)&#123;</span><br><span class="line">            parent = <span class="keyword">new</span> <span class="keyword">int</span>[count];</span><br><span class="line">            <span class="keyword">this</span>-&gt;count = count;</span><br><span class="line">            <span class="comment">// 初始化, 每一个parent[i]指向自己, 表示每一个元素自己自成一个集合</span></span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; count ; i ++ )</span><br><span class="line">                parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 析构函数</span></span><br><span class="line">        ~UnionFind()&#123;</span><br><span class="line">            <span class="keyword">delete</span>[] parent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找过程, 查找元素p所对应的集合编号</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">            assert( p &gt;= <span class="number">0</span> &amp;&amp; p &lt; count );</span><br><span class="line">            <span class="comment">// 不断去查询自己的父亲节点, 直到到达根节点</span></span><br><span class="line">            <span class="comment">// 根节点的特点: parent[p] == p</span></span><br><span class="line">            <span class="keyword">while</span>( p != parent[p] )</span><br><span class="line">                p = parent[p];</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查看元素p和元素q是否所属一个集合</span></span><br><span class="line">        <span class="comment">// O(h)复杂度, h为树的高度</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">isConnected</span><span class="params">( <span class="keyword">int</span> p , <span class="keyword">int</span> q )</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">find</span>(p) == <span class="built_in">find</span>(q);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并元素p和元素q所属的集合</span></span><br><span class="line">        <span class="comment">// O(h)复杂度, h为树的高度</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">unionElements</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> pRoot = <span class="built_in">find</span>(p);</span><br><span class="line">            <span class="keyword">int</span> qRoot = <span class="built_in">find</span>(q);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( pRoot == qRoot )</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-树结构层数优化并查集"><a href="#2-树结构层数优化并查集" class="headerlink" title="2 树结构层数优化并查集"></a>2 树结构层数优化并查集</h4><p>合并时将层数较少的集合指向层数较多的集合，减少树的总层数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> UF4&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span>&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span>* rank;   <span class="comment">// rank[i]表示以i为根的集合所表示的树的层数</span></span><br><span class="line">        <span class="keyword">int</span>* parent; <span class="comment">// parent[i]表示第i个元素所指向的父节点</span></span><br><span class="line">        <span class="keyword">int</span> count;   <span class="comment">// 数据个数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 构造函数</span></span><br><span class="line">        UnionFind(<span class="keyword">int</span> count)&#123;</span><br><span class="line">            parent = <span class="keyword">new</span> <span class="keyword">int</span>[count];</span><br><span class="line">            rank = <span class="keyword">new</span> <span class="keyword">int</span>[count];</span><br><span class="line">            <span class="keyword">this</span>-&gt;count = count;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; count ; i ++ )&#123;</span><br><span class="line">                parent[i] = i;</span><br><span class="line">                rank[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 析构函数</span></span><br><span class="line">        ~UnionFind()&#123;</span><br><span class="line">            <span class="keyword">delete</span>[] parent;</span><br><span class="line">            <span class="keyword">delete</span>[] rank;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找过程, 查找元素p所对应的集合编号</span></span><br><span class="line">        <span class="comment">// O(h)复杂度, h为树的高度</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">            assert( p &gt;= <span class="number">0</span> &amp;&amp; p &lt; count );</span><br><span class="line">            <span class="comment">// 不断去查询自己的父亲节点, 直到到达根节点</span></span><br><span class="line">            <span class="comment">// 根节点的特点: parent[p] == p</span></span><br><span class="line">            <span class="keyword">while</span>( p != parent[p] )</span><br><span class="line">                p = parent[p];</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查看元素p和元素q是否所属一个集合</span></span><br><span class="line">        <span class="comment">// O(h)复杂度, h为树的高度</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">isConnected</span><span class="params">( <span class="keyword">int</span> p , <span class="keyword">int</span> q )</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">find</span>(p) == <span class="built_in">find</span>(q);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并元素p和元素q所属的集合</span></span><br><span class="line">        <span class="comment">// O(h)复杂度, h为树的高度</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">unionElements</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> pRoot = <span class="built_in">find</span>(p);</span><br><span class="line">            <span class="keyword">int</span> qRoot = <span class="built_in">find</span>(q);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( pRoot == qRoot )</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根据两个元素所在树的元素个数不同判断合并方向</span></span><br><span class="line">            <span class="comment">// 将元素个数少的集合合并到元素个数多的集合上</span></span><br><span class="line">            <span class="keyword">if</span>( rank[pRoot] &lt; rank[qRoot] )&#123;</span><br><span class="line">                parent[pRoot] = qRoot;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>( rank[qRoot] &lt; rank[pRoot])&#123;</span><br><span class="line">                parent[qRoot] = pRoot;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123; <span class="comment">// rank[pRoot] == rank[qRoot]</span></span><br><span class="line">                parent[pRoot] = qRoot;</span><br><span class="line">                rank[qRoot] += <span class="number">1</span>;   <span class="comment">// 此时, 我维护rank的值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-路径压缩并查集"><a href="#3-路径压缩并查集" class="headerlink" title="3 路径压缩并查集"></a>3 路径压缩并查集</h4><figure class="image-box">                <img src="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%B9%B6%E6%9F%A5%E9%9B%86/2.png" alt="路径压缩" title class>                <p>路径压缩</p>            </figure><p>查找根节点时将父节点指向父节点的父节点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> UF5&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span>&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>* rank;   <span class="comment">// rank[i]表示以i为根的集合所表示的树的层数</span></span><br><span class="line">        <span class="keyword">int</span>* parent; <span class="comment">// parent[i]表示第i个元素所指向的父节点</span></span><br><span class="line">        <span class="keyword">int</span> count;   <span class="comment">// 数据个数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 构造函数</span></span><br><span class="line">        UnionFind(<span class="keyword">int</span> count)&#123;</span><br><span class="line">            parent = <span class="keyword">new</span> <span class="keyword">int</span>[count];</span><br><span class="line">            rank = <span class="keyword">new</span> <span class="keyword">int</span>[count];</span><br><span class="line">            <span class="keyword">this</span>-&gt;count = count;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; count ; i ++ )&#123;</span><br><span class="line">                parent[i] = i;</span><br><span class="line">                rank[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 析构函数</span></span><br><span class="line">        ~UnionFind()&#123;</span><br><span class="line">            <span class="keyword">delete</span>[] parent;</span><br><span class="line">            <span class="keyword">delete</span>[] rank;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找过程, 查找元素p所对应的集合编号</span></span><br><span class="line">        <span class="comment">// O(h)复杂度, h为树的高度</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">            assert( p &gt;= <span class="number">0</span> &amp;&amp; p &lt; count );</span><br><span class="line"></span><br><span class="line">            <span class="comment">// path compression 1</span></span><br><span class="line">            <span class="keyword">while</span>( p != parent[p] )&#123;</span><br><span class="line">                parent[p] = parent[parent[p]];</span><br><span class="line">                p = parent[p];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查看元素p和元素q是否所属一个集合</span></span><br><span class="line">        <span class="comment">// O(h)复杂度, h为树的高度</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">isConnected</span><span class="params">( <span class="keyword">int</span> p , <span class="keyword">int</span> q )</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">find</span>(p) == <span class="built_in">find</span>(q);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并元素p和元素q所属的集合</span></span><br><span class="line">        <span class="comment">// O(h)复杂度, h为树的高度</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">unionElements</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> pRoot = <span class="built_in">find</span>(p);</span><br><span class="line">            <span class="keyword">int</span> qRoot = <span class="built_in">find</span>(q);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( pRoot == qRoot )</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根据两个元素所在树的元素个数不同判断合并方向</span></span><br><span class="line">            <span class="comment">// 将元素个数少的集合合并到元素个数多的集合上</span></span><br><span class="line">            <span class="keyword">if</span>( rank[pRoot] &lt; rank[qRoot] )&#123;</span><br><span class="line">                parent[pRoot] = qRoot;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>( rank[qRoot] &lt; rank[pRoot])&#123;</span><br><span class="line">                parent[qRoot] = pRoot;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123; <span class="comment">// rank[pRoot] == rank[qRoot]</span></span><br><span class="line">                parent[pRoot] = qRoot;</span><br><span class="line">                rank[qRoot] += <span class="number">1</span>;   <span class="comment">// 此时维护rank的值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
            <tag> 算法与数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法课程笔记-二分搜索树</title>
      <link href="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
      <url>/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="二分搜索算法"><a href="#二分搜索算法" class="headerlink" title="二分搜索算法"></a>二分搜索算法</h1><p>用于解决查找问题</p><h4 id="1-二分查找法"><a href="#1-二分查找法" class="headerlink" title="1 二分查找法"></a>1 二分查找法</h4><p>只能在有序数组中查找</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分查找法,在有序数组arr中,查找target</span></span><br><span class="line"><span class="comment">// 如果找到target,返回相应的索引index</span></span><br><span class="line"><span class="comment">// 如果没有找到target,返回-1</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(T arr[], <span class="keyword">int</span> n, T target)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在arr[l...r]之中查找target</span></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>( l &lt;= r )&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//int mid = (l + r)/2;</span></span><br><span class="line">        <span class="comment">// 防止极端情况下的整形溢出，使用下面的逻辑求出mid</span></span><br><span class="line">        <span class="keyword">int</span> mid = l + (r-l)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( arr[mid] == target )</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( arr[mid] &gt; target )</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用递归的方式写二分查找法</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> __binarySearch2(T arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r, T target)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( l &gt; r )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//int mid = (l+r)/2;</span></span><br><span class="line">    <span class="comment">// 防止极端情况下的整形溢出，使用下面的逻辑求出mid</span></span><br><span class="line">    <span class="keyword">int</span> mid = l + (r-l)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( arr[mid] == target )</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( arr[mid] &gt; target )</span><br><span class="line">        <span class="keyword">return</span> __binarySearch2(arr, l, mid<span class="number">-1</span>, target);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> __binarySearch2(arr, mid+<span class="number">1</span>, r, target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch2</span><span class="params">(T arr[], <span class="keyword">int</span> n, T target)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> __binarySearch2( arr , <span class="number">0</span> , n<span class="number">-1</span>, target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较非递归和递归写法的二分查找的效率</span></span><br><span class="line"><span class="comment">// 非递归算法在性能上有微弱优势</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">1000000</span>;</span><br><span class="line">    <span class="keyword">int</span>* a = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++ )</span><br><span class="line">        a[i] = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试非递归二分查找法</span></span><br><span class="line">    <span class="keyword">clock_t</span> startTime = clock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于我们的待查找数组[0...N)</span></span><br><span class="line">    <span class="comment">// 对[0...N)区间的数值使用二分查找，最终结果应该就是数字本身</span></span><br><span class="line">    <span class="comment">// 对[N...2*N)区间的数值使用二分查找，因为这些数字不在arr中，结果为-1</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">2</span>*n ; i ++ )&#123;</span><br><span class="line">        <span class="keyword">int</span> v = binarySearch(a, n, i);</span><br><span class="line">        <span class="keyword">if</span>( i &lt; n )</span><br><span class="line">            assert( v == i );</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            assert( v == <span class="number">-1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">clock_t</span> endTime = clock();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Binary Search (Without Recursion): "</span> &lt;&lt; <span class="keyword">double</span>(endTime - startTime) / CLOCKS_PER_SEC &lt;&lt; <span class="string">" s"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试递归的二分查找法</span></span><br><span class="line">    startTime = clock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于我们的待查找数组[0...N)</span></span><br><span class="line">    <span class="comment">// 对[0...N)区间的数值使用二分查找，最终结果应该就是数字本身</span></span><br><span class="line">    <span class="comment">// 对[N...2*N)区间的数值使用二分查找，因为这些数字不在arr中，结果为-1</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">2</span>*n ; i ++ )&#123;</span><br><span class="line">        <span class="keyword">int</span> v = binarySearch2(a, n, i);</span><br><span class="line">        <span class="keyword">if</span>( i &lt; n )</span><br><span class="line">            assert( v == i );</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            assert( v == <span class="number">-1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    endTime = clock();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Binary Search (Recursion): "</span> &lt;&lt; <span class="keyword">double</span>(endTime - startTime) / CLOCKS_PER_SEC &lt;&lt; <span class="string">" s"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-O-n-2"><a href="#1-O-n-2" class="headerlink" title="1 O(n)2"></a>1 O(n)2</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++)&#123;</span><br><span class="line">    <span class="comment">// 寻找[i, n)区间里的最小值</span></span><br><span class="line">    <span class="keyword">int</span> minIndex = i;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> j = i + <span class="number">1</span> ; j &lt; n ; j ++ )</span><br><span class="line">        <span class="keyword">if</span>( arr[j] &lt; arr[minIndex] )</span><br><span class="line">            minIndex = j;</span><br><span class="line"></span><br><span class="line">    swap( arr[i] , arr[minIndex] );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-二分搜索树"><a href="#2-二分搜索树" class="headerlink" title="2 二分搜索树"></a>2 二分搜索树</h4><p>树适用于解决递归问题。<br><img src="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91/1.png" alt="二分搜索树1"> </p><figure class="image-box">                <img src="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91/2.png" alt="二分搜索树2" title class>                <p>二分搜索树2</p>            </figure>  <p>二分搜索树不一定是完全二叉树。<br>包括插入、查找、遍历、删除<br>前序遍历、中序遍历、后序遍历、层序遍历（使用队列）。</p><figure class="image-box">                <img src="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91/3.png" alt="删除节点" title class>                <p>删除节点</p>            </figure>  <p>删除节点的两边都有节点时，使用右节点二叉树的最小值代替该节点。</p><p>二分搜索树的局限性：同样的数据可能对应不同的树，树可能层数很高，退化为链表，但不如链表效率高。可以通过平衡二叉树解决。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分搜索树</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BST</span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 树中的节点为私有的结构体, 外界不需要了解二分搜索树节点的具体实现</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">        Key key;</span><br><span class="line">        Value value;</span><br><span class="line">        Node *left;</span><br><span class="line">        Node *right;</span><br><span class="line"></span><br><span class="line">        Node(Key key, Value value)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;key = key;</span><br><span class="line">            <span class="keyword">this</span>-&gt;value = value;</span><br><span class="line">            <span class="keyword">this</span>-&gt;left = <span class="keyword">this</span>-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node(Node *node)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;key = node-&gt;key;</span><br><span class="line">            <span class="keyword">this</span>-&gt;value = node-&gt;value;</span><br><span class="line">            <span class="keyword">this</span>-&gt;left = node-&gt;left;</span><br><span class="line">            <span class="keyword">this</span>-&gt;right = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Node *root; <span class="comment">// 根节点</span></span><br><span class="line">    <span class="keyword">int</span> count;  <span class="comment">// 树中的节点个数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数, 默认构造一棵空二分搜索树</span></span><br><span class="line">    BST()&#123;</span><br><span class="line">        root = <span class="literal">NULL</span>;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数, 释放二分搜索树的所有空间</span></span><br><span class="line">    ~BST()&#123;</span><br><span class="line">        destroy( root );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回二分搜索树的节点个数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回二分搜索树是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向二分搜索树中插入一个新的(key, value)数据对</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Key key, Value value)</span></span>&#123;</span><br><span class="line">        root = insert(root, key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看二分搜索树中是否存在键key</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">contain</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> contain(root, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在二分搜索树中搜索键key所对应的值。如果这个值不存在, 则返回NULL</span></span><br><span class="line">    <span class="function">Value* <span class="title">search</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> search( root , key );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二分搜索树的前序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        preOrder(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二分搜索树的中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        inOrder(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二分搜索树的后序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        postOrder(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二分搜索树的层序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span>&lt;Node*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>( !q.empty() )&#123;</span><br><span class="line"></span><br><span class="line">            Node *node = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line"></span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;node-&gt;key&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( node-&gt;left )</span><br><span class="line">                q.push( node-&gt;left );</span><br><span class="line">            <span class="keyword">if</span>( node-&gt;right )</span><br><span class="line">                q.push( node-&gt;right );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找二分搜索树的最小的键值</span></span><br><span class="line">    <span class="function">Key <span class="title">minimum</span><span class="params">()</span></span>&#123;</span><br><span class="line">        assert( count != <span class="number">0</span> );</span><br><span class="line">        Node* minNode = minimum( root );</span><br><span class="line">        <span class="keyword">return</span> minNode-&gt;key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找二分搜索树的最大的键值</span></span><br><span class="line">    <span class="function">Key <span class="title">maximum</span><span class="params">()</span></span>&#123;</span><br><span class="line">        assert( count != <span class="number">0</span> );</span><br><span class="line">        Node* maxNode = maximum(root);</span><br><span class="line">        <span class="keyword">return</span> maxNode-&gt;key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从二分搜索树中删除最小值所在节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeMin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( root )</span><br><span class="line">            root = removeMin( root );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从二分搜索树中删除最大值所在节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( root )</span><br><span class="line">            root = removeMax( root );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从二分搜索树中删除键值为key的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        root = <span class="built_in">remove</span>(root, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 向以node为根的二分搜索树中, 插入节点(key, value), 使用递归算法</span></span><br><span class="line">    <span class="comment">// 返回插入新节点后的二分搜索树的根</span></span><br><span class="line">    <span class="function">Node* <span class="title">insert</span><span class="params">(Node *node, Key key, Value value)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( node == <span class="literal">NULL</span> )&#123;</span><br><span class="line">            count ++;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Node(key, value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( key == node-&gt;key )</span><br><span class="line">            node-&gt;value = value;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( key &lt; node-&gt;key )</span><br><span class="line">            node-&gt;left = insert( node-&gt;left , key, value);</span><br><span class="line">        <span class="keyword">else</span>    <span class="comment">// key &gt; node-&gt;key</span></span><br><span class="line">            node-&gt;right = insert( node-&gt;right, key, value);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看以node为根的二分搜索树中是否包含键值为key的节点, 使用递归算法</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">contain</span><span class="params">(Node* node, Key key)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( node == <span class="literal">NULL</span> )</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( key == node-&gt;key )</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( key &lt; node-&gt;key )</span><br><span class="line">            <span class="keyword">return</span> contain( node-&gt;left , key );</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// key &gt; node-&gt;key</span></span><br><span class="line">            <span class="keyword">return</span> contain( node-&gt;right , key );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在以node为根的二分搜索树中查找key所对应的value, 递归算法</span></span><br><span class="line">    <span class="comment">// 若value不存在, 则返回NULL</span></span><br><span class="line">    <span class="function">Value* <span class="title">search</span><span class="params">(Node* node, Key key)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( node == <span class="literal">NULL</span> )</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( key == node-&gt;key )</span><br><span class="line">            <span class="keyword">return</span> &amp;(node-&gt;value);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( key &lt; node-&gt;key )</span><br><span class="line">            <span class="keyword">return</span> search( node-&gt;left , key );</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// key &gt; node-&gt;key</span></span><br><span class="line">            <span class="keyword">return</span> search( node-&gt;right, key );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对以node为根的二分搜索树进行前序遍历, 递归算法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node* node)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( node != <span class="literal">NULL</span> )&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;node-&gt;key&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            preOrder(node-&gt;left);</span><br><span class="line">            preOrder(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对以node为根的二分搜索树进行中序遍历, 递归算法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node* node)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( node != <span class="literal">NULL</span> )&#123;</span><br><span class="line">            inOrder(node-&gt;left);</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;node-&gt;key&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            inOrder(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对以node为根的二分搜索树进行后序遍历, 递归算法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Node* node)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( node != <span class="literal">NULL</span> )&#123;</span><br><span class="line">            postOrder(node-&gt;left);</span><br><span class="line">            postOrder(node-&gt;right);</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;node-&gt;key&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放以node为根的二分搜索树的所有节点</span></span><br><span class="line">    <span class="comment">// 采用后续遍历的递归算法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(Node* node)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( node != <span class="literal">NULL</span> )&#123;</span><br><span class="line">            destroy( node-&gt;left );</span><br><span class="line">            destroy( node-&gt;right );</span><br><span class="line"></span><br><span class="line">            <span class="keyword">delete</span> node;</span><br><span class="line">            count --;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回以node为根的二分搜索树的最小键值所在的节点, 递归算法</span></span><br><span class="line">    <span class="function">Node* <span class="title">minimum</span><span class="params">(Node* node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( node-&gt;left == <span class="literal">NULL</span> )</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> minimum(node-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回以node为根的二分搜索树的最大键值所在的节点, 递归算法</span></span><br><span class="line">    <span class="function">Node* <span class="title">maximum</span><span class="params">(Node* node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( node-&gt;right == <span class="literal">NULL</span> )</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maximum(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除掉以node为根的二分搜索树中的最小节点, 递归算法</span></span><br><span class="line">    <span class="comment">// 返回删除节点后新的二分搜索树的根</span></span><br><span class="line">    <span class="function">Node* <span class="title">removeMin</span><span class="params">(Node* node)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( node-&gt;left == <span class="literal">NULL</span> )&#123;</span><br><span class="line"></span><br><span class="line">            Node* rightNode = node-&gt;right;</span><br><span class="line">            <span class="keyword">delete</span> node;</span><br><span class="line">            count --;</span><br><span class="line">            <span class="keyword">return</span> rightNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node-&gt;left = removeMin(node-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除掉以node为根的二分搜索树中的最大节点, 递归算法</span></span><br><span class="line">    <span class="comment">// 返回删除节点后新的二分搜索树的根</span></span><br><span class="line">    <span class="function">Node* <span class="title">removeMax</span><span class="params">(Node* node)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( node-&gt;right == <span class="literal">NULL</span> )&#123;</span><br><span class="line"></span><br><span class="line">            Node* leftNode = node-&gt;left;</span><br><span class="line">            <span class="keyword">delete</span> node;</span><br><span class="line">            count --;</span><br><span class="line">            <span class="keyword">return</span> leftNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node-&gt;right = removeMax(node-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除掉以node为根的二分搜索树中键值为key的节点, 递归算法</span></span><br><span class="line">    <span class="comment">// 返回删除节点后新的二分搜索树的根</span></span><br><span class="line">    <span class="function">Node* <span class="title">remove</span><span class="params">(Node* node, Key key)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( node == <span class="literal">NULL</span> )</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( key &lt; node-&gt;key )&#123;</span><br><span class="line">            node-&gt;left = <span class="built_in">remove</span>( node-&gt;left , key );</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( key &gt; node-&gt;key )&#123;</span><br><span class="line">            node-&gt;right = <span class="built_in">remove</span>( node-&gt;right, key );</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;   <span class="comment">// key == node-&gt;key</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 待删除节点左子树为空的情况</span></span><br><span class="line">            <span class="keyword">if</span>( node-&gt;left == <span class="literal">NULL</span> )&#123;</span><br><span class="line">                Node *rightNode = node-&gt;right;</span><br><span class="line">                <span class="keyword">delete</span> node;</span><br><span class="line">                count --;</span><br><span class="line">                <span class="keyword">return</span> rightNode;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 待删除节点右子树为空的情况</span></span><br><span class="line">            <span class="keyword">if</span>( node-&gt;right == <span class="literal">NULL</span> )&#123;</span><br><span class="line">                Node *leftNode = node-&gt;left;</span><br><span class="line">                <span class="keyword">delete</span> node;</span><br><span class="line">                count--;</span><br><span class="line">                <span class="keyword">return</span> leftNode;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 待删除节点左右子树均不为空的情况</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 找到比待删除节点大的最小节点, 即待删除节点右子树的最小节点</span></span><br><span class="line">            <span class="comment">// 用这个节点顶替待删除节点的位置</span></span><br><span class="line">            Node *successor = <span class="keyword">new</span> Node(minimum(node-&gt;right));</span><br><span class="line">            count ++;</span><br><span class="line"></span><br><span class="line">            successor-&gt;right = removeMin(node-&gt;right);</span><br><span class="line">            successor-&gt;left = node-&gt;left;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">delete</span> node;</span><br><span class="line">            count --;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> successor;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shuffle</span><span class="params">( <span class="keyword">int</span> arr[], <span class="keyword">int</span> n )</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    srand( time(<span class="literal">NULL</span>) );</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = n<span class="number">-1</span> ; i &gt;= <span class="number">0</span> ; i -- )&#123;</span><br><span class="line">        <span class="keyword">int</span> x = rand()%(i+<span class="number">1</span>);</span><br><span class="line">        swap( arr[i] , arr[x] );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试 remove</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    BST&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; bst = BST&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取n个取值范围在[0...n)的随机整数放进二分搜索树中</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++ )&#123;</span><br><span class="line">        <span class="keyword">int</span> key = rand()%n;</span><br><span class="line">        <span class="comment">// 为了后续测试方便,这里value值取和key值一样</span></span><br><span class="line">        <span class="keyword">int</span> value = key;</span><br><span class="line">        bst.insert(key,value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意, 由于随机生成的数据有重复, 所以bst中的数据数量大概率是小于n的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// order数组中存放[0...n)的所有元素</span></span><br><span class="line">    <span class="keyword">int</span> order[n];</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++ )</span><br><span class="line">        order[i] = i;</span><br><span class="line">    <span class="comment">// 打乱order数组的顺序</span></span><br><span class="line">    shuffle( order , n );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 乱序删除[0...n)范围里的所有元素</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++ )</span><br><span class="line">        <span class="keyword">if</span>( bst.contain( order[i] ))&#123;</span><br><span class="line">            bst.<span class="built_in">remove</span>( order[i] );</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"After remove "</span>&lt;&lt;order[i]&lt;&lt;<span class="string">" size = "</span>&lt;&lt;bst.<span class="built_in">size</span>()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最终整个二分搜索树应该为空</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; bst.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
            <tag> 算法与数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构课程笔记</title>
      <link href="/2020/02/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/02/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h3><h4 id="1-最大子列和问题"><a href="#1-最大子列和问题" class="headerlink" title="1 最大子列和问题"></a>1 最大子列和问题</h4><p>给定K个整数组成的序列{ N1, N2, …, NK }，“连续子列”被定义为{ Ni, Ni+1, …, Nj }，其中 1≤i≤j≤K。“最大子列和”则被定义为所有连续子列元素的和中最大者。例如给定序列{ -2, 11, -4, 13, -5, -2 }，其连续子列{ 11, -4, 13 }有最大的和20。现要求你编写程序，计算给定整数序列的最大子列和。</p><p>输入格式:<br>输入第1行给出正整数K (≤100000)；第2行给出K个整数，其间以空格分隔。<br>输入样例：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">-2</span> <span class="number">11</span> <span class="number">-4</span> <span class="number">13</span> <span class="number">-5</span> <span class="number">-2</span></span><br></pre></td></tr></table></figure><p>输出格式:<br>在一行中输出最大子列和。如果序列中所有整数皆为负数，则输出0。<br>输出样例：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result=<span class="number">0</span>,thissum=<span class="number">0</span>,N,digit;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;N);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;digit);</span><br><span class="line">        thissum+=digit;</span><br><span class="line">        <span class="keyword">if</span>(thissum&gt;result)</span><br><span class="line">            result=thissum;</span><br><span class="line">        <span class="keyword">if</span>(thissum&lt;<span class="number">0</span>)   thissum=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-最大子列和问题"><a href="#2-最大子列和问题" class="headerlink" title="2 最大子列和问题"></a>2 最大子列和问题</h4><p>给定K个整数组成的序列{ N1, N2, …, NK }，“连续子列”被定义为{ Ni, Ni+1, …, Nj }，其中 1≤i≤j≤K。“最大子列和”则被定义为所有连续子列元素的和中最大者。例如给定序列{ -2, 11, -4, 13, -5, -2 }，其连续子列{ 11, -4, 13 }有最大的和20。现要求你编写程序，计算给定整数序列的最大子列和，并输出整个序列的第一个和最后一个数。</p><p>输入格式:<br>输入第1行给出正整数K (≤100000)；第2行给出K个整数，其间以空格分隔。<br>输入样例：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">-10</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">-5</span> <span class="number">-23</span> <span class="number">3</span> <span class="number">7</span> <span class="number">-21</span></span><br></pre></td></tr></table></figure><p>输出格式:<br>对于每个测试用例，在一行中输出最大和，以及最大子序列的第一个和最后一个数字。数字必须用一个空格隔开，但行尾不能有多余的空格。如果最大子序列不唯一，则输出索引i和j最小的子序列（如示例所示）。如果所有K个数都是负数，那么它的最大和被定义为0，你应该输出整个序列的第一个和最后一个数。<br>输出样例：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> <span class="number">1</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>, thissum = <span class="number">0</span>, N, digit, startnew = <span class="number">0</span>, start = <span class="number">0</span>, <span class="built_in">end</span>, trigger = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N)) &#123;&#125;;</span><br><span class="line">    <span class="built_in">end</span> = N <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;digit)) &#123;&#125;;</span><br><span class="line">        thissum += digit;</span><br><span class="line">        <span class="keyword">if</span> (thissum &gt; result) &#123;</span><br><span class="line">            <span class="keyword">if</span> (trigger == <span class="number">1</span>) &#123;</span><br><span class="line">                trigger = <span class="number">0</span>;</span><br><span class="line">                start = digit;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">end</span> = digit;</span><br><span class="line">            result = thissum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (thissum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            trigger = <span class="number">1</span>;</span><br><span class="line">            thissum = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>, result, start, <span class="built_in">end</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第二章-线性结构"><a href="#第二章-线性结构" class="headerlink" title="第二章 线性结构"></a>第二章 线性结构</h3><h4 id="1-一元多项式的乘法与加法运算"><a href="#1-一元多项式的乘法与加法运算" class="headerlink" title="1 一元多项式的乘法与加法运算"></a>1 一元多项式的乘法与加法运算</h4><p>设计函数分别求两个一元多项式的乘积与和。</p><p>输入格式:<br>输入分2行，每行分别先给出多项式非零项的个数，再以指数递降方式输入一个多项式非零项系数和指数（绝对值均为不超过1000的整数）。数字间以空格分隔。<br>输入样例：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">3</span> <span class="number">4</span> <span class="number">-5</span> <span class="number">2</span>  <span class="number">6</span> <span class="number">1</span>  <span class="number">-2</span> <span class="number">0</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">20</span>  <span class="number">-7</span> <span class="number">4</span>  <span class="number">3</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>输出格式:<br>输出分2行，分别以指数递降方式输出乘积多项式以及和多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。零多项式应输出0 0。<br>输出样例：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">15</span> <span class="number">24</span> <span class="number">-25</span> <span class="number">22</span> <span class="number">30</span> <span class="number">21</span> <span class="number">-10</span> <span class="number">20</span> <span class="number">-21</span> <span class="number">8</span> <span class="number">35</span> <span class="number">6</span> <span class="number">-33</span> <span class="number">5</span> <span class="number">14</span> <span class="number">4</span> <span class="number">-15</span> <span class="number">3</span> <span class="number">18</span> <span class="number">2</span> <span class="number">-6</span> <span class="number">1</span></span><br><span class="line"><span class="number">5</span> <span class="number">20</span> <span class="number">-4</span> <span class="number">4</span> <span class="number">-5</span> <span class="number">2</span> <span class="number">9</span> <span class="number">1</span> <span class="number">-2</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PolyNode</span> *<span class="title">Polynomial</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PolyNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> coef;</span><br><span class="line">    <span class="keyword">int</span> expon;</span><br><span class="line">    Polynomial link;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Attach</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> e, Polynomial* pRear)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Polynomial P;</span><br><span class="line"></span><br><span class="line">    P = (Polynomial)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct PolyNode));</span><br><span class="line">    P-&gt;coef = c;</span><br><span class="line">    P-&gt;expon = e;</span><br><span class="line">    P-&gt;link = <span class="literal">NULL</span>;</span><br><span class="line">    (*pRear)-&gt;link = P;</span><br><span class="line">    *pRear = P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Polynomial <span class="title">ReadPoly</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Polynomial P, Rear, t;</span><br><span class="line">    <span class="keyword">int</span> c, e, N;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">    P = (Polynomial)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct PolyNode)); <span class="comment">//表头空结点</span></span><br><span class="line">    P-&gt;link = <span class="literal">NULL</span>;</span><br><span class="line">    Rear = P;</span><br><span class="line">    <span class="keyword">while</span> (N--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;c, &amp;e);</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="number">0</span>)       </span><br><span class="line">            Attach(c, e, &amp;Rear);    <span class="comment">//当前项插入尾部</span></span><br><span class="line">    &#125;</span><br><span class="line">    t = P; P = P-&gt;link; <span class="built_in">free</span>(t);  <span class="comment">//删除临时头结点</span></span><br><span class="line">    <span class="keyword">return</span> P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Compare</span><span class="params">(<span class="keyword">int</span> e1, <span class="keyword">int</span> e2)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/*比较两项指数e1和e2，根据大、小、等三种情况分别返回1，-1，0 */</span></span><br><span class="line">    <span class="keyword">if</span> (e1 &gt; e2) <span class="keyword">return</span> <span class="number">1</span>;       <span class="comment">/* e1大，返回1       */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (e1 &lt; e2) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">/* e2大，返回-1      */</span></span><br><span class="line">    <span class="keyword">else</span>  <span class="keyword">return</span> <span class="number">0</span>;                <span class="comment">/* e1和e2相等，返回0 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Polynomial <span class="title">Add</span><span class="params">(Polynomial P1, Polynomial P2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Polynomial front, rear, temp;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    rear = (Polynomial)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct PolyNode));</span><br><span class="line">    front = rear;</span><br><span class="line">    <span class="keyword">while</span> (P1 &amp;&amp; P2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (Compare(P1-&gt;expon, P2-&gt;expon))</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            Attach(P1-&gt;coef, P1-&gt;expon, &amp;rear);</span><br><span class="line">            P1 = P1-&gt;link;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">            Attach(P2-&gt;coef, P2-&gt;expon, &amp;rear);</span><br><span class="line">            P2 = P2-&gt;link;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            sum = P1-&gt;coef + P2-&gt;coef;</span><br><span class="line">            <span class="keyword">if</span> (sum) Attach(sum, P1-&gt;expon, &amp;rear);</span><br><span class="line">            P1 = P1-&gt;link;</span><br><span class="line">            P2 = P2-&gt;link;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; P1; P1 = P1-&gt;link) Attach(P1-&gt;coef, P1-&gt;expon, &amp;rear);</span><br><span class="line">    <span class="keyword">for</span> (; P2; P2 = P2-&gt;link) Attach(P2-&gt;coef, P2-&gt;expon, &amp;rear);</span><br><span class="line">    rear-&gt;link = <span class="literal">NULL</span>;</span><br><span class="line">    temp = front;</span><br><span class="line">    front = front-&gt;link;</span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">    <span class="keyword">return</span> front;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Polynomial <span class="title">Mult</span><span class="params">(Polynomial P1, Polynomial P2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Polynomial P, Rear, t1, t2, t;</span><br><span class="line">    <span class="keyword">int</span> c, e;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!P1 || !P2) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    t1 = P1; t2 = P2;</span><br><span class="line">    P = (Polynomial)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct PolyNode)); P-&gt;link = <span class="literal">NULL</span>;</span><br><span class="line">    Rear = P;</span><br><span class="line">    <span class="keyword">while</span> (t2)   <span class="comment">//先使用P1第一项乘P2得到初始链表</span></span><br><span class="line">    &#123;</span><br><span class="line">        Attach(t1-&gt;coef * t2-&gt;coef, t1-&gt;expon + t2-&gt;expon, &amp;Rear);</span><br><span class="line">        t2 = t2-&gt;link;</span><br><span class="line">    &#125;</span><br><span class="line">    t1 = t1-&gt;link;</span><br><span class="line">    <span class="keyword">while</span> (t1)</span><br><span class="line">    &#123;</span><br><span class="line">        t2 = P2; Rear = P;</span><br><span class="line">        <span class="keyword">while</span> (t2)</span><br><span class="line">        &#123;</span><br><span class="line">            e = t1-&gt;expon + t2-&gt;expon;</span><br><span class="line">            c = t1-&gt;coef * t2-&gt;coef;</span><br><span class="line">            <span class="keyword">while</span> (Rear-&gt;link &amp;&amp; Rear-&gt;link-&gt;expon &gt; e)</span><br><span class="line">                Rear = Rear-&gt;link;</span><br><span class="line">            <span class="keyword">if</span> (Rear-&gt;link &amp;&amp; Rear-&gt;link-&gt;expon == e)  <span class="comment">//与下一个相等</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (Rear-&gt;link-&gt;coef + c)</span><br><span class="line">                    Rear-&gt;link-&gt;coef += c;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    t = Rear-&gt;link;</span><br><span class="line">                    Rear-&gt;link = t-&gt;link;</span><br><span class="line">                    <span class="built_in">free</span>(t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>                                <span class="comment">//比下一个大</span></span><br><span class="line">            &#123;</span><br><span class="line">                t = (Polynomial)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct PolyNode));</span><br><span class="line">                t-&gt;coef = c; t-&gt;expon = e; t-&gt;link = Rear-&gt;link;</span><br><span class="line">                Rear-&gt;link = t; Rear = Rear-&gt;link;</span><br><span class="line">            &#125;</span><br><span class="line">            t2 = t2-&gt;link;</span><br><span class="line">        &#125;</span><br><span class="line">        t1 = t1-&gt;link;</span><br><span class="line">    &#125;</span><br><span class="line">    t2 = P; P = P-&gt;link; <span class="built_in">free</span>(t2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintPoly</span><span class="params">(Polynomial P)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c, e, flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!P) &#123; <span class="built_in">printf</span>(<span class="string">"0 0"</span>); <span class="keyword">return</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (P)</span><br><span class="line">    &#123;</span><br><span class="line">        c = P-&gt;coef; e = P-&gt;expon;</span><br><span class="line">        <span class="keyword">if</span> (!flag)</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d"</span>, c, e);</span><br><span class="line">        P = P-&gt;link;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Polynomial P1, P2, PP, PS;</span><br><span class="line"></span><br><span class="line">    P1 = ReadPoly();</span><br><span class="line">    P2 = ReadPoly();</span><br><span class="line">    PP = Mult(P1, P2);</span><br><span class="line">    PrintPoly(PP);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    PS = Add(P1, P2);</span><br><span class="line">    PrintPoly(PS);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-两个有序链表序列的合并"><a href="#2-两个有序链表序列的合并" class="headerlink" title="2 两个有序链表序列的合并"></a>2 两个有序链表序列的合并</h4><p>本题要求实现一个函数，将两个链表表示的递增整数序列合并为一个非递减的整数序列。<br>L1和L2是给定的带头结点的单链表，其结点存储的数据是递增有序的；函数Merge要将L1和L2合并为一个非递减的整数序列。应直接使用原序列中的结点，返回归并后的带头结点的链表头指针。</p><p>输入样例：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">6</span> <span class="number">8</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><p>输出样例：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">8</span> <span class="number">10</span> </span><br><span class="line"><span class="literal">NULL</span></span><br><span class="line"><span class="literal">NULL</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">PtrToNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    PtrToNode   Next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToNode List;</span><br><span class="line"></span><br><span class="line"><span class="function">List <span class="title">Read</span><span class="params">()</span></span>; <span class="comment">/* 细节在此不表 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(List L)</span></span>; <span class="comment">/* 细节在此不表；空链表将输出NULL */</span></span><br><span class="line"></span><br><span class="line"><span class="function">List <span class="title">Merge</span><span class="params">(List L1, List L2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List L1, L2, L;</span><br><span class="line">    L1 = Read();</span><br><span class="line">    L2 = Read();</span><br><span class="line">    L = Merge(L1, L2);</span><br><span class="line">    Print(L);</span><br><span class="line">    Print(L1);</span><br><span class="line">    Print(L2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Attach</span><span class="params">(<span class="keyword">int</span> d, List* pRear)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List P;</span><br><span class="line"></span><br><span class="line">    P = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Node));</span><br><span class="line">    P-&gt;Data = d;</span><br><span class="line">    P-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    (*pRear)-&gt;Next = P;</span><br><span class="line">    *pRear = P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">List <span class="title">Merge</span><span class="params">(List L1, List L2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List temp1 = L1-&gt;Next;</span><br><span class="line">    List temp2 = L2-&gt;Next;</span><br><span class="line">    List p;</span><br><span class="line">    p = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Node));</span><br><span class="line">    p-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    List temp = p;</span><br><span class="line">    <span class="keyword">while</span> (temp1 &amp;&amp; temp2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (temp1-&gt;Data &lt; temp2-&gt;Data) &#123;</span><br><span class="line">            temp-&gt;Next = temp1;</span><br><span class="line">            temp1 = temp1-&gt;Next;</span><br><span class="line">            temp = temp-&gt;Next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            temp-&gt;Next = temp2;</span><br><span class="line">            temp2 = temp2-&gt;Next;</span><br><span class="line">            temp = temp-&gt;Next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (temp1 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        temp-&gt;Next = temp1;</span><br><span class="line">        temp1 = temp1-&gt;Next;</span><br><span class="line">        temp = temp-&gt;Next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (temp2 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        temp-&gt;Next = temp2;</span><br><span class="line">        temp2 = temp2-&gt;Next;</span><br><span class="line">        temp = temp-&gt;Next;</span><br><span class="line">    &#125;</span><br><span class="line">    L1-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    L2-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    temp-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">List <span class="title">Read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List P, Rear, t;</span><br><span class="line">    <span class="keyword">int</span> d, N;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">    P = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Node)); <span class="comment">//表头空结点</span></span><br><span class="line">    P-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    Rear = P;</span><br><span class="line">    <span class="keyword">while</span> (N--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;d);</span><br><span class="line">        Attach(d, &amp;Rear);    <span class="comment">//当前项插入尾部</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(List L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L-&gt;Next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"NULL\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    List temp = L-&gt;Next;</span><br><span class="line">    <span class="keyword">while</span> (temp) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, temp-&gt;Data);</span><br><span class="line">        temp = temp-&gt;Next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-Pop-Sequence"><a href="#3-Pop-Sequence" class="headerlink" title="3 Pop Sequence"></a>3 Pop Sequence</h4><p>给定一个最多能保存M个数的堆栈。按1，2，3，…，N的顺序推N个数字，然后随机弹出。您应该知道给定的数字序列是否可能是堆栈的弹出序列。例如，如果M是5，N是7，我们可以从堆栈中获得1，2，3，4，5，6，7，但不能从3，2，1，7，5，6，4。</p><p>输入格式:<br>每个输入文件包含一个测试用例。对于每种情况，第一行包含3个数字（都不超过1000）：M（堆栈的最大容量）、N（推送序列的长度）和K（要检查的pop序列的数量）。接下来是K行，每行包含N个数字的pop序列。一行中的所有数字都用空格隔开。<br>输入样例：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">7</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">7</span> <span class="number">5</span> <span class="number">6</span> <span class="number">4</span></span><br><span class="line"><span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">5</span> <span class="number">6</span> <span class="number">4</span> <span class="number">3</span> <span class="number">7</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p>输出格式:<br>对于每个弹出序列，如果确实是堆栈的可能弹出序列，则在一行中打印“YES”，如果不是，则打印“NO”。<br>输出样例：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">YES</span><br><span class="line">NO</span><br><span class="line">NO</span><br><span class="line">YES</span><br><span class="line">NO</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, m, n, k, a[<span class="number">1000</span>][<span class="number">1000</span>], b[<span class="number">1000</span>], <span class="built_in">stack</span>[<span class="number">1000</span>], stack_index, top;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;m, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)    <span class="comment">//读取每一行</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i][j]);                   </span><br><span class="line">        &#125;</span><br><span class="line">        stack_index = <span class="number">1</span>;      <span class="comment">//模拟栈</span></span><br><span class="line">        top = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">stack</span>[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (a[i][j] &gt; top)</span><br><span class="line">            &#123;</span><br><span class="line">                stack_index++;</span><br><span class="line">                top++;</span><br><span class="line">                <span class="built_in">stack</span>[stack_index] = top;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (stack_index &gt; m || a[i][j] &lt; <span class="built_in">stack</span>[stack_index])</span><br><span class="line">            &#123;</span><br><span class="line">                b[i] = <span class="number">0</span>;       <span class="comment">//无法实现栈则结果为0，退出</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a[i][j] == <span class="built_in">stack</span>[stack_index])</span><br><span class="line">            &#123;</span><br><span class="line">                stack_index--;</span><br><span class="line">                <span class="comment">//top = stack[stack_index];</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stack_index == <span class="number">0</span>)   <span class="comment">//成功实现栈则结果为1</span></span><br><span class="line">            b[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b[i] == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"NO"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (b[i] == <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"YES"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第三章-树结构（上）"><a href="#第三章-树结构（上）" class="headerlink" title="第三章 树结构（上）"></a>第三章 树结构（上）</h3><h4 id="1-树的同构"><a href="#1-树的同构" class="headerlink" title="1 树的同构"></a>1 树的同构</h4><p>给定两棵树T1和T2。如果T1可以通过若干次左右孩子互换就变成T2，则我们称两棵树是“同构”的。例如图1给出的两棵树就是同构的，因为我们把其中一棵树的结点A、B、G的左右孩子互换后，就得到另外一棵树。而图2就不是同构的。</p><figure class="image-box">                <img src="/2020/02/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/1.png" alt="1" title class>                <p>1</p>            </figure>  <p>图1<br><img src="/2020/02/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/2.png" alt="2"><br>图2<br>输入格式:<br>输入给出2棵二叉树树的信息。对于每棵树，首先在一行中给出一个非负整数N (≤10)，即该树的结点数（此时假设结点从0到N−1编号）；随后N行，第i行对应编号第i个结点，给出该结点中存储的1个英文大写字母、其左孩子结点的编号、右孩子结点的编号。如果孩子结点为空，则在相应位置上给出“-”。给出的数据间用一个空格分隔。注意：题目保证每个结点中存储的字母是不同的。  </p><p>输出格式:<br>如果两棵树是同构的，输出“Yes”，否则输出“No”。</p><p>输入样例1（对应图1）：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span></span><br><span class="line">A <span class="number">1</span> <span class="number">2</span></span><br><span class="line">B <span class="number">3</span> <span class="number">4</span></span><br><span class="line">C <span class="number">5</span> -</span><br><span class="line">D - -</span><br><span class="line">E <span class="number">6</span> -</span><br><span class="line">G <span class="number">7</span> -</span><br><span class="line">F - -</span><br><span class="line">H - -</span><br><span class="line"><span class="number">8</span></span><br><span class="line">G - <span class="number">4</span></span><br><span class="line">B <span class="number">7</span> <span class="number">6</span></span><br><span class="line">F - -</span><br><span class="line">A <span class="number">5</span> <span class="number">1</span></span><br><span class="line">H - -</span><br><span class="line">C <span class="number">0</span> -</span><br><span class="line">D - -</span><br><span class="line">E <span class="number">2</span> -</span><br></pre></td></tr></table></figure><p>输出样例1（对应图1）：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br></pre></td></tr></table></figure><p>输入样例2（对应图2）：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span></span><br><span class="line">B <span class="number">5</span> <span class="number">7</span></span><br><span class="line">F - -</span><br><span class="line">A <span class="number">0</span> <span class="number">3</span></span><br><span class="line">C <span class="number">6</span> -</span><br><span class="line">H - -</span><br><span class="line">D - -</span><br><span class="line">G <span class="number">4</span> -</span><br><span class="line">E <span class="number">1</span> -</span><br><span class="line"><span class="number">8</span></span><br><span class="line">D <span class="number">6</span> -</span><br><span class="line">B <span class="number">5</span> -</span><br><span class="line">E - -</span><br><span class="line">H - -</span><br><span class="line">C <span class="number">0</span> <span class="number">2</span></span><br><span class="line">G - <span class="number">3</span></span><br><span class="line">F - -</span><br><span class="line">A <span class="number">1</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p>输出样例2（对应图2）：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    String val;</span><br><span class="line">    <span class="keyword">int</span> left;</span><br><span class="line">    <span class="keyword">int</span> right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> TreeNode[] T1 = <span class="keyword">new</span> TreeNode[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> TreeNode[] T2 = <span class="keyword">new</span> TreeNode[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] check = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> T = scan.nextInt();</span><br><span class="line">        Arrays.fill(check, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T; i++) &#123;</span><br><span class="line">            T1[i] = <span class="keyword">new</span> TreeNode();</span><br><span class="line">            T1[i].val = scan.next();</span><br><span class="line">            String left = scan.next();</span><br><span class="line">            String right = scan.next();</span><br><span class="line">            <span class="keyword">if</span> (left.equals(<span class="string">"-"</span>)) &#123;</span><br><span class="line">                T1[i].left = -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                T1[i].left = Integer.parseInt(left);</span><br><span class="line">                check[Integer.parseInt(left)] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (right.equals(<span class="string">"-"</span>)) &#123;</span><br><span class="line">                T1[i].right = -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                T1[i].right = Integer.parseInt(right);</span><br><span class="line">                check[Integer.parseInt(right)] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> root = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (check[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                root = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        T = scan.nextInt();</span><br><span class="line">        Arrays.fill(check, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T; i++) &#123;</span><br><span class="line">            T2[i] = <span class="keyword">new</span> TreeNode();</span><br><span class="line">            T2[i].val = scan.next();</span><br><span class="line">            String left = scan.next();</span><br><span class="line">            String right = scan.next();</span><br><span class="line">            <span class="keyword">if</span> (left.equals(<span class="string">"-"</span>)) &#123;</span><br><span class="line">                T2[i].left = -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                T2[i].left = Integer.parseInt(left);</span><br><span class="line">                check[Integer.parseInt(left)] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (right.equals(<span class="string">"-"</span>)) &#123;</span><br><span class="line">                T2[i].right = -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                T2[i].right = Integer.parseInt(right);</span><br><span class="line">                check[Integer.parseInt(right)] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> root1 = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (check[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                root1 = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Isomorphic(root, root1) ? <span class="string">"Yes"</span> : <span class="string">"No"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//传递进来root的索引值可以避免数组越界</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">Isomorphic</span><span class="params">(<span class="keyword">int</span> node1, <span class="keyword">int</span> node2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node1 == -<span class="number">1</span> &amp;&amp; node2 == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((node1 == -<span class="number">1</span> &amp;&amp; node2 != -<span class="number">1</span>) || (node1 != -<span class="number">1</span> &amp;&amp; node2 == -<span class="number">1</span>) || (!T1[node1].val.equals(T2[node2].val))) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (T1[node1].left == -<span class="number">1</span> &amp;&amp; T2[node2].left == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Isomorphic(T1[node1].right, T2[node2].right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((T1[node1].left != -<span class="number">1</span> &amp;&amp; T2[node2].left != -<span class="number">1</span>) &amp;&amp; T1[T1[node1].left].val.equals(T2[T2[node2].left].val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> (Isomorphic(T1[node1].left, T2[node2].left) &amp;&amp; Isomorphic(T1[node1].right, T2[node2].right));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Isomorphic(T1[node1].left, T2[node2].right) &amp;&amp; Isomorphic(T1[node1].right, T2[node2].left));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-List-Leaves"><a href="#2-List-Leaves" class="headerlink" title="2 List Leaves"></a>2 List Leaves</h4><p>给定一棵树，您应该按照从上到下，从左到右的顺序列出所有叶子。</p><p>输入格式:<br>每个输入文件包含一个测试用例。对于每种情况，第一行给出一个正整数N（≤ 1 0），这是树中的节点的总数-并且因此节点编号从0到N − 1。然后N行跟随，每行对应一个节点，并给出该节点的左，右子级的索引。如果孩子不存在，将在该位置放置一个“-”。任何一对孩子都用空格隔开。</p><p>输出格式:<br>对于每个测试用例，按从上到下，从左到右的顺序在一行中打印所有叶子的索引。相邻数字之间必须恰好有一个空格，并且在行尾不能有多余的空格。</p><p>输入样例：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">1</span> -</span><br><span class="line">- -</span><br><span class="line"><span class="number">0</span> -</span><br><span class="line"><span class="number">2</span> <span class="number">7</span></span><br><span class="line">- -</span><br><span class="line">- -</span><br><span class="line"><span class="number">5</span> -</span><br><span class="line"><span class="number">4</span> <span class="number">6</span></span><br></pre></td></tr></table></figure><p>输出样例：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">1</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left;</span><br><span class="line">    <span class="keyword">int</span> right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> TreeNode[] tree = <span class="keyword">new</span> TreeNode[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] check = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> T = scan.nextInt();</span><br><span class="line">        Arrays.fill(check, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T; i++) &#123;</span><br><span class="line">            tree[i] = <span class="keyword">new</span> TreeNode();</span><br><span class="line">            String left = scan.next();</span><br><span class="line">            String right = scan.next();</span><br><span class="line">            <span class="keyword">if</span> (left.equals(<span class="string">"-"</span>)) &#123;</span><br><span class="line">                tree[i].left = -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tree[i].left = Integer.parseInt(left);</span><br><span class="line">                check[Integer.parseInt(left)] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (right.equals(<span class="string">"-"</span>)) &#123;</span><br><span class="line">                tree[i].right = -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tree[i].right = Integer.parseInt(right);</span><br><span class="line">                check[Integer.parseInt(right)] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> root = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (check[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                root = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printLeaves(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printLeaves</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tree[node].left != -<span class="number">1</span>) &#123;</span><br><span class="line">            queue.offer(tree[node].left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tree[node].right != -<span class="number">1</span>) &#123;</span><br><span class="line">            queue.offer(tree[node].right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tree[node].left == -<span class="number">1</span> &amp;&amp; tree[node].right == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                System.out.print(<span class="string">" "</span> + node);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                System.out.print(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Object n = queue.poll();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            printLeaves((<span class="keyword">int</span>)n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第四章-树（中）"><a href="#第四章-树（中）" class="headerlink" title="第四章 树（中）"></a>第四章 树（中）</h3><h4 id="1-是否同一棵二叉搜索树"><a href="#1-是否同一棵二叉搜索树" class="headerlink" title="1 是否同一棵二叉搜索树"></a>1 是否同一棵二叉搜索树</h4><p>给定一个插入序列就可以唯一确定一棵二叉搜索树。然而，一棵给定的二叉搜索树却可以由多种不同的插入序列得到。例如分别按照序列{2, 1, 3}和{2, 3, 1}插入初始为空的二叉搜索树，都得到一样的结果。于是对于输入的各种插入序列，你需要判断它们是否能生成一样的二叉搜索树。</p><p>输入格式:</p><p>输入包含若干组测试数据。每组数据的第1行给出两个正整数N (≤10)和L，分别是每个序列插入元素的个数和需要检查的序列个数。第2行给出N个以空格分隔的正整数，作为初始插入序列。最后L行，每行给出N个插入的元素，属于L个需要检查的序列。<br>简单起见，我们保证每个插入序列都是1到N的一个排列。当读到N为0时，标志输入结束，这组数据不要处理。  </p><p>输入样例：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">4</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">4</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><p>输出格式:</p><p>对每一组需要检查的序列，如果其生成的二叉搜索树跟对应的初始序列生成的一样，输出“Yes”，否则输出“No”。  </p><p>输出样例：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">No</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    <span class="keyword">boolean</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> N = scan.nextInt();</span><br><span class="line">        <span class="keyword">while</span> (N != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> L = scan.nextInt();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//以第一行数据创建树</span></span><br><span class="line">            TreeNode root = <span class="keyword">new</span> TreeNode();</span><br><span class="line">            root.val = scan.nextInt();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> val = scan.nextInt();</span><br><span class="line">                root = Insert(root, val);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将后L行数据与第一行对比</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L; i++) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">int</span> val = scan.nextInt();</span><br><span class="line">                <span class="keyword">if</span> (val != root.val) &#123;</span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    root.flag = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; N; j++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> nextVal = scan.nextInt();</span><br><span class="line">                    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                        flag = Check(root, nextVal);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"Yes"</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"No"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                Reset(root);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            N = scan.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//增加节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> TreeNode <span class="title">Insert</span><span class="params">(TreeNode node, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            node = <span class="keyword">new</span> TreeNode();</span><br><span class="line">            node.val = val;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (val &lt; node.val) &#123;</span><br><span class="line">                node.left = Insert(node.left, val);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; node.val) &#123;</span><br><span class="line">                node.right = Insert(node.right, val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查节点是否位置对应相等</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">Check</span><span class="params">(TreeNode node, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node.flag) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val &lt; node.val) &#123;</span><br><span class="line">                <span class="keyword">return</span> Check(node.left, val);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; node.val) &#123;</span><br><span class="line">                <span class="keyword">return</span> Check(node.right, val);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (val == node.val) &#123;</span><br><span class="line">                node.flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//复位树的flag</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Reset</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Reset(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Reset(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        node.flag = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第五章-树（下）"><a href="#第五章-树（下）" class="headerlink" title="第五章 树（下）"></a>第五章 树（下）</h3><h4 id="1-堆中的路径"><a href="#1-堆中的路径" class="headerlink" title="1 堆中的路径"></a>1 堆中的路径</h4><p>将一系列给定数字插入一个初始为空的最小堆H[]。随后对任意给定的下标i，打印从H[i]到根结点的路径。</p><p>输入格式:</p><p>每组测试第1行包含2个正整数N和M(≤1000)，分别是插入元素的个数、以及需要打印的路径条数。下一行给出区间[-10000, 10000]内的N个要被插入一个初始为空的小顶堆的整数。最后一行给出M个下标。</p><p>输入样例：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">3</span></span><br><span class="line"><span class="number">46</span> <span class="number">23</span> <span class="number">26</span> <span class="number">24</span> <span class="number">10</span></span><br><span class="line"><span class="number">5</span> <span class="number">4</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p>输出格式:</p><p>对输入中给出的每个下标i，在一行中输出从H[i]到根结点的路径上的数据。数字间以1个空格分隔，行末不得有多余空格。</p><p>输出样例：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">24</span> <span class="number">23</span> <span class="number">10</span></span><br><span class="line"><span class="number">46</span> <span class="number">23</span> <span class="number">10</span></span><br><span class="line"><span class="number">26</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Heap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] heap;        <span class="comment">/* 存储元素的数组 */</span></span><br><span class="line">    <span class="keyword">int</span> size;          <span class="comment">/* 堆中当前元素个数 */</span></span><br><span class="line">    <span class="keyword">int</span> capacity;      <span class="comment">/* 堆的最大容量 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> N = scan.nextInt();</span><br><span class="line">        <span class="keyword">int</span> M = scan.nextInt();</span><br><span class="line">        Heap minHeap = <span class="keyword">new</span> Heap();</span><br><span class="line">        minHeap.heap = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>];</span><br><span class="line">        minHeap.size = <span class="number">0</span>;</span><br><span class="line">        minHeap.capacity = N;</span><br><span class="line">        minHeap.heap[<span class="number">0</span>] = -<span class="number">20000</span>; <span class="comment">//哨兵</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            minHeap = Insert(minHeap, scan.nextInt());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = scan.nextInt(); index &gt; <span class="number">0</span>; index /= <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (index == <span class="number">1</span>) &#123;</span><br><span class="line">                    System.out.print(minHeap.heap[index]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.print(minHeap.heap[index] + <span class="string">" "</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i != M - <span class="number">1</span>)</span><br><span class="line">                System.out.print(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//增加最小堆节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Heap <span class="title">Insert</span><span class="params">(Heap minHeap, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (minHeap.size &lt; minHeap.capacity) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = ++minHeap.size;</span><br><span class="line">            <span class="keyword">for</span> ( ; minHeap.heap[i / <span class="number">2</span>] &gt; val; i /= <span class="number">2</span>) &#123;</span><br><span class="line">                minHeap.heap[i] = minHeap.heap[i / <span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            minHeap.heap[i] = val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minHeap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第六章-图（上）"><a href="#第六章-图（上）" class="headerlink" title="第六章 图（上）"></a>第六章 图（上）</h3><h4 id="1-列出连通集"><a href="#1-列出连通集" class="headerlink" title="1 列出连通集"></a>1 列出连通集</h4><p>给定一个有N个顶点和E条边的无向图，请用DFS和BFS分别列出其所有的连通集。假设顶点从0到N−1编号。进行搜索时，假设我们总是从编号最小的顶点出发，按编号递增的顺序访问邻接点。</p><p>输入格式:<br>输入第1行给出2个整数N(0&lt;N≤10)和E，分别是图的顶点数和边数。随后E行，每行给出一条边的两个端点。每行中的数字之间用1空格分隔。<br>输入样例：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span> <span class="number">6</span></span><br><span class="line"><span class="number">0</span> <span class="number">7</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">0</span></span><br><span class="line"><span class="number">4</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p>输出格式:<br>按照”{ v1 v2 … vk }”的格式，每行输出一个连通集。先输出DFS的结果，再输出BFS的结果。<br>输出样例：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="number">0</span> <span class="number">1</span> <span class="number">4</span> <span class="number">2</span> <span class="number">7</span> &#125;</span><br><span class="line">&#123; <span class="number">3</span> <span class="number">5</span> &#125;</span><br><span class="line">&#123; <span class="number">6</span> &#125;</span><br><span class="line">&#123; <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">7</span> <span class="number">4</span> &#125;</span><br><span class="line">&#123; <span class="number">3</span> <span class="number">5</span> &#125;</span><br><span class="line">&#123; <span class="number">6</span> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//图</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LGraph</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Nv;     <span class="comment">/* 顶点数 */</span></span><br><span class="line">    <span class="keyword">int</span> Ne;     <span class="comment">/* 边数   */</span></span><br><span class="line">    <span class="keyword">int</span> [][]  map = <span class="keyword">new</span>  <span class="keyword">int</span> [<span class="number">10</span>][<span class="number">10</span>]; <span class="comment">/*邻接矩阵  */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span>[] Visited1 = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span>[] Visited2 = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LGraph Graph = <span class="keyword">new</span> LGraph();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        Graph.Nv = scan.nextInt();</span><br><span class="line">        Graph.Ne = scan.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//图初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Graph.Ne; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> V1 = Integer.parseInt(scan.next());</span><br><span class="line">            <span class="keyword">int</span> V2 = Integer.parseInt(scan.next());</span><br><span class="line">            <span class="keyword">if</span> (V1 == V2)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            Graph.map[V1][V2] = <span class="number">1</span>;</span><br><span class="line">            Graph.map[V2][V1] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Graph.Nv; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!Visited1[i]) &#123;</span><br><span class="line">                System.out.print(<span class="string">"&#123; "</span>);</span><br><span class="line">                DFS(i);</span><br><span class="line">                System.out.print(<span class="string">"&#125;\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Graph.Nv; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!Visited2[i]) &#123;</span><br><span class="line">                System.out.print(<span class="string">"&#123; "</span>);</span><br><span class="line">                BFS(i);</span><br><span class="line">                System.out.print(<span class="string">"&#125;\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DFS</span> <span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        Visited1[node] = <span class="keyword">true</span>;</span><br><span class="line">        System.out.print(node + <span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; Graph.Nv; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Graph.map[node][i] == <span class="number">1</span> &amp;&amp; !Visited1[i])</span><br><span class="line">                DFS(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BFS</span> <span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        queue.offer(node);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> n = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (!Visited2[n]) &#123;</span><br><span class="line">                Visited2[n] = <span class="keyword">true</span>;</span><br><span class="line">                System.out.print(n + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; Graph.Nv; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (Graph.map[n][i] == <span class="number">1</span> &amp;&amp; !Visited2[i])</span><br><span class="line">                    queue.offer(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-六度空间"><a href="#2-六度空间" class="headerlink" title="2 六度空间"></a>2 六度空间</h4><p>“六度空间”理论又称作“六度分隔（Six Degrees of Separation）”理论。这个理论可以通俗地阐述为：“你和任何一个陌生人之间所间隔的人不会超过六个，也就是说，最多通过五个人你就能够认识任何一个陌生人。”</p><p>假如给你一个社交网络图，请你对每个节点计算符合“六度空间”理论的结点占结点总数的百分比。</p><p>输入格式:<br>输入第1行给出两个正整数，分别表示社交网络图的结点数N（1&lt;N≤10<sup>3</sup>，表示人数）、边数M（≤33×N，表示社交关系数）。随后的M行对应M条边，每行给出一对正整数，分别是该条边直接连通的两个结点的编号（节点从1到N编号）。<br>输入样例：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> <span class="number">9</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">5</span> <span class="number">6</span></span><br><span class="line"><span class="number">6</span> <span class="number">7</span></span><br><span class="line"><span class="number">7</span> <span class="number">8</span></span><br><span class="line"><span class="number">8</span> <span class="number">9</span></span><br><span class="line"><span class="number">9</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><p>输出格式:<br>对每个结点输出与该结点距离不超过6的结点数占结点总数的百分比，精确到小数点后2位。每个结节点输出一行，格式为“结点编号:（空格）百分比%”。<br>输出样例：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>: <span class="number">70.00</span>%</span><br><span class="line"><span class="number">2</span>: <span class="number">80.00</span>%</span><br><span class="line"><span class="number">3</span>: <span class="number">90.00</span>%</span><br><span class="line"><span class="number">4</span>: <span class="number">100.00</span>%</span><br><span class="line"><span class="number">5</span>: <span class="number">100.00</span>%</span><br><span class="line"><span class="number">6</span>: <span class="number">100.00</span>%</span><br><span class="line"><span class="number">7</span>: <span class="number">100.00</span>%</span><br><span class="line"><span class="number">8</span>: <span class="number">90.00</span>%</span><br><span class="line"><span class="number">9</span>: <span class="number">80.00</span>%</span><br><span class="line"><span class="number">10</span>: <span class="number">70.00</span>%</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//图</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LGraph</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Nv;     <span class="comment">/* 顶点数 */</span></span><br><span class="line">    <span class="keyword">int</span> Ne;     <span class="comment">/* 边数   */</span></span><br><span class="line">    Vertex[] vertexArray = <span class="keyword">new</span> Vertex[<span class="number">1000</span>]; <span class="comment">/*邻接表 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vertex</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> verName;</span><br><span class="line">    Vertex nextNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span>[] Visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">1000</span>];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LGraph Graph = <span class="keyword">new</span> LGraph();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        Graph.Nv = scan.nextInt();</span><br><span class="line">        Graph.Ne = scan.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Graph.Ne; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> v1 = Integer.parseInt(scan.next()) - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> v2 = Integer.parseInt(scan.next()) - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (v1 == v2)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            Vertex VN1 = <span class="keyword">new</span> Vertex();</span><br><span class="line">            VN1.verName = v2;</span><br><span class="line">            Vertex VN2 = <span class="keyword">new</span> Vertex();</span><br><span class="line">            VN2.verName = v1;</span><br><span class="line">            Vertex VN = Graph.vertexArray[v1];</span><br><span class="line">            Graph.vertexArray[v1] = VN1;</span><br><span class="line">            VN1.nextNode = VN;</span><br><span class="line">            VN = Graph.vertexArray[v2];</span><br><span class="line">            Graph.vertexArray[v2] = VN2;</span><br><span class="line">            VN2.nextNode = VN;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Graph.Nv; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Graph.Nv; j++)</span><br><span class="line">                Visited[j] = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">int</span> x = i + <span class="number">1</span>;</span><br><span class="line">            System.out.print(x + <span class="string">": "</span>);</span><br><span class="line">            BFS(i);</span><br><span class="line">            <span class="keyword">if</span> (i != Graph.Nv - <span class="number">1</span>) &#123;</span><br><span class="line">                System.out.print(<span class="string">"\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BFS</span> <span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>, tail = <span class="number">0</span>, last = node, level = <span class="number">0</span>;</span><br><span class="line">        queue.offer(node);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> n = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (!Visited[n]) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                Visited[n] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                Vertex no = Graph.vertexArray[n];</span><br><span class="line">                <span class="keyword">while</span> (no != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!Visited[no.verName]) &#123;</span><br><span class="line">                        queue.offer(no.verName);</span><br><span class="line">                        tail = no.verName;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                    no = no.nextNode;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (n == last) &#123;</span><br><span class="line">                    last = tail;</span><br><span class="line">                    level++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (level == <span class="number">7</span>) &#123;</span><br><span class="line">                    queue.clear();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> rate = (<span class="keyword">double</span>) count * <span class="number">100</span> / Graph.Nv;</span><br><span class="line">        System.out.print(String.format(<span class="string">"%.2f"</span>, rate) + <span class="string">"%"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小技巧：利用tail和last记录BFS当前层数</p><figure class="image-box">                <img src="/2020/02/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/3.png" alt="3" title class>                <p>3</p>            </figure>  <h3 id="第九章-排序-上"><a href="#第九章-排序-上" class="headerlink" title="第九章 排序(上)"></a>第九章 排序(上)</h3><h4 id="1-排序"><a href="#1-排序" class="headerlink" title="1 排序"></a>1 排序</h4><p>给定N个（长整型范围内的）整数，要求输出从小到大排序后的结果。</p><p>输入格式:<br>输入第一行给出正整数N（≤10​<sup>5</sup>），随后一行给出N个（长整型范围内的）整数，其间以空格分隔。<br>输入样例：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">4</span> <span class="number">981</span> <span class="number">10</span> <span class="number">-17</span> <span class="number">0</span> <span class="number">-20</span> <span class="number">29</span> <span class="number">50</span> <span class="number">8</span> <span class="number">43</span> <span class="number">-5</span></span><br></pre></td></tr></table></figure><p>输出格式:<br>在一行中输出从小到大排序后的结果，数字间以1个空格分隔，行末不得有多余空格。<br>输出样例：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">-20</span> <span class="number">-17</span> <span class="number">-5</span> <span class="number">0</span> <span class="number">4</span> <span class="number">8</span> <span class="number">10</span> <span class="number">29</span> <span class="number">43</span> <span class="number">50</span> <span class="number">981</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">( <span class="keyword">int</span> A[], <span class="keyword">int</span> TmpA[], <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> RightEnd )</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 将有序的A[L]~A[R-1]和A[R]~A[RightEnd]归并成一个有序序列 */</span></span><br><span class="line">     <span class="keyword">int</span> LeftEnd, NumElements, Tmp;</span><br><span class="line">     <span class="keyword">int</span> i;</span><br><span class="line">      </span><br><span class="line">     LeftEnd = R - <span class="number">1</span>; <span class="comment">/* 左边终点位置 */</span></span><br><span class="line">     Tmp = L;         <span class="comment">/* 有序序列的起始位置 */</span></span><br><span class="line">     NumElements = RightEnd - L + <span class="number">1</span>;</span><br><span class="line">      </span><br><span class="line">     <span class="keyword">while</span>( L &lt;= LeftEnd &amp;&amp; R &lt;= RightEnd ) &#123;</span><br><span class="line">         <span class="keyword">if</span> ( A[L] &lt;= A[R] )</span><br><span class="line">             TmpA[Tmp++] = A[L++]; <span class="comment">/* 将左边元素复制到TmpA */</span></span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">             TmpA[Tmp++] = A[R++]; <span class="comment">/* 将右边元素复制到TmpA */</span></span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">while</span>( L &lt;= LeftEnd )</span><br><span class="line">         TmpA[Tmp++] = A[L++]; <span class="comment">/* 直接复制左边剩下的 */</span></span><br><span class="line">     <span class="keyword">while</span>( R &lt;= RightEnd )</span><br><span class="line">         TmpA[Tmp++] = A[R++]; <span class="comment">/* 直接复制右边剩下的 */</span></span><br><span class="line">          </span><br><span class="line">     <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; NumElements; i++, RightEnd -- )</span><br><span class="line">         A[RightEnd] = TmpA[RightEnd]; <span class="comment">/* 将有序的TmpA[]复制回A[] */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge_pass</span><span class="params">( <span class="keyword">int</span> A[], <span class="keyword">int</span> TmpA[], <span class="keyword">int</span> N, <span class="keyword">int</span> length )</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 两两归并相邻有序子列 */</span></span><br><span class="line">     <span class="keyword">int</span> i, j;</span><br><span class="line">       </span><br><span class="line">     <span class="keyword">for</span> ( i=<span class="number">0</span>; i &lt;= N<span class="number">-2</span>*length; i += <span class="number">2</span>*length )</span><br><span class="line">         Merge( A, TmpA, i, i+length, i+<span class="number">2</span>*length<span class="number">-1</span> );</span><br><span class="line">     <span class="keyword">if</span> ( i+length &lt; N ) <span class="comment">/* 归并最后2个子列*/</span></span><br><span class="line">         Merge( A, TmpA, i, i+length, N<span class="number">-1</span>);</span><br><span class="line">     <span class="keyword">else</span> <span class="comment">/* 最后只剩1个子列*/</span></span><br><span class="line">         <span class="keyword">for</span> ( j = i; j &lt; N; j++ ) TmpA[j] = A[j];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge_Sort</span><span class="params">( <span class="keyword">int</span> A[], <span class="keyword">int</span> N )</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">     <span class="keyword">int</span> length; </span><br><span class="line">     <span class="keyword">int</span> *TmpA;</span><br><span class="line">      </span><br><span class="line">     length = <span class="number">1</span>; <span class="comment">/* 初始化子序列长度*/</span></span><br><span class="line">     TmpA =(<span class="keyword">int</span>*)  <span class="built_in">malloc</span>( N * <span class="keyword">sizeof</span>( <span class="keyword">int</span> ) );</span><br><span class="line">     <span class="keyword">if</span> ( TmpA != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">          <span class="keyword">while</span>( length &lt; N ) &#123;</span><br><span class="line">              Merge_pass( A, TmpA, N, length );</span><br><span class="line">              length *= <span class="number">2</span>;</span><br><span class="line">              Merge_pass( TmpA, A, N, length );</span><br><span class="line">              length *= <span class="number">2</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="built_in">free</span>( TmpA );</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> <span class="built_in">printf</span>( <span class="string">"空间不足"</span> );</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*****************************/</span></span><br><span class="line"><span class="comment">// --输入--</span></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">int</span>* a;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;N);</span><br><span class="line">a = <span class="keyword">new</span> <span class="keyword">int</span> [N];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; ++i)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line"><span class="comment">/*****************************/</span></span><br><span class="line">Merge_Sort( a, N );</span><br><span class="line"></span><br><span class="line"><span class="comment">// --输出--</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,a[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;N; ++i)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" %d"</span>,a[i]);</span><br><span class="line"><span class="keyword">delete</span> [] a;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第十章-排序-下"><a href="#第十章-排序-下" class="headerlink" title="第十章 排序(下)"></a>第十章 排序(下)</h3><h4 id="1-统计工龄"><a href="#1-统计工龄" class="headerlink" title="1 统计工龄"></a>1 统计工龄</h4><p>给定公司N名员工的工龄，要求按工龄增序输出每个工龄段有多少员工。</p><p>输入格式:<br>输入首先给出正整数N（≤10​<sup>5</sup>），即员工总人数；随后给出N个整数，即每个员工的工龄，范围在[0, 50]。<br>输入样例：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">10</span> <span class="number">2</span> <span class="number">0</span> <span class="number">5</span> <span class="number">7</span> <span class="number">2</span> <span class="number">5</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p>输出格式:<br>按工龄的递增顺序输出每个工龄的员工个数，格式为：“工龄:人数”。每项占一行。如果人数为0则不输出该项。<br>输出样例：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">1</span></span><br><span class="line"><span class="number">2</span>:<span class="number">3</span></span><br><span class="line"><span class="number">5</span>:<span class="number">2</span></span><br><span class="line"><span class="number">7</span>:<span class="number">1</span></span><br><span class="line"><span class="number">10</span>:<span class="number">1</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Array;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] A = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">51</span>];</span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> N = scan.nextInt();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> n = scan.nextInt();</span><br><span class="line">            A[n] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">51</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(i + <span class="string">":"</span> + A[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第十一章-散列查找"><a href="#第十一章-散列查找" class="headerlink" title="第十一章 散列查找"></a>第十一章 散列查找</h3><h4 id="1-电话聊天狂人"><a href="#1-电话聊天狂人" class="headerlink" title="1 电话聊天狂人"></a>1 电话聊天狂人</h4><p>给定大量手机用户通话记录，找出其中通话次数最多的聊天狂人。</p><p>输入格式:<br>输入首先给出正整数N（≤10​<sup>5</sup>），为通话记录条数。随后N行，每行给出一条通话记录。简单起见，这里只列出拨出方和接收方的11位数字构成的手机号码，其中以空格分隔。<br>输入样例：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">13005711862</span> <span class="number">13588625832</span></span><br><span class="line"><span class="number">13505711862</span> <span class="number">13088625832</span></span><br><span class="line"><span class="number">13588625832</span> <span class="number">18087925832</span></span><br><span class="line"><span class="number">15005713862</span> <span class="number">13588625832</span></span><br></pre></td></tr></table></figure><p>输出格式:<br>在一行中给出聊天狂人的手机号码及其通话次数，其间以空格分隔。如果这样的人不唯一，则输出狂人中最小的号码及其通话次数，并且附加给出并列狂人的人数。<br>输出样例：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">13588625832</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Integer&gt; phoneNumber = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> N = scan.nextInt();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * N; i++) &#123;</span><br><span class="line">            String n = scan.next();</span><br><span class="line">            <span class="keyword">if</span> (phoneNumber.containsKey(n)) &#123;</span><br><span class="line">                phoneNumber.put(n, phoneNumber.get(n) + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                phoneNumber.put(n, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>, value = <span class="number">0</span>;</span><br><span class="line">        List&lt;String&gt; number=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        String Num = <span class="string">"99999999999"</span>;</span><br><span class="line">        <span class="keyword">for</span> (String key:phoneNumber.keySet())&#123;</span><br><span class="line">            value = phoneNumber.get(key);</span><br><span class="line">            <span class="keyword">if</span>(max &lt; value)&#123;</span><br><span class="line">                max = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (String key:phoneNumber.keySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(phoneNumber.get(key) == max)&#123;</span><br><span class="line">                number.add(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (number.size() == <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(number.get(<span class="number">0</span>) + <span class="string">" "</span> + max);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (String key : number) &#123;</span><br><span class="line">                <span class="keyword">if</span> (key.compareTo(Num) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    Num = key;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Num + <span class="string">" "</span> + max + <span class="string">" "</span> + number.size());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-QQ帐户的申请与登陆"><a href="#2-QQ帐户的申请与登陆" class="headerlink" title="2 QQ帐户的申请与登陆"></a>2 QQ帐户的申请与登陆</h4><p>实现QQ新帐户申请和老帐户登陆的简化版功能。最大挑战是：据说现在的QQ号码已经有10位数了。</p><p>输入格式:<br>输入首先给出正整数N（≤10​<sup>5</sup>），随后给出N行指令。每行指令的格式为：“命令符（空格）QQ号码（空格）密码”。其中命令符为“N”（代表New）时表示要新申请一个QQ号，后面是新帐户的号码和密码；命令符为“L”（代表Login）时表示是老帐户登陆，后面是登陆信息。QQ号码为一个不超过10位、但大于1000（据说QQ老总的号码是1001）的整数。密码为不小于6位、不超过16位、且不包含空格的字符串。<br>输入样例：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line">L <span class="number">1234567890</span> myQQ@qq.com</span><br><span class="line">N <span class="number">1234567890</span> myQQ@qq.com</span><br><span class="line">N <span class="number">1234567890</span> myQQ@qq.com</span><br><span class="line">L <span class="number">1234567890</span> myQQ@qq</span><br><span class="line">L <span class="number">1234567890</span> myQQ@qq.com</span><br></pre></td></tr></table></figure><p>输出格式:<br>针对每条指令，给出相应的信息：<br>1）若新申请帐户成功，则输出“New: OK”；<br>2）若新申请的号码已经存在，则输出“ERROR: Exist”；<br>3）若老帐户登陆成功，则输出“Login: OK”；<br>4）若老帐户QQ号码不存在，则输出“ERROR: Not Exist”；<br>5）若老帐户密码错误，则输出“ERROR: Wrong PW”。<br>输出样例：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ERROR: Not Exist</span><br><span class="line">New: OK</span><br><span class="line">ERROR: Exist</span><br><span class="line">ERROR: Wrong PW</span><br><span class="line">Login: OK</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, String&gt; QQNumber = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> N = scan.nextInt();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            String order = scan.next();</span><br><span class="line">            String number = scan.next();</span><br><span class="line">            String password = scan.next();</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(order, <span class="string">"N"</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (QQNumber.containsKey(number)) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"ERROR: Exist"</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    QQNumber.put(number, password);</span><br><span class="line">                    System.out.println(<span class="string">"New: OK"</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (QQNumber.containsKey(number)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!Objects.equals(QQNumber.get(number), password)) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"ERROR: Wrong PW"</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">"Login: OK"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"ERROR: Not Exist"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
            <tag> 算法与数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理学习笔记四-词法分析</title>
      <link href="/2020/02/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/"/>
      <url>/2020/02/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="第四章-词法分析"><a href="#第四章-词法分析" class="headerlink" title="第四章 词法分析"></a>第四章 词法分析</h1><h3 id="第一部分：词法分析器的设计"><a href="#第一部分：词法分析器的设计" class="headerlink" title="第一部分：词法分析器的设计"></a>第一部分：词法分析器的设计</h3><h4 id="1-词法分析的任务"><a href="#1-词法分析的任务" class="headerlink" title="1 词法分析的任务"></a>1 词法分析的任务</h4><p>词法分析的任务：从左至右逐个字符地对源程序进行扫描，产生一个个单词符号  </p><p>词法分析器(Lexical Analyzer)：扫描器(Scanner)、执行词法分析的程序</p><h4 id="2-词法分析器的功能"><a href="#2-词法分析器的功能" class="headerlink" title="2 词法分析器的功能"></a>2 词法分析器的功能</h4><p>功能：输入源程序、输出单词符号</p><p>单词符号的种类：<br>基本字：如 begin，repeat，for，…<br>标识符：用来表示各种名字，如变量名、数组名和过程名<br>常数：各种类型的常数<br>运算符：+，-，*，/，…<br>界符：逗号、分号、括号和空白</p><h4 id="3-词法分析器的输出"><a href="#3-词法分析器的输出" class="headerlink" title="3 词法分析器的输出"></a>3 词法分析器的输出</h4><p>输出：输出的单词符号的表示形式(单词种别，单词自身的值)</p><p>单词种别通常用整数编码表示：<br>若一个种别只有一个单词符号，则种别编码就代表该单词符号。假定基本字、运算符和界符都是一符一种。<br>若一个种别有多个单词符号，则对于每个单词符号，给出种别编码和自身的值。</p><h4 id="4-词法分析器在编译器中的地位"><a href="#4-词法分析器在编译器中的地位" class="headerlink" title="4 词法分析器在编译器中的地位"></a>4 词法分析器在编译器中的地位</h4><figure class="image-box">                <img src="/2020/02/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/2.png" alt="词法分析器在编译器中的地位" title class>                <p>词法分析器在编译器中的地位</p>            </figure><h4 id="5-词法分析器的结构"><a href="#5-词法分析器的结构" class="headerlink" title="5 词法分析器的结构"></a>5 词法分析器的结构</h4><figure class="image-box">                <img src="/2020/02/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/1.png" alt="词法分析器的结构" title class>                <p>词法分析器的结构</p>            </figure><h4 id="6-避免超前搜索"><a href="#6-避免超前搜索" class="headerlink" title="6 避免超前搜索"></a>6 避免超前搜索</h4><p>所有基本字都是保留字;用户不能用它们作自己的标识符；<br>基本字作为特殊的标识符来处理，使用保留字表；<br>如果基本字、标识符和常数(或标号)之间没有确定的运算符或界符作间隔，则必须使用一个空白符作间隔。</p><h4 id="7-状态转换图"><a href="#7-状态转换图" class="headerlink" title="7 状态转换图"></a>7 状态转换图</h4><p>状态转换图是一张有限方向图。<br>结点代表状态，用圆圈表示；<br>状态之间用箭弧连结，箭弧上的标记(字符)代表射出结状态下可能出现的输入字符或字符类；<br>一张转换图只包含有限个状态，其中有一个为初态，至少要有一个终态。</p><p>状态转换图可用于识别(或接受)一定的字符串。<br>若存在一条从初态到某一终态的道路，且这条路上所有弧上的标记符连接成的字等于α，则称α被该状态转换图所识别(接受)</p><h4 id="8-词法分析器的设计示例"><a href="#8-词法分析器的设计示例" class="headerlink" title="8 词法分析器的设计示例"></a>8 词法分析器的设计示例</h4><figure class="image-box">                <img src="/2020/02/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/3.png" alt="词法分析器的设计示例" title class>                <p>词法分析器的设计示例</p>            </figure><h4 id="9-状态转换图的程序实现"><a href="#9-状态转换图的程序实现" class="headerlink" title="9 状态转换图的程序实现"></a>9 状态转换图的程序实现</h4><p>不含回路的分叉结点：可用一个CASE语句或一组IF-THEN-ELSE语句实现；<br>含回路的状态结点：对应一段由WHILE结构和IF语句构成的程序；<br>终态结点：表示识别出某种单词符号，对应返回语句。</p><h3 id="第二部分：词法规则的形式化"><a href="#第二部分：词法规则的形式化" class="headerlink" title="第二部分：词法规则的形式化"></a>第二部分：词法规则的形式化</h3><h4 id="10-正规式和正规集"><a href="#10-正规式和正规集" class="headerlink" title="10 正规式和正规集"></a>10 正规式和正规集</h4><p>正规集可以用正规式表示，正规式是表示正规集一种方法。<br>一个字集合是正规集当且仅当它能用正规式表示。<br>递归定义：<br>&nbsp;&nbsp;&nbsp;&nbsp;ε和Ø都是Σ上的正规式，它们所表示的正规集为{ε}和Ø;<br>&nbsp;&nbsp;&nbsp;&nbsp;任何a∈Σ，a是Σ上的正规式，它所表示的正规集为{a};<br>&nbsp;&nbsp;&nbsp;&nbsp;假定e1和e2都是上的正规式，它们所表示的正规集为L(e1)和L(e2)，则：(e1|e2)为正规式，它所表示的正规集为L(e1)∪L(e2)，(e1.e2)为正规式，它所表示的正规集为L(e1)L(e2)，(e1)*为正规式，它所表示的正规集为(L(e1))*。</p><p>若两个正规式所表示的正规集相同，则称这两个正规式等价。</p><p>正规式满足交换律、结合律、分配律。但e1e2 &lt;&gt; e2e1。</p><h4 id="11-确定有限自动机-DFA"><a href="#11-确定有限自动机-DFA" class="headerlink" title="11 确定有限自动机(DFA)"></a>11 确定有限自动机(DFA)</h4><p>确定有限自动机(Deterministic Finite Automata，DFA) M是一个五元式，M=(S, Σ, f, S0, F)，其中：<br>S：有穷状态集；<br>Σ：输入字母表(有穷)；<br>f：状态转换函数，为S×Σ→S的单值部分映射，f(s，a)=s’表示：当现行状态为s，输入字符为a时，将状态转换到下一状态s’，s’称为s的一个后继状态；<br>S0∈S是唯一的一个初态；<br>F⊆S：终态集(可空)。</p><p>例如：<br><img src="/2020/02/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/4.png" alt="确定有限自动机(DFA)"></p><p>对于Σ*中的任何字α，若存在一条从初态到某一终态的道路，且这条路上所有弧上的标记符连接成的字等于α，则称α为DFA M所识别(接收)。<br>DFA M所识别的字的全体记为L(M)。</p><h4 id="12-非确定有限自动机-NFA"><a href="#12-非确定有限自动机-NFA" class="headerlink" title="12 非确定有限自动机(NFA)"></a>12 非确定有限自动机(NFA)</h4><p>非确定有限自动机(Nondeterministic Finite Automata，NFA) M是一个五元式M=(S, Σ, f, S0, F)，其中：<br>S：有穷状态集<br>Σ：输入字母表(有穷)<br>f：状态转换函数，为S×Σ*→2S的部分映射<br>S0⊆S是非空的初态集<br>F⊆S：终态集(可空)</p><p>NFA 和DFA的区别：<br>NFA可以有多个初态；<br>弧上的标记可以是Σ*中的一个字(甚至可以是一个正规式)，而不一定是单个字符；<br>同一个字可能出现在同状态射出的多条弧上。</p><h4 id="13-DFA和NFA"><a href="#13-DFA和NFA" class="headerlink" title="13 DFA和NFA"></a>13 DFA和NFA</h4><p>对于任何两个有限自动机M和M’，如果L(M)=L(M’)，则称M与M’等价。<br>自动机理论中一个重要的结论：判定两个自动机等价性的算法是存在的。<br>对于每个NFA M存在一个DFA M’，使得 L(M)=L(M’)。<br>DFA与NFA识别能力相同。</p><h3 id="第三部分：有限自动机的等价性"><a href="#第三部分：有限自动机的等价性" class="headerlink" title="第三部分：有限自动机的等价性"></a>第三部分：有限自动机的等价性</h3><h4 id="14-DFA的化简"><a href="#14-DFA的化简" class="headerlink" title="14 DFA的化简"></a>14 DFA的化简</h4><p>对于给定的DFA M，寻找一个状态数比M少的DFA M’，使得L(M)=L(M’)。  </p><p>状态的等价性：<br>假设s和t为M的两个状态，如果从状态s出发能读出某个字α而停止于终态，那么同样，从t出发也能读出α而停止于终态；反之亦然，称s和t等价；<br>两个状态不等价，则称它们是可区别的。</p><p>基本思想：<br>把M的状态集划分为一些不相交的子集，使得任何两个不同子集的状态是可区别的，而同一子集的任何两个状态是等价的。<br>最后，让每个子集选出一个代表，同时消去其他状态。</p><p>子集划分：<br>首先，把S划分为终态和非终态两个子集，形成基本划分Π；<br>假定到某个时候，Π已含m个子集，记为Π={I(1)，I(2)，…，I(m)}，检查Π中的每个子集看是否能进一步划分；<br>一般地，对某个a和I(i)，若Ia(i) 落入现行Π中N个不同子集，则应把I(i)划分成N个不相交的组，使得每个组J的Ja都落入的Π同一子集；<br>重复上述过程，直到Π所含子集数不再增长；<br>对于上述最后划分Π中的每个子集，我们选取每个子集I中的一个状态代表其他状态，则可得到化简后的DFA M’；<br>若I含有原来的初态，则其代表为新的初态，若I含有原来的终态，则其代表为新的终态。</p><h4 id="15-NFA与正规式的转换"><a href="#15-NFA与正规式的转换" class="headerlink" title="15 NFA与正规式的转换"></a>15 NFA与正规式的转换</h4><p>对转换图概念拓广，令每条弧可用一个正规式作标记。</p><ol><li>对任何FA M，都存在一个正规式r，使得L(r)=L(M)。</li><li>对任何正规式r，都存在一个FA M，使得L(M)=L(r)。</li></ol><p>状态转换图消去结点的方法：</p><figure class="image-box">                <img src="/2020/02/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/5.png" alt="状态转换图消去结点的方法" title class>                <p>状态转换图消去结点的方法</p>            </figure><h4 id="16-词法分析程序自动生成–LEX"><a href="#16-词法分析程序自动生成–LEX" class="headerlink" title="16 词法分析程序自动生成–LEX"></a>16 词法分析程序自动生成–LEX</h4><figure class="image-box">                <img src="/2020/02/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/6.png" alt="词法分析程序自动生成--LEX" title class>                <p>词法分析程序自动生成--LEX</p>            </figure>  <p>工作过程：<br>对每条识别规则Pi构造一个相应的非确定有限自动机Mi；<br>引进一个新初态X，通过弧，将这些自动机连接成一个新的NFA；<br>把M确定化、最小化，生成该DFA的状态转换表和控制执行程序。</p>]]></content>
      
      
      <categories>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理学习笔记三-高级程序设计语言的语法描述</title>
      <link href="/2020/02/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E7%9A%84%E8%AF%AD%E6%B3%95%E6%8F%8F%E8%BF%B0/"/>
      <url>/2020/02/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E7%9A%84%E8%AF%AD%E6%B3%95%E6%8F%8F%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="第三章-高级程序设计语言的语法描述"><a href="#第三章-高级程序设计语言的语法描述" class="headerlink" title="第三章 高级程序设计语言的语法描述"></a>第三章 高级程序设计语言的语法描述</h1><h4 id="1-文法"><a href="#1-文法" class="headerlink" title="1 文法"></a>1 文法</h4><p>文法： 描述语言的语法结构的形式规则。</p><p>例：He gave me a book.<br>&lt;句子&gt; → &lt;主语&gt;&lt;谓语&gt;&lt;间接宾语&gt;&lt;直接宾语&gt;<br>&lt;主语&gt; → &lt;代词&gt;<br>&lt;谓语&gt; → &lt;动词&gt;<br>&lt;间接宾语&gt; → &lt;代词&gt;<br>&lt;直接宾语&gt; → &lt;冠词&gt; &lt;名词&gt;<br>&lt;代词&gt; → He<br>&lt;代词&gt; → me<br>&lt;名词&gt; → book<br>&lt;冠词&gt; → a<br>&lt;动词&gt; → gave  </p><h4 id="2-语法描述的几个基本概念"><a href="#2-语法描述的几个基本概念" class="headerlink" title="2 语法描述的几个基本概念"></a>2 语法描述的几个基本概念</h4><p>字母表：一个有穷字符集，记为∑<br>字母表中每个元素称为字符<br>∑上的字(也叫字符串)  是指由∑中的字符所构成的一个有穷序列<br>不包含任何字符的序列称为空字，记为ε<br>用∑*表示∑上的所有字的全体，包含空字ε<br>∑*的子集U和V的连接（积）定义为UV＝{ αβ | α∈U &amp; β∈V }<br>V自身的n次积记为Vn=V V … V<br>V0={ε}<br>V*是V的闭包： V<em>=V0∪V1∪V2∪V3∪…<br>V+是V的正规闭包：V＋＝V V</em></p><h4 id="3-上下文无关文法"><a href="#3-上下文无关文法" class="headerlink" title="3 上下文无关文法"></a>3 上下文无关文法</h4><p>上下文无关文法G是一个四元组G=(VT，VN，S，P)，其中<br>VT：终结符(Terminal)集合(非空)<br>VN：非终结符(Noterminal)集合(非空)，且VT ∩ VN=Ø<br>S：文法的开始符号，S∈VN<br>P：产生式集合(有限)，每个产生式形式为<br>P→α， P∈VN， α ∈ (VT ∪ VN)*<br>开始符S至少必须在某个产生式的左部出现一次</p><p>例，定义只含+，*的算术表达式的文法<br>  G=&lt; {i，+，*，(，)}，{E}，E， P &gt;， 其中，P由下列产生式组成：<br>E → i<br>E → E+E<br>E → E*E<br>E → (E)  </p><h4 id="4-最左推导、最右推导、语法树"><a href="#4-最左推导、最右推导、语法树" class="headerlink" title="4 最左推导、最右推导、语法树"></a>4 最左推导、最右推导、语法树</h4><p>最左推导：任何一步α⇒β都是对α中的最左非终结符进行替换<br>最右推导：任何一步α⇒β都是对α中的最右非终结符进行替换<br>用一张图表示一个句型的推导,称为语法树</p><h4 id="5-二义性-ambiguity"><a href="#5-二义性-ambiguity" class="headerlink" title="5 二义性(ambiguity)"></a>5 二义性(ambiguity)</h4><p>文法的二义性：如果一个文法存在某个句子对应两棵不同的语法树，则说这个文法是二义的<br>G(E)： E → i|E+E|E*E|(E) 是二义文法<br>语言的二义性：一个语言是二义的，如果对它不存在无二义的文法</p><h4 id="6-不论是程序设计语言还是自然语言，都可能有二义性，也称为歧义。请你针对某个程序语言或者自然语言，例举其中的二义性的例子。"><a href="#6-不论是程序设计语言还是自然语言，都可能有二义性，也称为歧义。请你针对某个程序语言或者自然语言，例举其中的二义性的例子。" class="headerlink" title="6 不论是程序设计语言还是自然语言，都可能有二义性，也称为歧义。请你针对某个程序语言或者自然语言，例举其中的二义性的例子。"></a>6 不论是程序设计语言还是自然语言，都可能有二义性，也称为歧义。请你针对某个程序语言或者自然语言，例举其中的二义性的例子。</h4><p>英语是一种二义性的语言，介词短语较易引起歧义。如“Tom saw Sam at the boat.”既可理解为Sam在船上，也可理解为Tom在船上。</p><p>但中文却不存在这样的歧义，“Tom看到Sam在船上”就是指Sam在船上。如果是Tom在船上就会表示为“Tom在船上看到Sam”。原因是中文附加了一些语法规则，会将介词短语的指代方指向前面的语法成分。因此可以通过增加规则消除二义性。因此在常见的高级程序语言中，较少见到二义性的例子。</p>]]></content>
      
      
      <categories>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统课程学习笔记四-进程管理</title>
      <link href="/2020/02/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
      <url>/2020/02/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="第四章-进程管理"><a href="#第四章-进程管理" class="headerlink" title="第四章 进程管理"></a>第四章 进程管理</h1><h4 id="4-1-进程具有异步性，是进程的优点还是缺点呢？"><a href="#4-1-进程具有异步性，是进程的优点还是缺点呢？" class="headerlink" title="4.1 进程具有异步性，是进程的优点还是缺点呢？"></a>4.1 进程具有异步性，是进程的优点还是缺点呢？</h4><p>是优点。异步可以提高系统运行效率，例如当某进程在加载资源时，可以异步执行，将系统资源让给其他进程。同时，异步运行也不影响进程的同步性，当需要同步执行某些进程时，可以使用进程的消息管理机制控制进程的运行。</p><h4 id="4-2-为何没有“阻塞到运行”或“就绪到阻塞”这样的状态迁移？"><a href="#4-2-为何没有“阻塞到运行”或“就绪到阻塞”这样的状态迁移？" class="headerlink" title="4.2 为何没有“阻塞到运行”或“就绪到阻塞”这样的状态迁移？"></a>4.2 为何没有“阻塞到运行”或“就绪到阻塞”这样的状态迁移？</h4><p>个人的理解是，就绪态的操作相当于一个队列等待。想要运行，在一定的优先级条件下首先要进入队列排队，而排队中的进程直到进入运行状态才能进行进入阻塞态等操作。</p><p>如果有“阻塞到运行”或“就绪到阻塞”的操作，实质上就打破了常规的流程，需要专门写一段代码处理这两种情况，降低系统稳定性。</p><h4 id="4-3-进程控制块中“内部进程通信信息”这一类成员变量的作用是什么？"><a href="#4-3-进程控制块中“内部进程通信信息”这一类成员变量的作用是什么？" class="headerlink" title="4.3 进程控制块中“内部进程通信信息”这一类成员变量的作用是什么？"></a>4.3 进程控制块中“内部进程通信信息”这一类成员变量的作用是什么？</h4><p>不同进程间的交互，数据通信，互斥与同步。</p><h4 id="4-4-列举你知道的WINDOWS中，在程序启动exe程序创建相应进程的方法？"><a href="#4-4-列举你知道的WINDOWS中，在程序启动exe程序创建相应进程的方法？" class="headerlink" title="4.4 列举你知道的WINDOWS中，在程序启动exe程序创建相应进程的方法？"></a>4.4 列举你知道的WINDOWS中，在程序启动exe程序创建相应进程的方法？</h4><p>1、system()</p><p>2、WinExec()</p><p>3、SheelExcute()</p><p>4、CreateProcess()</p><p>CreateProcess()是最底层的创建进程方法，创建进程内核对象，创建虚拟地址空间，装载exe、dll代码和数据到地址空间，创建主线程和线程内核对象，启动主线程并进入main函数。前三种函数是对CreateProcess()的封装简化，system()最简单，直接传入exe文件目录就可以直接开启进程。</p><h4 id="4-5-如何理解fork（）函数的返回值有2个取值？"><a href="#4-5-如何理解fork（）函数的返回值有2个取值？" class="headerlink" title="4.5 如何理解fork（）函数的返回值有2个取值？"></a>4.5 如何理解fork（）函数的返回值有2个取值？</h4><p>fork()会返回pid参数，用于判断是子进程还是父进程。pid=0，是子进程；pid&gt;0,是父进程，且值为子进程ID；pid=-1，出错。</p><h4 id="4-6-画圆和画方两个过程是完全同步的吗？"><a href="#4-6-画圆和画方两个过程是完全同步的吗？" class="headerlink" title="4.6 画圆和画方两个过程是完全同步的吗？"></a>4.6 画圆和画方两个过程是完全同步的吗？</h4><p>不会完全同步，因为首先创建的线程会先执行。要提高同步性，应首先创建好两个进程，然后采用时钟触发的方式同时执行。</p><h4 id="4-7-你有没有可用“线程编程技术”去改造和完善的编程项目？"><a href="#4-7-你有没有可用“线程编程技术”去改造和完善的编程项目？" class="headerlink" title="4.7 你有没有可用“线程编程技术”去改造和完善的编程项目？"></a>4.7 你有没有可用“线程编程技术”去改造和完善的编程项目？</h4><p>有。在前端页面开发中，获取网络资源应采用异步获取的方式，否则当网速较低时，页面会出现卡顿，影响体验效果。因此获取网络资源时应新建一线程获取，不影响页面其他内容的交互。</p><h4 id="4-8-临界区的设置大些好还是小些好？各有什么缺点？"><a href="#4-8-临界区的设置大些好还是小些好？各有什么缺点？" class="headerlink" title="4.8 临界区的设置大些好还是小些好？各有什么缺点？"></a>4.8 临界区的设置大些好还是小些好？各有什么缺点？</h4><p>应在满足访问控制的条件下尽可能小。太大会造成不必要的阻塞。</p><h4 id="4-9-Lock-S-，unLock-S-两个函数能否用于控制多线程之间的临界区访问"><a href="#4-9-Lock-S-，unLock-S-两个函数能否用于控制多线程之间的临界区访问" class="headerlink" title="4.9 Lock(S)，unLock(S)两个函数能否用于控制多线程之间的临界区访问?"></a>4.9 Lock(S)，unLock(S)两个函数能否用于控制多线程之间的临界区访问?</h4><p>可以是可以，但并不是一种好方法，线程间的临界区访问有其他更好的方式来实现。</p><h4 id="4-10-举出生活中类似“司机和售票员”的同步例子，并分析其中的关键操作。"><a href="#4-10-举出生活中类似“司机和售票员”的同步例子，并分析其中的关键操作。" class="headerlink" title="4.10 举出生活中类似“司机和售票员”的同步例子，并分析其中的关键操作。"></a>4.10 举出生活中类似“司机和售票员”的同步例子，并分析其中的关键操作。</h4><p>超市购物结算。收银员将商品全部扫码完毕，出示总金额，客户根据总金额付款，收银员根据客户付款方式执行相应操作，将商品打包交给客户。</p><h4 id="4-11-V操作定义中的q队列里面的进程都是阻塞进程。请问这些进程是从何而来的？或者说这些进程是怎么变成阻塞状态进入q队列的？"><a href="#4-11-V操作定义中的q队列里面的进程都是阻塞进程。请问这些进程是从何而来的？或者说这些进程是怎么变成阻塞状态进入q队列的？" class="headerlink" title="4.11 V操作定义中的q队列里面的进程都是阻塞进程。请问这些进程是从何而来的？或者说这些进程是怎么变成阻塞状态进入q队列的？"></a>4.11 V操作定义中的q队列里面的进程都是阻塞进程。请问这些进程是从何而来的？或者说这些进程是怎么变成阻塞状态进入q队列的？</h4><p>V操作和P操作是成对出现的。只有一种操作是无意义的。V操作中q队列的阻塞进程是P操作转入的。</p><h4 id="4-12-3个进程Pa-Pb-Pc-。临界资源数量为1，CSa-b-c是临界区”中，三个进程并发过程中，是不是一定会发生阻塞或唤醒操作？如果mutex初值设置为0或2会有什么结果？在实际应用中，应该怎么合理的设置互斥量的初值？"><a href="#4-12-3个进程Pa-Pb-Pc-。临界资源数量为1，CSa-b-c是临界区”中，三个进程并发过程中，是不是一定会发生阻塞或唤醒操作？如果mutex初值设置为0或2会有什么结果？在实际应用中，应该怎么合理的设置互斥量的初值？" class="headerlink" title="4.12 3个进程Pa,Pb,Pc 。临界资源数量为1，CSa,b,c是临界区”中，三个进程并发过程中，是不是一定会发生阻塞或唤醒操作？如果mutex初值设置为0或2会有什么结果？在实际应用中，应该怎么合理的设置互斥量的初值？"></a>4.12 3个进程Pa,Pb,Pc 。临界资源数量为1，CSa,b,c是临界区”中，三个进程并发过程中，是不是一定会发生阻塞或唤醒操作？如果mutex初值设置为0或2会有什么结果？在实际应用中，应该怎么合理的设置互斥量的初值？</h4><p>不一定。例如并发过程中，三个进程恰好是分别先后执行PV操作。设置为0的话，所有进程都无法进入临界区；设置为1的话，可以同时有两个进程进入临界区。在实际应用中，根据可最多同时进入临界区的进程个数设置互斥量初值。</p><h4 id="4-13-在4-5-4节“实现进程同步的例子：司机vs售票员”中，如果把两个信号量S1-S2的初值都设置为1，司机和售票员还能否正确同步？如果不能，请给出反例证明。在实际应用中，应该怎么合理的设置信号量的初值？"><a href="#4-13-在4-5-4节“实现进程同步的例子：司机vs售票员”中，如果把两个信号量S1-S2的初值都设置为1，司机和售票员还能否正确同步？如果不能，请给出反例证明。在实际应用中，应该怎么合理的设置信号量的初值？" class="headerlink" title="4.13 在4.5.4节“实现进程同步的例子：司机vs售票员”中，如果把两个信号量S1,S2的初值都设置为1，司机和售票员还能否正确同步？如果不能，请给出反例证明。在实际应用中，应该怎么合理的设置信号量的初值？"></a>4.13 在4.5.4节“实现进程同步的例子：司机vs售票员”中，如果把两个信号量S1,S2的初值都设置为1，司机和售票员还能否正确同步？如果不能，请给出反例证明。在实际应用中，应该怎么合理的设置信号量的初值？</h4><p>不能。因为会出现未关门就起步或未停车就开门的情况。在实际应用中，应根据正确的逻辑关系确定初值。如果是分属两个进程的两个步骤先后执行，应将初值设为0，如果是临界区互斥，应将初值设为1。</p><h4 id="4-14-编者和读者”同步问题在严格意义上讲是一个同步问题还是一个互斥问题？如果把题目的同步要求做一个加强：如果有读者和编者同时在等一个编者“写完”，则当前的“写”操作完后，等待的编者能优先进入。新的情形应当如何完成P-V同步操作？"><a href="#4-14-编者和读者”同步问题在严格意义上讲是一个同步问题还是一个互斥问题？如果把题目的同步要求做一个加强：如果有读者和编者同时在等一个编者“写完”，则当前的“写”操作完后，等待的编者能优先进入。新的情形应当如何完成P-V同步操作？" class="headerlink" title="4.14 编者和读者”同步问题在严格意义上讲是一个同步问题还是一个互斥问题？如果把题目的同步要求做一个加强：如果有读者和编者同时在等一个编者“写完”，则当前的“写”操作完后，等待的编者能优先进入。新的情形应当如何完成P-V同步操作？"></a>4.14 编者和读者”同步问题在严格意义上讲是一个同步问题还是一个互斥问题？如果把题目的同步要求做一个加强：如果有读者和编者同时在等一个编者“写完”，则当前的“写”操作完后，等待的编者能优先进入。新的情形应当如何完成P-V同步操作？</h4><p>写者优先:</p><p>1.写者线程的优先级高于读者线程。</p><p>2.当有写者到来时应该阻塞读者线程的队列。</p><p>3.当有一个写者正在写时或在阻塞队列时应当阻塞读者进程的读操作，直到所有写者进程完成写操作时放开读者进程。</p><p>4.当没有写者进程时读者进程应该能够同时读取文件。</p><p>具体实现:</p><p>1.通过添加信号量read实现写者到来时能够打断读者进程。</p><p>2.设置信号量fileSrc实现读写者对临界资源的访问。</p><p>3.设置计数器writeCount来统计当前阻塞的写者进程的数目，设置信号量writeCountSignal完成对writeCount计数器资源的互斥访问。</p><p>4.设置计数器readCount来统计访问临界资源的读者数目，设置信号量readCountSignal完成对readCount计数器资源的互斥访问。</p><h4 id="4-15-在控制台上直接启动的一个应用程序，其末尾的exit-函数返回参数由谁处理或接收？"><a href="#4-15-在控制台上直接启动的一个应用程序，其末尾的exit-函数返回参数由谁处理或接收？" class="headerlink" title="4.15 在控制台上直接启动的一个应用程序，其末尾的exit( )函数返回参数由谁处理或接收？"></a>4.15 在控制台上直接启动的一个应用程序，其末尾的exit( )函数返回参数由谁处理或接收？</h4><p>应该是init进程。init进程是系统中所有其它用户进程的祖先进程，Linux中的所有进程都是有init进程创建并运行的。首先Linux内核启动，然后在用户空间中启动init进程，再启动其他系统进程。在系统启动完成完成后，init将变为守护进程监视系统其他进程。</p><h4 id="4-16-举出生活中类似“司机和售票员”的同步例子，并分析其中的关键操作。"><a href="#4-16-举出生活中类似“司机和售票员”的同步例子，并分析其中的关键操作。" class="headerlink" title="4.16 举出生活中类似“司机和售票员”的同步例子，并分析其中的关键操作。"></a>4.16 举出生活中类似“司机和售票员”的同步例子，并分析其中的关键操作。</h4><p>个人理解，匿名管道实质上是有主从关系的，用来实现父进程对子进程的控制，因此是由父进程单方面的读写，子进程被动的响应。</p><h4 id="4-17-Linux信号机制与中断机制有什么异同？"><a href="#4-17-Linux信号机制与中断机制有什么异同？" class="headerlink" title="4.17 Linux信号机制与中断机制有什么异同？"></a>4.17 Linux信号机制与中断机制有什么异同？</h4><p>信号和中断的相似点：</p><p>都采用了异步通信的方式，同步就是排队，信息一个接一个的处理，异步就是插队；</p><p>都是暂停当前的, 去执行对应的handle程序；</p><p>都是处理完返回原来位置；</p><p>对于信号和中断, 都是可以屏蔽的。</p><p>信号与中断的区别：</p><p>中断有优先级, 信号没有；</p><p>信号处理程序在用户态下运行的, 中断程序在核心态下运行的；</p><p>中断响应是及时的, 当信号响应一般有延迟。</p><h3 id="单元作业"><a href="#单元作业" class="headerlink" title="单元作业"></a>单元作业</h3><h4 id="1-进程有哪4个特征？"><a href="#1-进程有哪4个特征？" class="headerlink" title="1 进程有哪4个特征？"></a>1 进程有哪4个特征？</h4><p>动态性：进程是程序的一次执行过程，动态产生和消亡；</p><p>并发性：进程同其他进程一起向前推进；</p><p>异步性：进程按各自速度向前推进；</p><p>独立性：进程是系统分配资源和调度CPU的单位。</p><h4 id="2-进程有哪3个基本状态，它们之间如何迁移？"><a href="#2-进程有哪3个基本状态，它们之间如何迁移？" class="headerlink" title="2 进程有哪3个基本状态，它们之间如何迁移？"></a>2 进程有哪3个基本状态，它们之间如何迁移？</h4><p>运行状态：进程已占有CPU，在CPU上运行；</p><p>就绪状态：举报运行条件但由于无CPU，暂时不能运行；</p><p>阻塞状态：因为等待某项服务完成或信号不能运行的状态。</p><p>新建的进程会进入就绪状态，根据进程调度进入运行状态，若有退出信号则进入终止状态，若需等待I/O或事件则进入阻塞状态，若时间片已到则进入就绪状态，组赛状态的进程等到I/O信号或事件信号后进入就绪状态。</p><h4 id="3-什么是进程控制，有哪4个典型的进程控制行为？"><a href="#3-什么是进程控制，有哪4个典型的进程控制行为？" class="headerlink" title="3 什么是进程控制，有哪4个典型的进程控制行为？"></a>3 什么是进程控制，有哪4个典型的进程控制行为？</h4><p>进程控制是指在进程生成全周期内，对其全部行为的控制。</p><p>四个典型控制行为包括：创建进程、阻塞进程、撤销进程和唤醒进行。</p><h4 id="4-什么是原语，有何特点？"><a href="#4-什么是原语，有何特点？" class="headerlink" title="4 什么是原语，有何特点？"></a>4 什么是原语，有何特点？</h4><p>原语是由若干指令构成的具有特定功能的函数。具有原子性，其操作不可分割。</p><h4 id="5-试述fork-函数的作用和特点？"><a href="#5-试述fork-函数的作用和特点？" class="headerlink" title="5 试述fork()函数的作用和特点？"></a>5 试述fork()函数的作用和特点？</h4><p>fork()是一个系统调用，用于创建进程。一个进程调用fork()函数后，系统先给新的进程分配资源，例如存储数据和代码的空间。新进程是当前进程的子进程，子进程是父进程的复制，子进程和父进程并发运行。</p><p>fork()会返回pid参数，用于判断是子进程还是父进程。pid=0，是子进程；pid&gt;0,是父进程，且值为子进程ID；pid=-1，出错。</p><h4 id="6-试述线程的概念（Thread）或特点？"><a href="#6-试述线程的概念（Thread）或特点？" class="headerlink" title="6 试述线程的概念（Thread）或特点？"></a>6 试述线程的概念（Thread）或特点？</h4><p>线程是可由CPU直接运行的实体；一个进程可以创建多个线程；多个线程共享CPU可以实现并发运行。</p><h4 id="7-试述线程有哪些典型应用场合？"><a href="#7-试述线程有哪些典型应用场合？" class="headerlink" title="7 试述线程有哪些典型应用场合？"></a>7 试述线程有哪些典型应用场合？</h4><p>1、程序需要并发运行多个功能；</p><p>2、需要改善窗口交互性的地方，例如用户输入、文件操作、网络操作、搜索等；</p><p>3、需要改善程序结构的地方，后台程序；</p><p>4、多核CPU上的应用，重复发挥多核性能。</p><h4 id="8-何为临界资源，何为临界区？"><a href="#8-何为临界资源，何为临界区？" class="headerlink" title="8 何为临界资源，何为临界区？"></a>8 何为临界资源，何为临界区？</h4><p>临界资源是指一次只允许一个进程独占访问的资源。临界区是指进程中访问临界资源的程序段。</p><h4 id="9-试述设计临界资源或临界区访问机制的四个原则是什么？"><a href="#9-试述设计临界资源或临界区访问机制的四个原则是什么？" class="headerlink" title="9 试述设计临界资源或临界区访问机制的四个原则是什么？"></a>9 试述设计临界资源或临界区访问机制的四个原则是什么？</h4><p>忙则等待、空闲让进、有限等待、让权等待</p><h4 id="10-临界区访问机制为什么要实现让权等待原则？锁机制为什么没有满足该原则？"><a href="#10-临界区访问机制为什么要实现让权等待原则？锁机制为什么没有满足该原则？" class="headerlink" title="10 临界区访问机制为什么要实现让权等待原则？锁机制为什么没有满足该原则？"></a>10 临界区访问机制为什么要实现让权等待原则？锁机制为什么没有满足该原则？</h4><p>让权等待可以让其它进程有机会得到CPU。锁机制阻止了其他进程对临界区资源的使用，且让调用该资源的进程处于阻塞状态，直到该进程调用完临界资源，执行解锁操作。</p><h4 id="11-什么是进程的互斥，什么是进程的同步？各举一个例子说明。"><a href="#11-什么是进程的互斥，什么是进程的同步？各举一个例子说明。" class="headerlink" title="11 什么是进程的互斥，什么是进程的同步？各举一个例子说明。"></a>11 什么是进程的互斥，什么是进程的同步？各举一个例子说明。</h4><p>进程的互斥是指多个进程由于共享了独占性资源，必须协调各进程对资源的存取顺序，确保没有两个或两个以上的进程同时进行存取操作。例如临界资源的使用。</p><p>进程的同步是指若干进程为了完成一个共同的任务，需要相互协调运行步伐，一个进程开始某个操作之前必须要求另一个进程已经完成某个操作，否则前面的进程只能等待。例如司机和售票员之间的操作。</p><h4 id="12-P-V操作的作用是什么？P操作和V操作各自的原理是什么？"><a href="#12-P-V操作的作用是什么？P操作和V操作各自的原理是什么？" class="headerlink" title="12 P-V操作的作用是什么？P操作和V操作各自的原理是什么？"></a>12 P-V操作的作用是什么？P操作和V操作各自的原理是什么？</h4><p>P-V操作为了实现信号灯进程同步机制。信号灯包含S和q两个属性，S表示信号量，q表示PCB队列。进程可以通过P-V操作改变信号灯的状态，同时进程的状态也受信号灯状态的约束。</p><p>P操作将S减1；若差大于等于0，该进程继续；若差小于0，则进程阻塞并加入队列q。</p><p>V操作将S加1；若和大于0，进程继续；若和小于等于0，该进程继续同时从q唤醒一个进程。</p><h4 id="13-试述P-V操作解决互斥问题的思路是什么？"><a href="#13-试述P-V操作解决互斥问题的思路是什么？" class="headerlink" title="13 试述P-V操作解决互斥问题的思路是什么？"></a>13 试述P-V操作解决互斥问题的思路是什么？</h4><p>​1、设定合适的S初值；</p><p>2、进入临界区前执行P操作；</p><p>3、离开临界区之后执行V操作。</p><h4 id="14-试述P-V操作解决同步问题的思路是什么？"><a href="#14-试述P-V操作解决同步问题的思路是什么？" class="headerlink" title="14 试述P-V操作解决同步问题的思路是什么？"></a>14 试述P-V操作解决同步问题的思路是什么？</h4><p>1、​定义有意义的信号量S，并设置合适的初值；</p><p>2、暂停进程时在关键操作前执行P操作；</p><p>3、继续进程时在关键操作后执行V操作。</p><h4 id="15-试分析“司机vs售票员”同步问题中，哪些操作是关键操作，哪些不是？为什么？"><a href="#15-试分析“司机vs售票员”同步问题中，哪些操作是关键操作，哪些不是？为什么？" class="headerlink" title="15 试分析“司机vs售票员”同步问题中，哪些操作是关键操作，哪些不是？为什么？"></a>15 试分析“司机vs售票员”同步问题中，哪些操作是关键操作，哪些不是？为什么？</h4><p>关键操作有关门、起步和停车、开门。行驶和售票不是关键操作。关键操作涉及到与其他进程的交互，非关键操作不涉及其他进程，只需满足进程内的逻辑。</p><h4 id="16-试分析“生产者与消费者”问题中，P-V操作是如何阻止生产者生产速度过快的，又是如何阻止消费者消费速度过快的？又是如何及时唤醒生产者去尽快生产的，又是如何及时唤醒消费者去尽快消费的？"><a href="#16-试分析“生产者与消费者”问题中，P-V操作是如何阻止生产者生产速度过快的，又是如何阻止消费者消费速度过快的？又是如何及时唤醒生产者去尽快生产的，又是如何及时唤醒消费者去尽快消费的？" class="headerlink" title="16 试分析“生产者与消费者”问题中，P-V操作是如何阻止生产者生产速度过快的，又是如何阻止消费者消费速度过快的？又是如何及时唤醒生产者去尽快生产的，又是如何及时唤醒消费者去尽快消费的？"></a>16 试分析“生产者与消费者”问题中，P-V操作是如何阻止生产者生产速度过快的，又是如何阻止消费者消费速度过快的？又是如何及时唤醒生产者去尽快生产的，又是如何及时唤醒消费者去尽快消费的？</h4><p>添加规则，不能向满缓存区存产品，不能从空缓存区取产品，当缓存区已满，生产者处于阻塞态，只有消费者可以运行，当缓存区已空，消费者处于阻塞态，只有生产者可以运行。</p><h4 id="17-试述Windows的信号量（Semaphore）机制的工作原理（或如何应用该机制）？"><a href="#17-试述Windows的信号量（Semaphore）机制的工作原理（或如何应用该机制）？" class="headerlink" title="17 试述Windows的信号量（Semaphore）机制的工作原理（或如何应用该机制）？"></a>17 试述Windows的信号量（Semaphore）机制的工作原理（或如何应用该机制）？</h4><p>信号量允许指定数目的多个线程或进程访问临界区，是一种资源计数器，用于限制并发线程的数量。</p><p>WaitForSingleObject将信号量减1，ReleaseSemaphore将信号量加1，信号量大于0为有信号状态，小于等于0为无信号状态。</p><h4 id="18-试述Linux中wait函数和exit函数的作用和它们之间的联系？"><a href="#18-试述Linux中wait函数和exit函数的作用和它们之间的联系？" class="headerlink" title="18 试述Linux中wait函数和exit函数的作用和它们之间的联系？"></a>18 试述Linux中wait函数和exit函数的作用和它们之间的联系？</h4><p>wait(int status)可以阻塞自己，当有子进程结束，wait收集该子进程信息并销毁该子进程后返回。</p><p>exit(int status)可以终止进程，利用status传递进程结束时的状态，然后变为僵尸状态，保留部分PCB信息供wait收集。</p><h4 id="19-试述Windows管道通信或Linux信号机制的原理（或如何应用该机制）？"><a href="#19-试述Windows管道通信或Linux信号机制的原理（或如何应用该机制）？" class="headerlink" title="19 试述Windows管道通信或Linux信号机制的原理（或如何应用该机制）？"></a>19 试述Windows管道通信或Linux信号机制的原理（或如何应用该机制）？</h4><p>管道是一种用于在进程间共享数据的机制，其实质是一段共享内存。Windows系统为这段共享的内存设计采用数据流I/0的方式来访问。由一个进程读、另一个进程写，类似于一个管道两端，因此这种进程间的通信方式称作“管道”。</p><p>管道分为匿名管道和命名管道：</p><p>匿名管道只能在父子进程间进行通信，不能在网络间通信，而且数据传输是单向的，只能一端写，另一端读，为实现双向通信，需建立两个匿名管道；</p><p>命令管道可以在任意进程间通信，通信是双向的，任意一端都可读可写，但是在同一时间只能有一端读、一端写。</p><p>匿名管道使用方法：</p><p>1、创建一个安全属性描述符，设置句柄可继承</p><p>2、创建两个管道，父读子写和子读父写</p><p>3、重定向输出，将子进程的读写重定向</p><p>4、创建子进程</p><p>5、读写数据给子进程</p><h4 id="20-阅读Linux2-6或更早早期的版本，查看task-struct结构的定义，了解每个成员变量的含义。"><a href="#20-阅读Linux2-6或更早早期的版本，查看task-struct结构的定义，了解每个成员变量的含义。" class="headerlink" title="20 阅读Linux2.6或更早早期的版本，查看task_struct结构的定义，了解每个成员变量的含义。"></a>20 阅读Linux2.6或更早早期的版本，查看task_struct结构的定义，了解每个成员变量的含义。</h4><p>state 进程状态</p><p>pid 进程标识符</p><p>tgid 线程组标识符</p><p>flags 进程标记符</p><p>real_parent 当前执行进程的父进程</p><p>parent 父进程</p><p>children 子进程</p><p>prio 优先级</p><p>mm 地址空间</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理学习笔记二-高级程序设计语言概述</title>
      <link href="/2020/02/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/"/>
      <url>/2020/02/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-引论"><a href="#第一章-引论" class="headerlink" title="第一章 引论"></a>第一章 引论</h1><h4 id="1-高级程序设计语言的优点"><a href="#1-高级程序设计语言的优点" class="headerlink" title="1 高级程序设计语言的优点"></a>1 高级程序设计语言的优点</h4><p>相对机器语言或汇编语言，高级程序设计语言更接近于数学语言和工程语言，更直观、自然和易于理解，更容易验证其正确性、改错，编写程序的效率更高，更容易移植</p><h4 id="2-程序语言的定义"><a href="#2-程序语言的定义" class="headerlink" title="2 程序语言的定义"></a>2 程序语言的定义</h4><p>语法、语义、语用</p><h4 id="3-语法"><a href="#3-语法" class="headerlink" title="3 语法"></a>3 语法</h4><p>程序本质上是一定字符集上的字符串。语法：一组规则，用它可以形成和产生一个合式(well-formed)的程序。<br>词法规则：单词符号的形成规则，单词符号是语言中具有独立意义的最基本结构，一般包括常数、标识符、基本字、算符、界符等，描述工具为有限自动机。<br>语法规则：语法单位的形成规则，语法单位通常包括表达式、语句、分程序、过程、函数、程序等，描述工具为上下文无关文法。<br>语法规则和词法规则定义了程序的形式结构，定义语法单位的意义属于语义问题。</p><h4 id="4-语义"><a href="#4-语义" class="headerlink" title="4 语义"></a>4 语义</h4><p>语义指一组规则，用它可以定义一个程序的意义，描述方法有自然语言描述和形式描述。</p><p>自然语言描述有二义性、隐藏错误和不完整性，形式描述有操作语义、指称语义、代数语义</p><h4 id="5-高级语言的分类"><a href="#5-高级语言的分类" class="headerlink" title="5 高级语言的分类"></a>5 高级语言的分类</h4><p>强制式语言(Imperative Languge)/过程式语言：命令驱动，面向语句。FORTRAN、C、Pascal，Ada<br>应用式语言(Applicative Language)：注重程序所表示的功能，而不是一个语句接一个语句地执行。LISP、ML<br>基于规则的语言( Rule-based Language)：检查一定的条件，当它满足值，则执行适当的动作、Prolog<br>面向对象语言(Object-Oriented Language)：封装、继承和多态性。Smalltalk，C++，Java </p><h4 id="6-数据类型与操作"><a href="#6-数据类型与操作" class="headerlink" title="6 数据类型与操作"></a>6 数据类型与操作</h4><p>数据类型通常包括三要素：<br>用于区别这种类型数据对象的<strong>属性</strong>；<br>这种类型的数据对象可以具有的<strong>值</strong>；<br>可以作用于这种类型的数据对象的<strong>操作</strong>。</p><h4 id="7-初等数据类型"><a href="#7-初等数据类型" class="headerlink" title="7 初等数据类型"></a>7 初等数据类型</h4><p>数值类型：整型、实型、复数、双精度。运算有+，-，*，/等<br>逻辑类型：true、false。布尔运算有∨，∧，┑等<br>字符类型：符号处理<br>指针类型</p><h4 id="8-名字"><a href="#8-名字" class="headerlink" title="8 名字"></a>8 名字</h4><p>名字的意义和属性：值，单元中的内容；属性，类型和作用域<br>名字的说明方式：由说明语句来明确规定的，如int score；隐含说明，如FORTRAN中以I,J,K,…N为首的名字代表整型，否则为实型；动态确定，走到哪里，是什么，算什么，如Python。</p><h4 id="9-标识符与名字"><a href="#9-标识符与名字" class="headerlink" title="9 标识符与名字"></a>9 标识符与名字</h4><p>标识符是以字母开头的，由字母数字组成的字符串。<br>标识符与名字两者有本质区别，标识符是语法概念，名字有确切的意义和属性。</p><h4 id="10-数据结构"><a href="#10-数据结构" class="headerlink" title="10 数据结构"></a>10 数据结构</h4><p>数组，字符串、表格、栈</p><h4 id="11-抽象数据类型"><a href="#11-抽象数据类型" class="headerlink" title="11 抽象数据类型"></a>11 抽象数据类型</h4><p>抽象数据类型(Abstract Data Type)：一组独立于任何特定实现而精确指定的数据值和相关操作。<br>抽象数据类型由数据集合、及其相关的操作组成，这些操作有明确的定义，而且定义不依赖于具体的实现。</p><p>一个抽象数据类型包括数据对象集合、作用于这些数据对象的抽象运算的集合、这种类型对象的封装。</p><h4 id="12-表达式"><a href="#12-表达式" class="headerlink" title="12 表达式"></a>12 表达式</h4><p>表达式由运算量（也称操作数，即数据引用或函数调用）和算符（运算符，操作符）组成</p><p>形式：中缀、前缀、后缀：X*Y、-A、P↑</p><p>表达式形成规则：变量（包括下标变量）、常数是表达式；若E1、E2为表达式，是一个二元算符，则E1E2是表达式；若E是表达式，为一元算符，则E（或E）是表达式；若E是表达式，则（E）是表达式。</p><h4 id="13-名字的左值和右值"><a href="#13-名字的左值和右值" class="headerlink" title="13 名字的左值和右值"></a>13 名字的左值和右值</h4><p>赋值语句<br>A := B</p><p>名字的左值：该名字代表的存储单元的地址</p><p>名字的右值：该名字代表的存贮单元的内容</p><h4 id="14-语句的分类"><a href="#14-语句的分类" class="headerlink" title="14 语句的分类"></a>14 语句的分类</h4><p>按功能：执行语句，描述程序的动作；说明语句，定义各种不同数据类型的变量或运算，定义名字的性质</p><p>按形式：简单句，不包含其他语句成分的基本句；复合句，句中有句的语句</p>]]></content>
      
      
      <categories>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理学习笔记一-引论</title>
      <link href="/2020/02/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80-%E5%BC%95%E8%AE%BA/"/>
      <url>/2020/02/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80-%E5%BC%95%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-引论"><a href="#第一章-引论" class="headerlink" title="第一章 引论"></a>第一章 引论</h1><h4 id="1-翻译程序-Translator-、编译程序-Compiler-、解释程序-Interpreter"><a href="#1-翻译程序-Translator-、编译程序-Compiler-、解释程序-Interpreter" class="headerlink" title="1 翻译程序(Translator)、编译程序(Compiler)、解释程序(Interpreter)"></a>1 翻译程序(Translator)、编译程序(Compiler)、解释程序(Interpreter)</h4><p>翻译程序是把某一种语言程序(称为源语言程序)等价地转换成另一种语言程序(称为目标语言程序)的程序。</p><p>编译程序是把某一种高级语言程序等价地转换成另一种低级语言程序(如汇编语言或机器语言程序)的程序。</p><p>解释程序是把源语言写的源程序作为输入，但不产生目标程序，而是边解释边执行源程序。</p><h4 id="2-编译过程"><a href="#2-编译过程" class="headerlink" title="2 编译过程"></a>2 编译过程</h4><figure class="image-box">                <img src="/2020/02/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80-%E5%BC%95%E8%AE%BA/1.png" alt="词法分析程序自动生成--LEX" title class>                <p>词法分析程序自动生成--LEX</p>            </figure>  <p>词法分析：输入源程序，对构成源程序的字符串进行扫描和分解，识别出单词符号；<br>语法分析：在词法分析的基础上，根据语法规则把单词符号串分解成各类语法单位(语法范畴)；<br>中间代码生成：对各类语法单位按语言的语义进行初步翻译；<br>优化：依据程序的等价变换规则，对前阶段产生的中间代码进行加工变换，以期在最后阶段产生更高效的目标代码；<br>目标代码产生：把中间代码变换成特定机器上的目标代码，目标代码有三种形式，汇编指令代码、绝对指令代码、可重新定位指令代码。</p><h4 id="3-编译程序结构"><a href="#3-编译程序结构" class="headerlink" title="3 编译程序结构"></a>3 编译程序结构</h4><p>包括词法分析器、语法分析器、语义分析与中间代码生成器、优化段、目标代码生成器、符号表管理和出错处理</p><h4 id="4-遍-pass"><a href="#4-遍-pass" class="headerlink" title="4 遍(pass)"></a>4 遍(pass)</h4><p>所谓”遍”， 就是对源程序或源程序的中间表示从头到尾扫描一次.阶段与遍是不同的概念，一遍可以由若干段组成，一个阶段也可以分若干遍来完成</p><h4 id="5-编译前端与后端"><a href="#5-编译前端与后端" class="headerlink" title="5 编译前端与后端"></a>5 编译前端与后端</h4><p>编译前端：与源语言有关，如词法分析，语法分析，语义分析与中间代码产生，与机器无关的优化；<br>编译后端：与目标机有关，与目标机有关的优化，目标代码产生；<br>带来的好处：程序逻辑结构清晰；优化更充分，有利于移植。</p><h4 id="6-编译语言的生成"><a href="#6-编译语言的生成" class="headerlink" title="6 编译语言的生成"></a>6 编译语言的生成</h4><p>以汇编语言和机器语言为工具。<br>优点:  可以针对具体的机器，充分发挥计算机的系统功能；生成的程序效率高<br>缺点:  程序难读、难写、易出错、难维护、生产的效率低</p><p>以高级语言为工具。程序易读、易理解、容易维护、生产的效率高</p><p>自编译方式。</p>]]></content>
      
      
      <categories>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法课程笔记-堆和堆排序</title>
      <link href="/2020/02/12/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%A0%86%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/02/12/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%A0%86%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="堆和堆排序"><a href="#堆和堆排序" class="headerlink" title="堆和堆排序"></a>堆和堆排序</h1><figure class="image-box">                <img src="/2020/02/12/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%A0%86%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F/1.png" alt="三路快速排序" title class>                <p>三路快速排序</p>            </figure>   <p>基本规则：<br>从数组1号位置开始，每个元素的leftChild为2k，rightChild为2k+1。<br>从数组0号位置开始，每个元素的leftChild为2k+1，rightChild为2k+2。</p><h4 id="1-二叉树存取数据的实现"><a href="#1-二叉树存取数据的实现" class="headerlink" title="1 二叉树存取数据的实现"></a>1 二叉树存取数据的实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Item&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxHeap</span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Item *data;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shiftUp</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>( k &gt; <span class="number">1</span> &amp;&amp; data[k/<span class="number">2</span>] &lt; data[k] )&#123;</span><br><span class="line">            swap( data[k/<span class="number">2</span>], data[k] );</span><br><span class="line">            k /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shiftDown</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>( <span class="number">2</span>*k &lt;= count )&#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">2</span>*k; <span class="comment">// 在此轮循环中,data[k]和data[j]交换位置</span></span><br><span class="line">            <span class="keyword">if</span>( j+<span class="number">1</span> &lt;= count &amp;&amp; data[j+<span class="number">1</span>] &gt; data[j] )</span><br><span class="line">                j ++;</span><br><span class="line">            <span class="comment">// data[j] 是 data[2*k]和data[2*k+1]中的最大值</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( data[k] &gt;= data[j] ) <span class="keyword">break</span>;</span><br><span class="line">            swap( data[k] , data[j] );</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数, 构造一个空堆, 可容纳capacity个元素</span></span><br><span class="line">    MaxHeap(<span class="keyword">int</span> capacity)&#123;</span><br><span class="line">        data = <span class="keyword">new</span> Item[capacity+<span class="number">1</span>];</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数, 通过一个给定数组创建一个最大堆</span></span><br><span class="line">    <span class="comment">// 该构造堆的过程, 时间复杂度为O(n)</span></span><br><span class="line">    MaxHeap(Item arr[], <span class="keyword">int</span> n)&#123;</span><br><span class="line">        data = <span class="keyword">new</span> Item[n+<span class="number">1</span>];</span><br><span class="line">        capacity = n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++ )</span><br><span class="line">            data[i+<span class="number">1</span>] = arr[i];</span><br><span class="line">        count = n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = count/<span class="number">2</span> ; i &gt;= <span class="number">1</span> ; i -- )</span><br><span class="line">            shiftDown(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~MaxHeap()&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回堆中的元素个数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个布尔值, 表示堆中是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 像最大堆中插入一个新的元素 item</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Item item)</span></span>&#123;</span><br><span class="line">        assert( count + <span class="number">1</span> &lt;= capacity );</span><br><span class="line">        data[count+<span class="number">1</span>] = item;</span><br><span class="line">        shiftUp(count+<span class="number">1</span>);</span><br><span class="line">        count ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从最大堆中取出堆顶元素, 即堆中所存储的最大数据</span></span><br><span class="line">    <span class="function">Item <span class="title">extractMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">        assert( count &gt; <span class="number">0</span> );</span><br><span class="line">        Item ret = data[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        swap( data[<span class="number">1</span>] , data[count] );</span><br><span class="line">        count --;</span><br><span class="line">        shiftDown(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最大堆中的堆顶元素</span></span><br><span class="line">    <span class="function">Item <span class="title">getMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">        assert( count &gt; <span class="number">0</span> );</span><br><span class="line">        <span class="keyword">return</span> data[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-基础堆排序"><a href="#2-基础堆排序" class="headerlink" title="2 基础堆排序"></a>2 基础堆排序</h4><p>基础堆排序在静态数据中的效率慢于常规排序算法，适用于动态数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// heapSort1, 将所有的元素依次添加到堆中, 在将所有元素从堆中依次取出来, 即完成了排序</span></span><br><span class="line"><span class="comment">// 无论是创建堆的过程, 还是从堆中依次取出元素的过程, 时间复杂度均为O(nlogn)</span></span><br><span class="line"><span class="comment">// 整个堆排序的整体时间复杂度为O(nlogn)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort1</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    MaxHeap&lt;T&gt; maxheap = MaxHeap&lt;T&gt;(n);</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++ )</span><br><span class="line">        maxheap.insert(arr[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = n<span class="number">-1</span> ; i &gt;= <span class="number">0</span> ; i-- )</span><br><span class="line">        arr[i] = maxheap.extractMax();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// heapSort2, 借助我们的heapify过程创建堆，整体添加到堆中</span></span><br><span class="line"><span class="comment">// 此时, 创建堆的过程时间复杂度为O(n), 将所有元素依次从堆中取出来, 实践复杂度为O(nlogn)</span></span><br><span class="line"><span class="comment">// 堆排序的总体时间复杂度依然是O(nlogn), 但是比上述heapSort1性能更优, 因为创建堆的性能更优</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort2</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    MaxHeap&lt;T&gt; maxheap = MaxHeap&lt;T&gt;(arr,n);</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = n<span class="number">-1</span> ; i &gt;= <span class="number">0</span> ; i-- )</span><br><span class="line">        arr[i] = maxheap.extractMax();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-优化堆排序"><a href="#3-优化堆排序" class="headerlink" title="3 优化堆排序"></a>3 优化堆排序</h4><p>原地堆排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原始的shiftDown过程</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> __shiftDown(T arr[], <span class="keyword">int</span> n, <span class="keyword">int</span> k)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>( <span class="number">2</span>*k+<span class="number">1</span> &lt; n )&#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">2</span>*k+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>( j+<span class="number">1</span> &lt; n &amp;&amp; arr[j+<span class="number">1</span>] &gt; arr[j] )</span><br><span class="line">            j += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( arr[k] &gt;= arr[j] )<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        swap( arr[k] , arr[j] );</span><br><span class="line">        k = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化的shiftDown过程, 使用赋值的方式取代不断的swap,</span></span><br><span class="line"><span class="comment">// 该优化思想和我们之前对插入排序进行优化的思路是一致的</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> __shiftDown2(T arr[], <span class="keyword">int</span> n, <span class="keyword">int</span> k)&#123;</span><br><span class="line"></span><br><span class="line">    T e = arr[k];</span><br><span class="line">    <span class="keyword">while</span>( <span class="number">2</span>*k+<span class="number">1</span> &lt; n )&#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">2</span>*k+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>( j+<span class="number">1</span> &lt; n &amp;&amp; arr[j+<span class="number">1</span>] &gt; arr[j] )</span><br><span class="line">            j += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( e &gt;= arr[j] ) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        arr[k] = arr[j];</span><br><span class="line">        k = j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    arr[k] = e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不使用一个额外的最大堆, 直接在原数组上进行原地的堆排序</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意，此时我们的堆是从0开始索引的</span></span><br><span class="line">    <span class="comment">// 从(最后一个元素的索引-1)/2开始</span></span><br><span class="line">    <span class="comment">// 最后一个元素的索引 = n-1</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = (n<span class="number">-1</span><span class="number">-1</span>)/<span class="number">2</span> ; i &gt;= <span class="number">0</span> ; i -- )</span><br><span class="line">        __shiftDown2(arr, n, i);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将顶部数据置于末尾，将树的容量减一，再次排序，也就是extractMax()</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt; <span class="number">0</span> ; i-- )&#123;</span><br><span class="line">        swap( arr[<span class="number">0</span>] , arr[i] );</span><br><span class="line">        __shiftDown2(arr, i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-索引堆"><a href="#4-索引堆" class="headerlink" title="4 索引堆"></a>4 索引堆</h4><figure class="image-box">                <img src="/2020/02/12/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%A0%86%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F/2.png" alt="索引堆" title class>                <p>索引堆</p>            </figure>   <p>对索引进行操作，而不是对值进行操作，可以在打乱顺序后找到数据对应的索引</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SortTestHelper.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大索引堆</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Item&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IndexMaxHeap</span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Item *data;     <span class="comment">// 最大索引堆中的数据</span></span><br><span class="line">    <span class="keyword">int</span> *indexes;   <span class="comment">// 最大索引堆中的索引</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 索引堆中, 数据之间的比较根据data的大小进行比较, 但实际操作的是索引</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shiftUp</span><span class="params">( <span class="keyword">int</span> k )</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( k &gt; <span class="number">1</span> &amp;&amp; data[indexes[k/<span class="number">2</span>]] &lt; data[indexes[k]] )&#123;</span><br><span class="line">            swap( indexes[k/<span class="number">2</span>] , indexes[k] );</span><br><span class="line">            k /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 索引堆中, 数据之间的比较根据data的大小进行比较, 但实际操作的是索引</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shiftDown</span><span class="params">( <span class="keyword">int</span> k )</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( <span class="number">2</span>*k &lt;= count )&#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">2</span>*k;</span><br><span class="line">            <span class="keyword">if</span>( j + <span class="number">1</span> &lt;= count &amp;&amp; data[indexes[j+<span class="number">1</span>]] &gt; data[indexes[j]] )</span><br><span class="line">                j += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( data[indexes[k]] &gt;= data[indexes[j]] )</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            swap( indexes[k] , indexes[j] );</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数, 构造一个空的索引堆, 可容纳capacity个元素</span></span><br><span class="line">    IndexMaxHeap(<span class="keyword">int</span> capacity)&#123;</span><br><span class="line"></span><br><span class="line">        data = <span class="keyword">new</span> Item[capacity+<span class="number">1</span>];</span><br><span class="line">        indexes = <span class="keyword">new</span> <span class="keyword">int</span>[capacity+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~IndexMaxHeap()&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data;</span><br><span class="line">        <span class="keyword">delete</span>[] indexes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回索引堆中的元素个数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个布尔值, 表示索引堆中是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向最大索引堆中插入一个新的元素, 新元素的索引为i, 元素为item</span></span><br><span class="line">    <span class="comment">// 传入的i对用户而言,是从0索引的</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> i, Item item)</span></span>&#123;</span><br><span class="line">        assert( count + <span class="number">1</span> &lt;= capacity );</span><br><span class="line">        assert( i + <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp; i + <span class="number">1</span> &lt;= capacity );</span><br><span class="line"></span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">        data[i] = item;</span><br><span class="line">        indexes[count+<span class="number">1</span>] = i;</span><br><span class="line">        count++;</span><br><span class="line"></span><br><span class="line">        shiftUp(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从最大索引堆中取出堆顶元素, 即索引堆中所存储的最大数据</span></span><br><span class="line">    <span class="function">Item <span class="title">extractMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">        assert( count &gt; <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">        Item ret = data[indexes[<span class="number">1</span>]];</span><br><span class="line">        swap( indexes[<span class="number">1</span>] , indexes[count] );</span><br><span class="line">        count--;</span><br><span class="line">        shiftDown(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从最大索引堆中取出堆顶元素的索引</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">extractMaxIndex</span><span class="params">()</span></span>&#123;</span><br><span class="line">        assert( count &gt; <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret = indexes[<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">        swap( indexes[<span class="number">1</span>] , indexes[count] );</span><br><span class="line">        count--;</span><br><span class="line">        shiftDown(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最大索引堆中的堆顶元素</span></span><br><span class="line">    <span class="function">Item <span class="title">getMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">        assert( count &gt; <span class="number">0</span> );</span><br><span class="line">        <span class="keyword">return</span> data[indexes[<span class="number">1</span>]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最大索引堆中的堆顶元素的索引</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMaxIndex</span><span class="params">()</span></span>&#123;</span><br><span class="line">        assert( count &gt; <span class="number">0</span> );</span><br><span class="line">        <span class="keyword">return</span> indexes[<span class="number">1</span>]<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最大索引堆中索引为i的元素</span></span><br><span class="line">    <span class="function">Item <span class="title">getItem</span><span class="params">( <span class="keyword">int</span> i )</span></span>&#123;</span><br><span class="line">        assert( i + <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp; i + <span class="number">1</span> &lt;= capacity );</span><br><span class="line">        <span class="keyword">return</span> data[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将最大索引堆中索引为i的元素修改为newItem</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">( <span class="keyword">int</span> i , Item newItem )</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">        data[i] = newItem;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到indexes[j] = i, j表示data[i]在堆中的位置</span></span><br><span class="line">        <span class="comment">// 之后shiftUp(j), 再shiftDown(j)</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= count ; j ++ )</span><br><span class="line">            <span class="keyword">if</span>( indexes[j] == i )&#123;</span><br><span class="line">                shiftUp(j);</span><br><span class="line">                shiftDown(j);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试索引堆中的索引数组index</span></span><br><span class="line">    <span class="comment">// 注意:这个测试在向堆中插入元素以后, 不进行extract操作有效</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">testIndexes</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> *copyIndexes = <span class="keyword">new</span> <span class="keyword">int</span>[count+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= count ; i ++ )</span><br><span class="line">            copyIndexes[i] = indexes[i];</span><br><span class="line"></span><br><span class="line">        copyIndexes[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">std</span>::sort(copyIndexes, copyIndexes + count + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在对索引堆中的索引进行排序后, 应该正好是1...count这count个索引</span></span><br><span class="line">        <span class="keyword">bool</span> res = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= count ; i ++ )</span><br><span class="line">            <span class="keyword">if</span>( copyIndexes[i<span class="number">-1</span>] + <span class="number">1</span> != copyIndexes[i] )&#123;</span><br><span class="line">                res = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span>[] copyIndexes;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( !res )&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"Error!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用最大索引堆进行堆排序, 来验证我们的最大索引堆的正确性</span></span><br><span class="line"><span class="comment">// 最大索引堆的主要作用不是用于排序, 我们在这里使用排序只是为了验证我们的最大索引堆实现的正确性</span></span><br><span class="line"><span class="comment">// 在后续的图论中, 无论是最小生成树算法, 还是最短路径算法, 我们都需要使用索引堆进行优化:)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSortUsingIndexMaxHeap</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    IndexMaxHeap&lt;T&gt; indexMaxHeap = IndexMaxHeap&lt;T&gt;(n);</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++ )</span><br><span class="line">        indexMaxHeap.insert( i , arr[i] );</span><br><span class="line">    assert( indexMaxHeap.testIndexes() );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = n<span class="number">-1</span> ; i &gt;= <span class="number">0</span> ; i -- )</span><br><span class="line">        arr[i] = indexMaxHeap.extractMax();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>* arr = SortTestHelper::generateRandomArray(n, <span class="number">0</span>, n);</span><br><span class="line">    SortTestHelper::testSort(<span class="string">"Heap Sort Using Index-Max-Heap"</span>, heapSortUsingIndexMaxHeap, arr, n);</span><br><span class="line">    <span class="keyword">delete</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-优化索引堆"><a href="#5-优化索引堆" class="headerlink" title="5 优化索引堆"></a>5 优化索引堆</h4><figure class="image-box">                <img src="/2020/02/12/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%A0%86%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F/3.png" alt="优化索引堆" title class>                <p>优化索引堆</p>            </figure>   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SortTestHelper.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大索引堆</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Item&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IndexMaxHeap</span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Item *data;     <span class="comment">// 最大索引堆中的数据</span></span><br><span class="line">    <span class="keyword">int</span> *indexes;   <span class="comment">// 最大索引堆中的索引, indexes[x] = i 表示索引i在x的位置</span></span><br><span class="line">    <span class="keyword">int</span> *reverse;   <span class="comment">// 最大索引堆中的反向索引, reverse[i] = x 表示索引i在x的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 索引堆中, 数据之间的比较根据data的大小进行比较, 但实际操作的是索引</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shiftUp</span><span class="params">( <span class="keyword">int</span> k )</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( k &gt; <span class="number">1</span> &amp;&amp; data[indexes[k/<span class="number">2</span>]] &lt; data[indexes[k]] )&#123;</span><br><span class="line">            swap( indexes[k/<span class="number">2</span>] , indexes[k] );</span><br><span class="line">            reverse[indexes[k/<span class="number">2</span>]] = k/<span class="number">2</span>;</span><br><span class="line">            reverse[indexes[k]] = k;</span><br><span class="line">            k /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 索引堆中, 数据之间的比较根据data的大小进行比较, 但实际操作的是索引</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shiftDown</span><span class="params">( <span class="keyword">int</span> k )</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( <span class="number">2</span>*k &lt;= count )&#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">2</span>*k;</span><br><span class="line">            <span class="keyword">if</span>( j + <span class="number">1</span> &lt;= count &amp;&amp; data[indexes[j+<span class="number">1</span>]] &gt; data[indexes[j]] )</span><br><span class="line">                j += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( data[indexes[k]] &gt;= data[indexes[j]] )</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            swap( indexes[k] , indexes[j] );</span><br><span class="line">            reverse[indexes[k]] = k;</span><br><span class="line">            reverse[indexes[j]] = j;</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数, 构造一个空的索引堆, 可容纳capacity个元素</span></span><br><span class="line">    IndexMaxHeap(<span class="keyword">int</span> capacity)&#123;</span><br><span class="line"></span><br><span class="line">        data = <span class="keyword">new</span> Item[capacity+<span class="number">1</span>];</span><br><span class="line">        indexes = <span class="keyword">new</span> <span class="keyword">int</span>[capacity+<span class="number">1</span>];</span><br><span class="line">        reverse = <span class="keyword">new</span> <span class="keyword">int</span>[capacity+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= capacity ; i ++ )</span><br><span class="line">            reverse[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~IndexMaxHeap()&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data;</span><br><span class="line">        <span class="keyword">delete</span>[] indexes;</span><br><span class="line">        <span class="keyword">delete</span>[] reverse;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回索引堆中的元素个数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个布尔值, 表示索引堆中是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向最大索引堆中插入一个新的元素, 新元素的索引为i, 元素为item</span></span><br><span class="line">    <span class="comment">// 传入的i对用户而言,是从0索引的</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> i, Item item)</span></span>&#123;</span><br><span class="line">        assert( count + <span class="number">1</span> &lt;= capacity );</span><br><span class="line">        assert( i + <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp; i + <span class="number">1</span> &lt;= capacity );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再插入一个新元素前,还需要保证索引i所在的位置是没有元素的。</span></span><br><span class="line">        assert( !contain(i) );</span><br><span class="line"></span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">        data[i] = item;</span><br><span class="line">        indexes[count+<span class="number">1</span>] = i;</span><br><span class="line">        reverse[i] = count+<span class="number">1</span>;</span><br><span class="line">        count++;</span><br><span class="line"></span><br><span class="line">        shiftUp(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从最大索引堆中取出堆顶元素, 即索引堆中所存储的最大数据</span></span><br><span class="line">    <span class="function">Item <span class="title">extractMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">        assert( count &gt; <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">        Item ret = data[indexes[<span class="number">1</span>]];</span><br><span class="line">        swap( indexes[<span class="number">1</span>] , indexes[count] );</span><br><span class="line">        reverse[indexes[count]] = <span class="number">0</span>;</span><br><span class="line">        count--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(count)&#123;</span><br><span class="line">            reverse[indexes[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">            shiftDown(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从最大索引堆中取出堆顶元素的索引</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">extractMaxIndex</span><span class="params">()</span></span>&#123;</span><br><span class="line">        assert( count &gt; <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret = indexes[<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">        swap( indexes[<span class="number">1</span>] , indexes[count] );</span><br><span class="line">        reverse[indexes[count]] = <span class="number">0</span>;</span><br><span class="line">        count--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(count) &#123;</span><br><span class="line">            reverse[indexes[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">            shiftDown(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最大索引堆中的堆顶元素</span></span><br><span class="line">    <span class="function">Item <span class="title">getMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">        assert( count &gt; <span class="number">0</span> );</span><br><span class="line">        <span class="keyword">return</span> data[indexes[<span class="number">1</span>]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最大索引堆中的堆顶元素的索引</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMaxIndex</span><span class="params">()</span></span>&#123;</span><br><span class="line">        assert( count &gt; <span class="number">0</span> );</span><br><span class="line">        <span class="keyword">return</span> indexes[<span class="number">1</span>]<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 看索引i所在的位置是否存在元素</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">contain</span><span class="params">( <span class="keyword">int</span> i )</span></span>&#123;</span><br><span class="line">        assert( i + <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp; i + <span class="number">1</span> &lt;= capacity );</span><br><span class="line">        <span class="keyword">return</span> reverse[i+<span class="number">1</span>] != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最大索引堆中索引为i的元素</span></span><br><span class="line">    <span class="function">Item <span class="title">getItem</span><span class="params">( <span class="keyword">int</span> i )</span></span>&#123;</span><br><span class="line">        assert( contain(i) );</span><br><span class="line">        <span class="keyword">return</span> data[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将最大索引堆中索引为i的元素修改为newItem</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">( <span class="keyword">int</span> i , Item newItem )</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        assert( contain(i) );</span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">        data[i] = newItem;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到indexes[j] = i, j表示data[i]在堆中的位置</span></span><br><span class="line">        <span class="comment">// 之后shiftUp(j), 再shiftDown(j)</span></span><br><span class="line"><span class="comment">//        for( int j = 1 ; j &lt;= count ; j ++ )</span></span><br><span class="line"><span class="comment">//            if( indexes[j] == i )&#123;</span></span><br><span class="line"><span class="comment">//                shiftUp(j);</span></span><br><span class="line"><span class="comment">//                shiftDown(j);</span></span><br><span class="line"><span class="comment">//                return;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有了 reverse 之后,</span></span><br><span class="line">        <span class="comment">// 我们可以非常简单的通过reverse直接定位索引i在indexes中的位置</span></span><br><span class="line">        shiftUp( reverse[i] );</span><br><span class="line">        shiftDown( reverse[i] );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试索引堆中的索引数组index和反向数组reverse</span></span><br><span class="line">    <span class="comment">// 注意:这个测试在向堆中插入元素以后, 不进行extract操作有效</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">testIndexesAndReverseIndexes</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> *copyIndexes = <span class="keyword">new</span> <span class="keyword">int</span>[count+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> *copyReverseIndexes = <span class="keyword">new</span> <span class="keyword">int</span>[count+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= count ; i ++ )&#123;</span><br><span class="line">            copyIndexes[i] = indexes[i];</span><br><span class="line">            copyReverseIndexes[i] = reverse[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        copyIndexes[<span class="number">0</span>] = copyReverseIndexes[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">std</span>::sort(copyIndexes, copyIndexes + count + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">std</span>::sort(copyReverseIndexes, copyReverseIndexes + count + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在对索引堆中的索引和反向索引进行排序后,</span></span><br><span class="line">        <span class="comment">// 两个数组都应该正好是1...count这count个索引</span></span><br><span class="line">        <span class="keyword">bool</span> res = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= count ; i ++ )</span><br><span class="line">            <span class="keyword">if</span>( copyIndexes[i<span class="number">-1</span>] + <span class="number">1</span> != copyIndexes[i] ||</span><br><span class="line">                    copyReverseIndexes[i<span class="number">-1</span>] + <span class="number">1</span> != copyReverseIndexes[i] )&#123;</span><br><span class="line">                res = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span>[] copyIndexes;</span><br><span class="line">        <span class="keyword">delete</span>[] copyReverseIndexes;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( !res )&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"Error!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= count ; i ++ )</span><br><span class="line">            <span class="keyword">if</span>( reverse[ indexes[i] ] != i )&#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"Error 2"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用最大索引堆进行堆排序, 来验证我们的最大索引堆的正确性</span></span><br><span class="line"><span class="comment">// 最大索引堆的主要作用不是用于排序, 我们在这里使用排序只是为了验证我们的最大索引堆实现的正确性</span></span><br><span class="line"><span class="comment">// 在后续的图论中, 无论是最小生成树算法, 还是最短路径算法, 我们都需要使用索引堆进行优化:)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSortUsingIndexMaxHeap</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    IndexMaxHeap&lt;T&gt; indexMaxHeap = IndexMaxHeap&lt;T&gt;(n);</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++ )</span><br><span class="line">        indexMaxHeap.insert( i , arr[i] );</span><br><span class="line">    assert( indexMaxHeap.testIndexesAndReverseIndexes() );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = n<span class="number">-1</span> ; i &gt;= <span class="number">0</span> ; i -- )</span><br><span class="line">        arr[i] = indexMaxHeap.extractMax();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>* arr = SortTestHelper::generateRandomArray(n, <span class="number">0</span>, n);</span><br><span class="line">    SortTestHelper::testSort(<span class="string">"Heap Sort Using Index-Max-Heap"</span>, heapSortUsingIndexMaxHeap, arr, n);</span><br><span class="line">    <span class="keyword">delete</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
            <tag> 算法与数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法课程笔记-排序算法</title>
      <link href="/2020/02/12/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2020/02/12/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h4 id="1-O-n-2"><a href="#1-O-n-2" class="headerlink" title="1 O(n)2"></a>1 O(n)2</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++)&#123;</span><br><span class="line">    <span class="comment">// 寻找[i, n)区间里的最小值</span></span><br><span class="line">    <span class="keyword">int</span> minIndex = i;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> j = i + <span class="number">1</span> ; j &lt; n ; j ++ )</span><br><span class="line">        <span class="keyword">if</span>( arr[j] &lt; arr[minIndex] )</span><br><span class="line">            minIndex = j;</span><br><span class="line"></span><br><span class="line">    swap( arr[i] , arr[minIndex] );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-插入排序"><a href="#2-插入排序" class="headerlink" title="2 插入排序"></a>2 插入排序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; i ++ ) &#123;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">// 寻找元素arr[i]合适的插入位置</span></span><br><span class="line">     <span class="comment">// 写法1</span></span><br><span class="line">     <span class="keyword">for</span>( <span class="keyword">int</span> j = i ; j &gt; <span class="number">0</span> ; j-- )</span><br><span class="line">         <span class="keyword">if</span>( arr[j] &lt; arr[j<span class="number">-1</span>] )</span><br><span class="line">             swap( arr[j] , arr[j<span class="number">-1</span>] );</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">// 写法2</span></span><br><span class="line">     <span class="keyword">for</span>( <span class="keyword">int</span> j = i ; j &gt; <span class="number">0</span> &amp;&amp; arr[j] &lt; arr[j<span class="number">-1</span>] ; j -- )</span><br><span class="line">         swap( arr[j] , arr[j<span class="number">-1</span>] );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-插入排序优化"><a href="#3-插入排序优化" class="headerlink" title="3 插入排序优化"></a>3 插入排序优化</h4><p>swap交换需要赋值三次，可以改进。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++)&#123;</span><br><span class="line">    T e = arr[i];</span><br><span class="line">    <span class="keyword">int</span> j; <span class="comment">// j保存元素e应该插入的位置</span></span><br><span class="line">    <span class="keyword">for</span> (j = i; j &gt; <span class="number">0</span> &amp;&amp; arr[j<span class="number">-1</span>] &gt; e; j--)</span><br><span class="line">        arr[j] = arr[j<span class="number">-1</span>];</span><br><span class="line">    arr[j] = e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-冒泡排序"><a href="#4-冒泡排序" class="headerlink" title="4 冒泡排序"></a>4 冒泡排序</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">bool swapped;</span><br><span class="line"></span><br><span class="line">    do&#123;</span><br><span class="line">        swapped &#x3D; false;</span><br><span class="line">        for( int i &#x3D; 1 ; i &lt; n ; i ++ )</span><br><span class="line">            if( arr[i-1] &gt; arr[i] )&#123;</span><br><span class="line">                swap( arr[i-1] , arr[i] );</span><br><span class="line">                swapped &#x3D; true;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 优化, 每一趟Bubble Sort都将最大的元素放在了最后的位置</span><br><span class="line">        &#x2F;&#x2F; 所以下一次排序, 最后的元素可以不再考虑</span><br><span class="line">        n --;</span><br><span class="line"></span><br><span class="line">    &#125;while(swapped);</span><br></pre></td></tr></table></figure><h4 id="5-希尔排序"><a href="#5-希尔排序" class="headerlink" title="5 希尔排序"></a>5 希尔排序</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 计算 increment sequence: 1, 4, 13, 40, 121, 364, 1093...</span><br><span class="line">    int h &#x3D; 1;</span><br><span class="line">    while( h &lt; n&#x2F;3 )</span><br><span class="line">        h &#x3D; 3 * h + 1;</span><br><span class="line"></span><br><span class="line">    while( h &gt;&#x3D; 1 )&#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; h-sort the array</span><br><span class="line">        for( int i &#x3D; h ; i &lt; n ; i ++ )&#123;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 对 arr[i], arr[i-h], arr[i-2*h], arr[i-3*h]... 使用插入排序</span><br><span class="line">            T e &#x3D; arr[i];</span><br><span class="line">            int j;</span><br><span class="line">            for( j &#x3D; i ; j &gt;&#x3D; h &amp;&amp; e &lt; arr[j-h] ; j -&#x3D; h )</span><br><span class="line">                arr[j] &#x3D; arr[j-h];</span><br><span class="line">            arr[j] &#x3D; e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        h &#x2F;&#x3D; 3;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="6-归并排序"><a href="#6-归并排序" class="headerlink" title="6 归并排序"></a>6 归并排序</h4><p>数组分成两半进行排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __merge(T arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> mid, <span class="keyword">int</span> r)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//* VS不支持动态长度数组, 即不能使用 T aux[r-l+1]的方式申请aux的空间</span></span><br><span class="line">    <span class="comment">//* 使用VS的同学, 请使用new的方式申请aux空间</span></span><br><span class="line">    <span class="comment">//* 使用new申请空间, 不要忘了在__merge函数的最后, delete掉申请的空间:)</span></span><br><span class="line">    T aux[r-l+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//T *aux = new T[r-l+1];</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = l ; i &lt;= r; i ++ )</span><br><span class="line">        aux[i-l] = arr[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化，i指向左半部分的起始索引位置l；j指向右半部分起始索引位置mid+1</span></span><br><span class="line">    <span class="keyword">int</span> i = l, j = mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> k = l ; k &lt;= r; k ++ )&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( i &gt; mid )&#123;  <span class="comment">// 如果左半部分元素已经全部处理完毕</span></span><br><span class="line">            arr[k] = aux[j-l]; j ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( j &gt; r )&#123;  <span class="comment">// 如果右半部分元素已经全部处理完毕</span></span><br><span class="line">            arr[k] = aux[i-l]; i ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( aux[i-l] &lt; aux[j-l] ) &#123;  <span class="comment">// 左半部分所指元素 &lt; 右半部分所指元素</span></span><br><span class="line">            arr[k] = aux[i-l]; i ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;  <span class="comment">// 左半部分所指元素 &gt;= 右半部分所指元素</span></span><br><span class="line">            arr[k] = aux[j-l]; j ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//delete[] aux;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归使用归并排序,对arr[l...r]的范围进行排序</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> __mergeSort(T arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)&#123;</span><br><span class="line">    <span class="comment">//判断数组合法性</span></span><br><span class="line">    <span class="keyword">if</span>( l &gt;= r )</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">    __mergeSort(arr, l, mid);</span><br><span class="line">    __mergeSort(arr, mid+<span class="number">1</span>, r);</span><br><span class="line">    __merge(arr, l, mid, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    __mergeSort( arr , <span class="number">0</span> , n<span class="number">-1</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-归并排序优化"><a href="#7-归并排序优化" class="headerlink" title="7 归并排序优化"></a>7 归并排序优化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> __mergeSort2(T arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 优化2: 对于小规模数组, 使用插入排序</span></span><br><span class="line">    <span class="keyword">if</span>( r - l &lt;= <span class="number">15</span> )&#123;</span><br><span class="line">        insertionSort(arr, l, r);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">    __mergeSort2(arr, l, mid);</span><br><span class="line">    __mergeSort2(arr, mid+<span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 优化1: 对于arr[mid] &lt;= arr[mid+1]的情况,即完全有序，不进行merge</span></span><br><span class="line">    <span class="comment">// 对于近乎有序的数组非常有效,但是对于一般情况,有一定的性能损失</span></span><br><span class="line">    <span class="keyword">if</span>( arr[mid] &gt; arr[mid+<span class="number">1</span>] )</span><br><span class="line">        __merge(arr, l, mid, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort2</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    __mergeSort2( arr , <span class="number">0</span> , n<span class="number">-1</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-自底向上归并排序"><a href="#8-自底向上归并排序" class="headerlink" title="8 自底向上归并排序"></a>8 自底向上归并排序</h4><p>变递归为迭代，而且可用于链表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSortBU</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Merge Sort Bottom Up 无优化版本</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> sz = <span class="number">1</span>; sz &lt; n ; sz += sz )</span><br><span class="line">        <span class="comment">//保证i+sz&lt;n</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n - sz ; i += sz+sz )</span><br><span class="line">            <span class="comment">// 对 arr[i...i+sz-1] 和 arr[i+sz...i+2*sz-1] 进行归并</span></span><br><span class="line">            __merge(arr, i, i+sz<span class="number">-1</span>, <span class="built_in">min</span>(i+sz+sz<span class="number">-1</span>,n<span class="number">-1</span>) );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Merge Sort Bottom Up 优化</span></span><br><span class="line">    <span class="comment">// 对于小数组, 使用插入排序优化</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i += <span class="number">16</span> )</span><br><span class="line">        insertionSort(arr,i,<span class="built_in">min</span>(i+<span class="number">15</span>,n<span class="number">-1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> sz = <span class="number">16</span>; sz &lt; n ; sz += sz )</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n - sz ; i += sz+sz )</span><br><span class="line">            <span class="comment">// 对于arr[mid] &lt;= arr[mid+1]的情况,不进行merge</span></span><br><span class="line">            <span class="keyword">if</span>( arr[i+sz<span class="number">-1</span>] &gt; arr[i+sz] )</span><br><span class="line">                __merge(arr, i, i+sz<span class="number">-1</span>, <span class="built_in">min</span>(i+sz+sz<span class="number">-1</span>,n<span class="number">-1</span>) );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Merge Sort BU 也是一个O(nlogn)复杂度的算法，虽然只使用两重for循环</span></span><br><span class="line">    <span class="comment">// 所以，Merge Sort BU也可以在1秒之内轻松处理100万数量级的数据</span></span><br><span class="line">    <span class="comment">// 注意：不要轻易根据循环层数来判断算法的复杂度，Merge Sort BU就是一个反例</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较Merge Sort和Merge Sort Bottom Up两种排序算法的性能效率</span></span><br><span class="line"><span class="comment">// 整体而言, 两种算法的效率是差不多的。但是如果进行仔细测试, 自底向上的归并排序会略胜一筹。</span></span><br></pre></td></tr></table></figure><h4 id="9-快速排序"><a href="#9-快速排序" class="headerlink" title="9 快速排序"></a>9 快速排序</h4><p>将第一个元素作为标记点，找到该标记的正确位置，之前的元素小于标记元素，之后的元素大于标记元素。</p><figure class="image-box">                <img src="/2020/02/12/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/1.png" alt="快速排序" title class>                <p>快速排序</p>            </figure> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __partition(T arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)&#123;</span><br><span class="line"></span><br><span class="line">    T v = arr[l];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> j = l; <span class="comment">// arr[l+1...j] &lt; v ; arr[j+1...i) &gt; v</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = l + <span class="number">1</span> ; i &lt;= r ; i ++ )</span><br><span class="line">        <span class="keyword">if</span>( arr[i] &lt; v )&#123;</span><br><span class="line">            j ++;</span><br><span class="line">            swap( arr[j] , arr[i] );</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//最后将v放入正确位置</span></span><br><span class="line">    swap( arr[l] , arr[j]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对arr[l...r]部分进行快速排序</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> __quickSort(T arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( l &gt;= r )</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> p = __partition(arr, l, r);</span><br><span class="line">    __quickSort(arr, l, p<span class="number">-1</span> );</span><br><span class="line">    __quickSort(arr, p+<span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    __quickSort(arr, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较Merge Sort和Quick Sort两种排序算法的性能效率</span></span><br><span class="line"><span class="comment">// 两种排序算法虽然都是O(nlogn)级别的, 但是Quick Sort算法有常数级的优势</span></span><br><span class="line"><span class="comment">// Quick Sort要比Merge Sort快, 即使我们对Merge Sort进行了优化</span></span><br></pre></td></tr></table></figure><h4 id="10-随机化快速排序"><a href="#10-随机化快速排序" class="headerlink" title="10 随机化快速排序"></a>10 随机化快速排序</h4><p>随机选择标定点，改善近似顺序列表排序性能</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对arr[l...r]部分进行partition操作</span></span><br><span class="line"><span class="comment">// 返回p, 使得arr[l...p-1] &lt; arr[p] ; arr[p+1...r] &gt; arr[p]</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> _partition(T arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 随机在arr[l...r]的范围中, 选择一个数值作为标定点pivot</span></span><br><span class="line">    swap( arr[l] , arr[rand()%(r-l+<span class="number">1</span>)+l] );</span><br><span class="line"></span><br><span class="line">    T v = arr[l];</span><br><span class="line">    <span class="keyword">int</span> j = l;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = l + <span class="number">1</span> ; i &lt;= r ; i ++ )</span><br><span class="line">        <span class="keyword">if</span>( arr[i] &lt; v )&#123;</span><br><span class="line">            j ++;</span><br><span class="line">            swap( arr[j] , arr[i] );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    swap( arr[l] , arr[j]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对arr[l...r]部分进行快速排序</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> _quickSort(T arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于小规模数组, 使用插入排序进行优化</span></span><br><span class="line">    <span class="keyword">if</span>( r - l &lt;= <span class="number">15</span> )&#123;</span><br><span class="line">        insertionSort(arr,l,r);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> p = _partition(arr, l, r);</span><br><span class="line">    _quickSort(arr, l, p<span class="number">-1</span> );</span><br><span class="line">    _quickSort(arr, p+<span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    _quickSort(arr, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11-双路快速排序"><a href="#11-双路快速排序" class="headerlink" title="11 双路快速排序"></a>11 双路快速排序</h4><p>从两头向中间执行partition，使等于v的元素分散在两边，使两部分尽量平衡，适用于大量重复数据的场合</p><figure class="image-box">                <img src="/2020/02/12/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/2.png" alt="双路快速排序" title class>                <p>双路快速排序</p>            </figure> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双路快速排序的partition</span></span><br><span class="line"><span class="comment">// 返回p, 使得arr[l...p-1] &lt;= arr[p] ; arr[p+1...r] &gt;= arr[p]</span></span><br><span class="line"><span class="comment">// 双路快排处理的元素正好等于arr[p]的时候要注意，详见下面的注释：）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> _partition2(T arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 随机在arr[l...r]的范围中, 选择一个数值作为标定点pivot</span></span><br><span class="line">    swap( arr[l] , arr[rand()%(r-l+<span class="number">1</span>)+l] );</span><br><span class="line">    T v = arr[l];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// arr[l+1...i) &lt;= v; arr(j...r] &gt;= v</span></span><br><span class="line">    <span class="keyword">int</span> i = l+<span class="number">1</span>, j = r;</span><br><span class="line">    <span class="keyword">while</span>( <span class="literal">true</span> )&#123;</span><br><span class="line">        <span class="comment">// 注意这里的边界, arr[i] &lt; v, 不能是arr[i] &lt;= v</span></span><br><span class="line">        <span class="keyword">while</span>( i &lt;= r &amp;&amp; arr[i] &lt; v )</span><br><span class="line">            i ++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意这里的边界, arr[j] &gt; v, 不能是arr[j] &gt;= v</span></span><br><span class="line">        <span class="keyword">while</span>( j &gt;= l+<span class="number">1</span> &amp;&amp; arr[j] &gt; v )</span><br><span class="line">            j --;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 多了个等号的判断会造成两棵子树不平衡</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( i &gt; j )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        swap( arr[i] , arr[j] );</span><br><span class="line">        i ++;</span><br><span class="line">        j --;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    swap( arr[l] , arr[j]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对arr[l...r]部分进行快速排序</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> _quickSort(T arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于小规模数组, 使用插入排序进行优化</span></span><br><span class="line">    <span class="keyword">if</span>( r - l &lt;= <span class="number">15</span> )&#123;</span><br><span class="line">        insertionSort(arr,l,r);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用双路快速排序的partition</span></span><br><span class="line">    <span class="keyword">int</span> p = _partition2(arr, l, r);</span><br><span class="line">    _quickSort(arr, l, p<span class="number">-1</span> );</span><br><span class="line">    _quickSort(arr, p+<span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    _quickSort(arr, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="12-三路快速排序"><a href="#12-三路快速排序" class="headerlink" title="12 三路快速排序"></a>12 三路快速排序</h4><figure class="image-box">                <img src="/2020/02/12/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/3.png" alt="三路快速排序" title class>                <p>三路快速排序</p>            </figure> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归的三路快速排序算法</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> __quickSort3Ways(T arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于小规模数组, 使用插入排序进行优化</span></span><br><span class="line">    <span class="keyword">if</span>( r - l &lt;= <span class="number">15</span> )&#123;</span><br><span class="line">        insertionSort(arr,l,r);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 随机在arr[l...r]的范围中, 选择一个数值作为标定点pivot</span></span><br><span class="line">    swap( arr[l], arr[rand()%(r-l+<span class="number">1</span>)+l ] );</span><br><span class="line"></span><br><span class="line">    T v = arr[l];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> lt = l;     <span class="comment">// arr[l+1...lt] &lt; v</span></span><br><span class="line">    <span class="keyword">int</span> gt = r + <span class="number">1</span>; <span class="comment">// arr[gt...r] &gt; v</span></span><br><span class="line">    <span class="keyword">int</span> i = l+<span class="number">1</span>;    <span class="comment">// arr[lt+1...i) == v</span></span><br><span class="line">    <span class="keyword">while</span>( i &lt; gt )&#123;</span><br><span class="line">        <span class="keyword">if</span>( arr[i] &lt; v )&#123;</span><br><span class="line">            swap( arr[i], arr[lt+<span class="number">1</span>]);</span><br><span class="line">            i ++;</span><br><span class="line">            lt ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( arr[i] &gt; v )&#123;</span><br><span class="line">            swap( arr[i], arr[gt<span class="number">-1</span>]);</span><br><span class="line">            gt --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123; <span class="comment">// arr[i] == v</span></span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    swap( arr[l] , arr[lt] );</span><br><span class="line"></span><br><span class="line">    __quickSort3Ways(arr, l, lt<span class="number">-1</span>);</span><br><span class="line">    __quickSort3Ways(arr, gt, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort3Ways</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    __quickSort3Ways( arr, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较Merge Sort和双路快速排序和三路快排三种排序算法的性能效率</span></span><br><span class="line"><span class="comment">// 对于包含有大量重复数据的数组, 三路快排有巨大的优势</span></span><br><span class="line"><span class="comment">// 对于一般性的随机数组和近乎有序的数组, 三路快排的效率虽然不是最优的, 但是是在非常可以接受的范围里</span></span><br><span class="line"><span class="comment">// 因此, 在一些语言中, 三路快排是默认的语言库函数中使用的排序算法。比如Java:)</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
            <tag> 算法与数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统课程学习笔记三-操作系统用户界面</title>
      <link href="/2020/02/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2/"/>
      <url>/2020/02/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="第三章-操作系统用户界面"><a href="#第三章-操作系统用户界面" class="headerlink" title="第三章 操作系统用户界面"></a>第三章 操作系统用户界面</h1><h4 id="3-1-BIOS中断是INT-XXh的形式，例如INT-13H是磁盘读写服务。那么INT-21H与这些BIOS中断的机制是不是一样的呢？"><a href="#3-1-BIOS中断是INT-XXh的形式，例如INT-13H是磁盘读写服务。那么INT-21H与这些BIOS中断的机制是不是一样的呢？" class="headerlink" title="3.1 BIOS中断是INT XXh的形式，例如INT 13H是磁盘读写服务。那么INT 21H与这些BIOS中断的机制是不是一样的呢？"></a>3.1 BIOS中断是INT XXh的形式，例如INT 13H是磁盘读写服务。那么INT 21H与这些BIOS中断的机制是不是一样的呢？</h4><p>机制一样，但实现方法有区别。二者都是中断，过程表现为识别中断源、保护断点和现场、装入中断服务程序的入口地址、进入中断服务程序、结束中断程序后恢复现场和断点、中断返回。但BIOS中断由硬件电路实现，INT 21H由软件程序指令实现。</p><h4 id="3-2-操作系统的初始引导过程涉及哪些程序模块，各自存放的介质是什么，存放的形式是什么？"><a href="#3-2-操作系统的初始引导过程涉及哪些程序模块，各自存放的介质是什么，存放的形式是什么？" class="headerlink" title="3.2 操作系统的初始引导过程涉及哪些程序模块，各自存放的介质是什么，存放的形式是什么？"></a>3.2 操作系统的初始引导过程涉及哪些程序模块，各自存放的介质是什么，存放的形式是什么？</h4><p>操作系统初始引导是指通过引导程序把操作系统核心装入内存并使之接管计算机系统的过程。首先BIOS读取MRB引导程序到内存运行，MRB的引导程序根据BIOS提供的参数读取硬盘指定位置的文件到内存，该文件加载指定操作系统的内核并初始化基本参数，操作系统内核逐步加载剩余操作系统程序，最后完全控制计算机。</p><h4 id="3-3-比较DOS、Windows7与Linux早期版本都有哪些典型的操作界面？操作界面对普通用户（办公或娱乐）选择操作系统有何影响？"><a href="#3-3-比较DOS、Windows7与Linux早期版本都有哪些典型的操作界面？操作界面对普通用户（办公或娱乐）选择操作系统有何影响？" class="headerlink" title="3.3 比较DOS、Windows7与Linux早期版本都有哪些典型的操作界面？操作界面对普通用户（办公或娱乐）选择操作系统有何影响？"></a>3.3 比较DOS、Windows7与Linux早期版本都有哪些典型的操作界面？操作界面对普通用户（办公或娱乐）选择操作系统有何影响？</h4><p>主要有GUI界面（win7）和命令行（DOS、Linux）两种。GUI界面更易被初学者或普通用户接受，操作简单并且可以浏览使用各种图形数据，命令行界面的操作需要学会使用指令，入门成本高，且难以处理复杂图像应用。</p><h4 id="3-4-Linux的Shell能否看成操作系统的内核功能？如何理解Shell与内核之间的交互？"><a href="#3-4-Linux的Shell能否看成操作系统的内核功能？如何理解Shell与内核之间的交互？" class="headerlink" title="3.4 Linux的Shell能否看成操作系统的内核功能？如何理解Shell与内核之间的交互？"></a>3.4 Linux的Shell能否看成操作系统的内核功能？如何理解Shell与内核之间的交互？</h4><p>不能。Shell可以看作是用户和操作系统信息交互的中间桥梁。用户用过Shell将命令下达给操作系统，操作系统通过Shell将需要展示给用户的信息返回，Shell本身不执行命令，仅仅是组织和管理命令。</p><h4 id="3-5-printf，open都是Linux中典型的隐式系统调用。当我们在“为Linux内核增加新的系统调用实验”中增加一个新的系统调用后，我们在应用程序中是如何调用的它们的？为何我们不能像printf，open等函数一样简单地调用？"><a href="#3-5-printf，open都是Linux中典型的隐式系统调用。当我们在“为Linux内核增加新的系统调用实验”中增加一个新的系统调用后，我们在应用程序中是如何调用的它们的？为何我们不能像printf，open等函数一样简单地调用？" class="headerlink" title="3.5 printf，open都是Linux中典型的隐式系统调用。当我们在“为Linux内核增加新的系统调用实验”中增加一个新的系统调用后，我们在应用程序中是如何调用的它们的？为何我们不能像printf，open等函数一样简单地调用？"></a>3.5 printf，open都是Linux中典型的隐式系统调用。当我们在“为Linux内核增加新的系统调用实验”中增加一个新的系统调用后，我们在应用程序中是如何调用的它们的？为何我们不能像printf，open等函数一样简单地调用？</h4><p>不能。printf和open是高级语言的API接口，Linux中隐式系统调用也会在编译时转化为显式的系统调用，最终用到INT80h。我们在自己制作的操作系统中加入的自定义系统调用，并没有现成的高级语言API接口供我们使用，可以通过汇编语言调用INT80端口使用或封装成高级语言API接口直接调用。</p><h3 id="单元作业"><a href="#单元作业" class="headerlink" title="单元作业"></a>单元作业</h3><h4 id="1-系统BIOS的功能有哪些？"><a href="#1-系统BIOS的功能有哪些？" class="headerlink" title="1 系统BIOS的功能有哪些？"></a>1 系统BIOS的功能有哪些？</h4><p>BIOS全程Basic I/O System，是一种固件（Firmware），是以硬件形式储存的软件，储存主板启动配置信息、基本设备I/O服务，完成系统的加电自检、初始化基本硬件。</p><h4 id="2-计算机加电后执行的第一条指令存放在哪里，有什么特点？"><a href="#2-计算机加电后执行的第一条指令存放在哪里，有什么特点？" class="headerlink" title="2 计算机加电后执行的第一条指令存放在哪里，有什么特点？"></a>2 计算机加电后执行的第一条指令存放在哪里，有什么特点？</h4><p>BIOS的指令位置位于F0000-FFFFF处，按下开机或重启键后执行的第一条指令位于FFFFQ处，执行JUMP POST（加电自检）动作，POST位于BIOS内部，该指令由硬件电路实现，功能是初始化基本硬件，若自检错误通过喇叭或数显二极管的方式提示。</p><h4 id="3-何为操作系统的生成？简述Linux内核的生成过程。"><a href="#3-何为操作系统的生成？简述Linux内核的生成过程。" class="headerlink" title="3 何为操作系统的生成？简述Linux内核的生成过程。"></a>3 何为操作系统的生成？简述Linux内核的生成过程。</h4><p>​操作系统的生成是指满足特定硬件环境和用户需要，组装和构建操作系统的过程。<br>Linux操作系统的生成过程如下：</p><p>1、获取Linux内核的源代码</p><p>2、选择和启动内核配置程序</p><p>3、根据需要配置内核模块的参数</p><p>4、程序编译新的内核</p><p>5、编译和安装模块</p><p>6、启动新内核</p><h4 id="4-何为用户界面？有哪些类别？各有什么特点？"><a href="#4-何为用户界面？有哪些类别？各有什么特点？" class="headerlink" title="4 何为用户界面？有哪些类别？各有什么特点？"></a>4 何为用户界面？有哪些类别？各有什么特点？</h4><p>用户界面是指操作系统提供给用户控制计算机的机制，又称用户接口。分为操作界面和系统调用。</p><p>操作界面通过GUI或控制台接受普通命令、批处理程序或Shell指令，一般不涉及核心资源或硬件操作。</p><p>系统调用需要操作系统内核为应用程序提供服务或函数，CPU运行于核态，调用过程会产生自愿中断。</p><h4 id="5-何为shell？有哪4类典型的shell？"><a href="#5-何为shell？有哪4类典型的shell？" class="headerlink" title="5 何为shell？有哪4类典型的shell？"></a>5 何为shell？有哪4类典型的shell？</h4><p>Shell可以看作是用户和操作系统信息交互的中间桥梁。用户用过Shell将命令下达给操作系统，操作系统通过Shell将需要展示给用户的信息返回，Shell本身不执行命令，仅仅是组织和管理命令。</p><p>Shell有Bsh、Csh、Ksh、Bash四种，前三种是早期版本，各有优缺点，Bsh有较强编程功能，Csh交互方便，Ksh结合Bsh和Csh优势，Bash是Bsh的升级并且吸收了Ksh的特性。</p><h4 id="6-何为输出重定向？举一个Linux或Windows中的重定向的应用命令或例子。"><a href="#6-何为输出重定向？举一个Linux或Windows中的重定向的应用命令或例子。" class="headerlink" title="6 何为输出重定向？举一个Linux或Windows中的重定向的应用命令或例子。"></a>6 何为输出重定向？举一个Linux或Windows中的重定向的应用命令或例子。</h4><p>输出重定向是指将命令输出由默认的显示器更改为指定的文件。</p><p>在Linux命令行中输入<code>ls /etc/ &gt; etcdir.log</code>，可以将原本会在命令行中显示的etc目录信息储存在当前目录下的etcdir.log文件中。</p><h4 id="7-试述运行shell脚本程序的三种方式？"><a href="#7-试述运行shell脚本程序的三种方式？" class="headerlink" title="7 试述运行shell脚本程序的三种方式？"></a>7 试述运行shell脚本程序的三种方式？</h4><p>第一种是直接运行，用缺省版本的Shell运行程序；</p><p>第二种是使用特定版本，在运行程序时输入Shell版本+程序名可以使用特定版本，如bash my_script 。</p><p>第三种是在脚本文件首行指定。在脚本开头加一行：#!/bin/bush 。</p><h4 id="8-系统调用与普通用户态函数比较，有何异同点？"><a href="#8-系统调用与普通用户态函数比较，有何异同点？" class="headerlink" title="8 系统调用与普通用户态函数比较，有何异同点？"></a>8 系统调用与普通用户态函数比较，有何异同点？</h4><p>系统调用一般设计核心资源或硬件的操作，CPU运行于核态，每个系统调用具有唯一ID，调用过程会产生自愿中断，实现过程较复杂。相同点是都属于用户接口，实现用户对计算机的控制。</p><h4 id="9-何为隐式系统调用？"><a href="#9-何为隐式系统调用？" class="headerlink" title="9 何为隐式系统调用？"></a>9 何为隐式系统调用？</h4><p>隐式调用是指通过高级语言的API接口在编译时转化为显式的系统调用，最终用到特定的中断执行系统调用指令。使用隐式系统调用可以快捷方便的使用计算的机某些内核资源。</p><h4 id="10-试述Linux系统调用-INT-80H-的工作原理？"><a href="#10-试述Linux系统调用-INT-80H-的工作原理？" class="headerlink" title="10 试述Linux系统调用(INT 80H)的工作原理？"></a>10 试述Linux系统调用(INT 80H)的工作原理？</h4><p>应用程序调用库函数（API）；</p><p>API将系统调用号存入EAX，然后通过中断调用使系统进入内核态；</p><p>内核中的中断处理函数根据系统调用号，调用对应的内核函数（系统调用）；</p><p>系统调用完成相应功能，将返回值存入EAX，返回到中断处理函数；</p><p>中断处理函数返回到API中；</p><p>API将EAX返回给应用程序。</p><h4 id="11-试述为Linux增加新的系统调用的过程？"><a href="#11-试述为Linux增加新的系统调用的过程？" class="headerlink" title="11 试述为Linux增加新的系统调用的过程？"></a>11 试述为Linux增加新的系统调用的过程？</h4><p>1、在sys.c中加入函数</p><p>2、添加声明</p><p>3、添加ID</p><p>4、重新配置安装内核</p><h4 id="12-回顾汇编语言中关于寄存器结构和定义部分的知识，理解各个寄存器的基本作用和用法。"><a href="#12-回顾汇编语言中关于寄存器结构和定义部分的知识，理解各个寄存器的基本作用和用法。" class="headerlink" title="12 回顾汇编语言中关于寄存器结构和定义部分的知识，理解各个寄存器的基本作用和用法。"></a>12 回顾汇编语言中关于寄存器结构和定义部分的知识，理解各个寄存器的基本作用和用法。</h4><p>寄存器是中央处理器内的组成部份。寄存器是有限存贮容量的高速存贮部件，它们可用来暂存指令、数据和位址。在中央处理器的控制部件中，包含的寄存器有指令寄存器(IR)和程序计数器(PC)。在中央处理器的算术及逻辑部件中，包含的寄存器有累加器(ACC)。</p><p>寄存器的作用：可将寄存器内的数据执行算术及逻辑运算；存于寄存器内的地址可用来指向内存的某个位置，即寻址；可以用来读写数据到电脑的周边设备。</p><p>数据寄存器主要用来保存操作数和运算结果等信息，从而节省读取操作数所需占用总线和访问存储器的时间。</p><p>寄存器 ESI、EDI称为变址寄存器(Index Register)，它们主要用于存放存储单元在段内的偏移量，用它们可实现多种存储器操作数的寻址方式，为以不同的地址形式访问存储单元提供方便。</p><p>寄存器EBP、ESP、BP和SP称为指针寄存器(Pointer Register)，主要用于存放堆栈内存储单元的偏移量，用它们可实现多种存储器操作数的寻址方式，为以不同的地址形式访问存储单元提供方便。</p><p>段寄存器是根据内存分段的管理模式而设置的。内存单元的物理地址由段寄存器的值和一个偏移量组合而成的，这样可用两个较少位数的值组合成一个可访问较大物理空间的内存地址。</p><p>​指令指针EIP、IP(InstructionPointer)是存放下次将要执行的指令在代码段的偏移量。</p><p>标志寄存器用于实现特定功能。</p><h4 id="13-尝试去理解用-menucofig命令去配置Linux内核时，配置界面上每个条目的含义和作用？"><a href="#13-尝试去理解用-menucofig命令去配置Linux内核时，配置界面上每个条目的含义和作用？" class="headerlink" title="13 尝试去理解用 menucofig命令去配置Linux内核时，配置界面上每个条目的含义和作用？"></a>13 尝试去理解用 menucofig命令去配置Linux内核时，配置界面上每个条目的含义和作用？</h4><p>Code maturity level options：代码成熟等级</p><p>Loadable module support：对模块的支持</p><p>General setup：常规内核选项</p><p>Memory Technology Devices (MTD)：配置存储设备</p><p>Parallel port support：配置并口</p><p>Plug and Play configuration：即插即用支持</p><p>Block devices：块设备支持</p><p>Multiple devices driver support：多设备驱动支持</p><p>Networking options：网络选项</p><p>Telephony Support：电话支持</p><p>ATA/IDE/MFM/RLL support：配置对ATA，IDE，MFM和RLL的支持</p><p>SCSI support：SCSI设备的支持</p><p>I2O Device Support：I20设备支持</p><p>Network Device Support：网络设备支持</p><p>Amateur Radio support：配置业余广播支持</p><p>IrDA（infrared）support：配置红外线（无线）通讯支持</p><p>ISDN subsystem：配置ISDN</p><p>Old CD-ROM drivers（not SCSI、not IDE）：配置老CDROM</p><p>Input Core Support：提供USB支持</p><p>Character devices：字符设备</p><p>Multimedia Devices：配置多媒体设备</p><p>File System：配置文件系统</p><p>Console drivers：配置控制台驱动</p><p>USB support：配置USB支持</p><p>kernel hacking：配置“kernel hacking”</p><p>​<a href="https://blog.csdn.net/xuyuefei1988/article/details/8635539" target="_blank" rel="noopener">https://blog.csdn.net/xuyuefei1988/article/details/8635539</a></p><h4 id="14-在Linux上练习使用管道命令。"><a href="#14-在Linux上练习使用管道命令。" class="headerlink" title="14 在Linux上练习使用管道命令。"></a>14 在Linux上练习使用管道命令。</h4><p><code>curl -s https://api.github.com/repos/iissnan/hexo-theme-next/releases/latest | grep tarball_url | cut -d &#39;&quot;&#39; -f 4 | wget -i - -O- | tar -zx -C themes/next --strip-components=1</code></p><p>这条指令是一个管道指令，首先打开指定网络文件，获取tarball_url对应的值，去掉首末端双引号得到一个网址，下载对应文件并解压到指定目录，去掉第一层目录。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统课程学习笔记一-操作系统概述</title>
      <link href="/2020/02/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"/>
      <url>/2020/02/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-操作系统概述"><a href="#第一章-操作系统概述" class="headerlink" title="第一章 操作系统概述"></a>第一章 操作系统概述</h1><h4 id="1-1-没有安装操作系统的计算机启动过程和结果？"><a href="#1-1-没有安装操作系统的计算机启动过程和结果？" class="headerlink" title="1.1 没有安装操作系统的计算机启动过程和结果？"></a>1.1 没有安装操作系统的计算机启动过程和结果？</h4><p>启动会比较快，但功能很局限，无法使用常见的软件应用，对于普通用户来说，功能很局限，对于专业工程师来说，想使用没有操作系统的计算机也有难度。</p><h4 id="1-2-常见的虚拟机软件（例如VMware，VirtualPC等）能不能理解为操作系统？"><a href="#1-2-常见的虚拟机软件（例如VMware，VirtualPC等）能不能理解为操作系统？" class="headerlink" title="1.2 常见的虚拟机软件（例如VMware，VirtualPC等）能不能理解为操作系统？"></a>1.2 常见的虚拟机软件（例如VMware，VirtualPC等）能不能理解为操作系统？</h4><p>不能理解为完全的操作系统。因为操作系统是作为硬件部分和应用软件的中间桥梁而存在的，硬件与软件的交互必须通过操作系统。因此虚拟机虽然可以模拟操作系统的功能，但仍是作为应用软件通过真实操作系统与硬件进行交互</p><h4 id="1-3-现代操作系统会不会因为内存太小，而让应用程序无法启动运行或让系统崩溃？"><a href="#1-3-现代操作系统会不会因为内存太小，而让应用程序无法启动运行或让系统崩溃？" class="headerlink" title="1.3 现代操作系统会不会因为内存太小，而让应用程序无法启动运行或让系统崩溃？"></a>1.3 现代操作系统会不会因为内存太小，而让应用程序无法启动运行或让系统崩溃？</h4><p>一般不会。现代操作系统可以合理分配内存，即使软件所需内存大大超过实际内存，也仅仅是使计算机响应变慢，甚至是出现类似“死机”的情况，表现为计算机无法加载软件初始页面，难以响应输入设备的状态变化，只能通过强制重启计算机解决。但不会无法启动软件或使系统出现故障</p><h4 id="1-4-在多道批处理中尝试不断增加程序的数量，系统的效率会不会持续增加？结果会如何？"><a href="#1-4-在多道批处理中尝试不断增加程序的数量，系统的效率会不会持续增加？结果会如何？" class="headerlink" title="1.4 在多道批处理中尝试不断增加程序的数量，系统的效率会不会持续增加？结果会如何？"></a>1.4 在多道批处理中尝试不断增加程序的数量，系统的效率会不会持续增加？结果会如何？</h4><p>如果在CPU工作未饱和的情况下，增加程序会增加系统工作效率。但若CPU工作饱和的情况下增加程序，不会增加工作效率。</p><h4 id="1-5-分时技术的时间片设置太大或太小，应该根据哪些因素来考虑？是尽量大好还是尽量小好？"><a href="#1-5-分时技术的时间片设置太大或太小，应该根据哪些因素来考虑？是尽量大好还是尽量小好？" class="headerlink" title="1.5 分时技术的时间片设置太大或太小，应该根据哪些因素来考虑？是尽量大好还是尽量小好？"></a>1.5 分时技术的时间片设置太大或太小，应该根据哪些因素来考虑？是尽量大好还是尽量小好？</h4><p>要根据实际情况选择合适的时间片大小，比如软件的实时性要求以及程序结构特点。时间片太长，应用软件交互性变差，时间片太短，CPU频繁进行切换进程的操作，耗费不必要的运算资源</p><h3 id="单元作业"><a href="#单元作业" class="headerlink" title="单元作业"></a>单元作业</h3><h4 id="1-站在普通用户的角度，总结操作系统有哪些基本功能？"><a href="#1-站在普通用户的角度，总结操作系统有哪些基本功能？" class="headerlink" title="1 站在普通用户的角度，总结操作系统有哪些基本功能？"></a>1 站在普通用户的角度，总结操作系统有哪些基本功能？</h4><p>1、提供操作界面</p><p>2、控制程序运行</p><p>3、管理系统资源</p><p>4、配置系统参数</p><p>5、监控系统状态</p><p>6、提供工具软件集合</p><h4 id="2-操作系统有哪4大核心功能？"><a href="#2-操作系统有哪4大核心功能？" class="headerlink" title="2 操作系统有哪4大核心功能？"></a>2 操作系统有哪4大核心功能？</h4><p>1、进程管理（CPU管理）：<br>实现进程控制、调度和通信</p><p>2、内存管理：<br>实现内存分配、共享、保护以及虚拟内存技术</p><p>3、设备管理：<br>实现设备的分配调度、传输控制等</p><p>4、文件管理：<br>实现储存空间的管理、文件的操作、目录的操作以及文件目录的存取权限管理</p><h4 id="3-操作系统有哪4个典型的发展阶段，各有什么特点？"><a href="#3-操作系统有哪4个典型的发展阶段，各有什么特点？" class="headerlink" title="3 操作系统有哪4个典型的发展阶段，各有什么特点？"></a>3 操作系统有哪4个典型的发展阶段，各有什么特点？</h4><p>1、手工操作（无操作系统）：<br>对应计算机的电子管时代。程序启动、运行、结束需要手工处理，操作繁琐，CPU利用率低、用户独占使用、缺少交互。</p><p>2、单通道批处理系统：<br>对应计算机的晶体管时代。管理员事先将多个作业输入到磁盘形成作业队列，系统依次运行各个作业任务，自动完成程序装入和撤出。外设与CPU交替运行，设备利用率低</p><p>3、多通道批处理系统：<br>内存中存放多道程序，当某道程序因为某种原因不能继续运行而放弃CPU时，系统调用零一程序投入运行。CPU利用率高，宏观上程序并行处理，微观上串行处理，作业处理时间长、用户与程序交互性差、程序运行状态不确定。</p><p>4、分时系统：<br>随着中断技术和通道技术的发展，分时技术开始运用于操作系统中。以时间片为单位把CPU轮流分配给每个终端使用。具有多路调制性、用户独占性（感觉上）、良好的交互性。</p><h4 id="4-多道批处理系统为什么工作效率比单道的高？"><a href="#4-多道批处理系统为什么工作效率比单道的高？" class="headerlink" title="4 多道批处理系统为什么工作效率比单道的高？"></a>4 多道批处理系统为什么工作效率比单道的高？</h4><p>对于单道处理系统来说，在CPU处理程序前需要通过I/O读程序，在CPU处理程序后需要通过I/O写程序，系统在读写程序时CPU处于空闲状态，造成资源的浪费。<br>而多道批处理系统可以在读写程序的同时进行CPU处理程序的任务，这样当系统加载多个任务时，可以尽量保证CPU和外设处于工作状态，提高工作效率。</p><h4 id="5-分时技术与多道批处理都能完成多个程序的切换。这两种切换情形有什么差别？"><a href="#5-分时技术与多道批处理都能完成多个程序的切换。这两种切换情形有什么差别？" class="headerlink" title="5 分时技术与多道批处理都能完成多个程序的切换。这两种切换情形有什么差别？"></a>5 分时技术与多道批处理都能完成多个程序的切换。这两种切换情形有什么差别？</h4><p>多道批处理是在内存中同时存放多道程序，用户将一批程序提交给操作系统后就不再干预，由操作系统控制它们自动运行。<br>分时技术是给不同终端用户的程序提供轮流使用CPU的机会，多个程序分时（分时间片）共享硬件和软件资源，以交互方式使用计算机，共享主机中的资源。<br>批处理系统没有人机交互，而分时系统允许多个用户同时使用；批处理系统中允许程序长时间地占用CPU，而分时系统不允许。<br>分时技术一般要优于多道批处理，二者的出现主要与硬件性能决定，随着计算机性能的显著提升，分时技术出现，成为当前操作系统主要采用的多程序切换原理</p><h4 id="6-思考运行应用程序（例如记事本程序）需要操作系统提供哪些支持？"><a href="#6-思考运行应用程序（例如记事本程序）需要操作系统提供哪些支持？" class="headerlink" title="6 思考运行应用程序（例如记事本程序）需要操作系统提供哪些支持？"></a>6 思考运行应用程序（例如记事本程序）需要操作系统提供哪些支持？</h4><p>1、文件系统，将程序置入内存中<br>2、内存管理<br>3、设备管理，从键盘、鼠标读取设备状态，向屏幕显示信息<br>4、进程管理，应用程序可能会同时操作多个进程</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>万事开头难，但过程也并不轻松</title>
      <link href="/2020/02/11/%E4%B8%87%E4%BA%8B%E5%BC%80%E5%A4%B4%E9%9A%BE/"/>
      <url>/2020/02/11/%E4%B8%87%E4%BA%8B%E5%BC%80%E5%A4%B4%E9%9A%BE/</url>
      
        <content type="html"><![CDATA[<p>这是第一篇博客文章，主要写一下搭建博客的过程。</p><h2 id="第一步：Hexo"><a href="#第一步：Hexo" class="headerlink" title="第一步：Hexo"></a>第一步：Hexo</h2><p>使用了<a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>脚手架。<br>首先找一个放置脚手架的目录，输入以下命令完成安装：</p> <a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">hexo init blog</span><br><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>文件目录大致如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── <span class="built_in">source</span></span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure><p>-config.yml 中是博客参数配置<br>scaffoles 中是模板文件，可以修改文章的模板<br>source 中是博客中的静态资源，这篇文章就是通过 source/_posts 目录下的 md 文档写的<br>themes 中是主题样式，是编写博客样式的地方，可以自己编，也可以用现成的</p><p>然后就可以在配置文件<code>-config.yml</code>中绑定自己的域名。我用的是 github.io，可以参考<a href="https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html" target="_blank" rel="noopener">搭建免费个人博客详细教程</a>进行配置。<br>绑定域名后就可以上传博客页面了。</p><p>下面是一些常用 hexo 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo g          //生成项目</span><br><span class="line">hexo s --debug  //本地调试（热更新）</span><br><span class="line">hexo clean      //清除生成项目</span><br><span class="line">hexo d          //部署项目</span><br></pre></td></tr></table></figure><p>如果直接生成并部署项目，打开网页会看到 Hexo 提供的默认主题。主题存放于 themes 文件夹下，默认的主题名为 landscape，文件夹名即为主题名，可在配置文件<code>config.yml</code>的<code>theme</code>项中更改。但前提是 themes 目录下有其他的主题。</p><h2 id="第二步：主题"><a href="#第二步：主题" class="headerlink" title="第二步：主题"></a>第二步：主题</h2><p>说实话，Hexo 默认的主题 landscape 就不错，简洁大气，但直接用默认主题就没意思了。GitHub 上页有一些不错的主题模板，比如 Next，星星是最高的，但感觉页面效果也没那么好，而且想用 Next 也有不少配置要学，索性自己从零开始搭建。</p><p>我的主题主要是仿照默认主题的结构编写。landscape 主题目录下有 languages、layout、scripts 和 source 四个文件夹，languages 存放语言配置文件，layout 存放页面模板文件，scripts 存放 Hexo 脚本，source 存放页面样式、图片、字体等资源文件。</p><p>由于主题文件的编写是采用<a href="https://ejs.bootcss.com/" target="_blank" rel="noopener">ejs</a>模板引擎，所以如果没接触过 ejs 可能不好上手。可以参考<a href="https://www.cnblogs.com/mmzuo-798/p/10451385.html" target="_blank" rel="noopener">从零开始制作 Hexo 主题</a>进行编写。</p>]]></content>
      
      
      <categories>
          
          <category> other </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统课程学习笔记二-操作系统逻辑结构</title>
      <link href="/2020/02/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84/"/>
      <url>/2020/02/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="第二章-操作系统逻辑结构"><a href="#第二章-操作系统逻辑结构" class="headerlink" title="第二章 操作系统逻辑结构"></a>第二章 操作系统逻辑结构</h1><h4 id="2-1-操作系统的微内核结构的优点对我们设计大规模的应用程序有什么启示？"><a href="#2-1-操作系统的微内核结构的优点对我们设计大规模的应用程序有什么启示？" class="headerlink" title="2.1 操作系统的微内核结构的优点对我们设计大规模的应用程序有什么启示？"></a>2.1 操作系统的微内核结构的优点对我们设计大规模的应用程序有什么启示？</h4><p>微内核架构包含两类组件：核心系统（core system）和插件模块（plug-in modules）。</p><p>核心系统负责和具体业务功能无关的通用功能，例如模块加载、模块间通信等；插件模块负责实现具体的业务逻辑。核心系统功能比较稳定，不会因为业务功能扩展而不断修改，插件模块可以根据业务功能的需要不断地扩展。微内核的架构本质就是将变化部分封装在插件里面，从而达到快速灵活扩展的目的，而又不影响整体系统的稳定。</p><p>比如vue和react等前端框架都采用这种结构，简洁的核心组件和丰富的插件模块，实现功能的按需加载，各个部分易于维护和修改。</p><h4 id="2-2-用户态向内核态转有多种情形（用户请求OS提供服务、发生中断、用户进程产生错误、用户态企图执行特权指令），但是本质上就是一种情形，即通过中断的形式进入。如何理解这句话？"><a href="#2-2-用户态向内核态转有多种情形（用户请求OS提供服务、发生中断、用户进程产生错误、用户态企图执行特权指令），但是本质上就是一种情形，即通过中断的形式进入。如何理解这句话？" class="headerlink" title="2.2 用户态向内核态转有多种情形（用户请求OS提供服务、发生中断、用户进程产生错误、用户态企图执行特权指令），但是本质上就是一种情形，即通过中断的形式进入。如何理解这句话？"></a>2.2 用户态向内核态转有多种情形（用户请求OS提供服务、发生中断、用户进程产生错误、用户态企图执行特权指令），但是本质上就是一种情形，即通过中断的形式进入。如何理解这句话？</h4><p>中断是指CPU对突发的外部事件的反应过程或机制，用户请求OS提供服务、用户进程产生错误、用户态企图执行特权指令都是中断的几种情况，中断响应的本质是交换指令执行地址和交换CPU的态.</p><h4 id="2-3-CPU收到外部中断信号后，是如何响应该外部信号，完成中断服务程序后，并最后自动回到原程序继续运行的？这个过程中硬件，软件会做哪些工作？"><a href="#2-3-CPU收到外部中断信号后，是如何响应该外部信号，完成中断服务程序后，并最后自动回到原程序继续运行的？这个过程中硬件，软件会做哪些工作？" class="headerlink" title="2.3 CPU收到外部中断信号后，是如何响应该外部信号，完成中断服务程序后，并最后自动回到原程序继续运行的？这个过程中硬件，软件会做哪些工作？"></a>2.3 CPU收到外部中断信号后，是如何响应该外部信号，完成中断服务程序后，并最后自动回到原程序继续运行的？这个过程中硬件，软件会做哪些工作？</h4><p>1、识别中断源</p><p>2、保护断点和现场</p><p>3、装入中断服务程序的入口地址</p><p>4、进入中断服务程序</p><p>5、结束中断程序后恢复现场和断点</p><p>6、中断返回</p><h3 id="单元作业"><a href="#单元作业" class="headerlink" title="单元作业"></a>单元作业</h3><h4 id="1-何为操作系统的逻辑结构？有哪几种典型逻辑结构？"><a href="#1-何为操作系统的逻辑结构？有哪几种典型逻辑结构？" class="headerlink" title="1. 何为操作系统的逻辑结构？有哪几种典型逻辑结构？"></a>1. 何为操作系统的逻辑结构？有哪几种典型逻辑结构？</h4><p>操作系统的逻辑结构是指操作系统的设计实现思路。分为整体式结构、层次式结构和微内核结构。</p><p>1、整体式结构以模块为基本单位，但信息传递随意，维护更新困难。</p><p>2、层次式结构根据模块功能分为多个层级，相邻层级只有单向调用，结构清晰，利于系统维护移植。</p><p>3、微内核结构包含两类组件：核心系统（core system）和插件模块（plug-in modules）。核心系统负责和具体业务功能无关的通用功能，例如模块加载、模块间通信等，插件模块负责实现具体的业务逻辑。</p><h4 id="2-分层结构的分层原则是什么？"><a href="#2-分层结构的分层原则是什么？" class="headerlink" title="2. 分层结构的分层原则是什么？"></a>2. 分层结构的分层原则是什么？</h4><p>1、最底层与硬件相关</p><p>2、最外层与外部特性相关</p><p>3、中间层按调用次序和消息传递顺序规划</p><p>4、共性服务置于较低层</p><p>5、活跃功能置于较低层</p><h4 id="3-何为CPU的态？定义态的作用什么？有哪些态？"><a href="#3-何为CPU的态？定义态的作用什么？有哪些态？" class="headerlink" title="3. 何为CPU的态？定义态的作用什么？有哪些态？"></a>3. 何为CPU的态？定义态的作用什么？有哪些态？</h4><p>CPU的态（Mode）是指CPU的工作状态，是对资源和指令使用权限的描述。</p><p>定义态可以实现对资源和指令的分级管理，避免用户直接操作计算机硬件。</p><p>CPU的态分为核态（Kernel mode）、用户态（User mode）和管态（Supervisor mode）。核态能访问所有资源，能执行所有指令，一般宫管理程序和操作系统内核使用；用户态仅能访问操作系统提供的部分接口，一般供用户程序使用；管态是介于核态和用户态之间的状态。</p><h4 id="4-操作系统分层结构有何作用？在应用编程中，我们如何使用分层的编程思想提升程序的可移植性和可维护性？"><a href="#4-操作系统分层结构有何作用？在应用编程中，我们如何使用分层的编程思想提升程序的可移植性和可维护性？" class="headerlink" title="4. 操作系统分层结构有何作用？在应用编程中，我们如何使用分层的编程思想提升程序的可移植性和可维护性？"></a>4. 操作系统分层结构有何作用？在应用编程中，我们如何使用分层的编程思想提升程序的可移植性和可维护性？</h4><p>层次结构结构清晰，可以避免循环调用。将整体问题局部化，易于保证系统的正确性。最底层与硬件相关、最外层与外部特性相关的结构有利于操作系统的维护扩充和移植。</p><p>对于前端工程师来说，在设计程序时，可大致分为API模块、UI模块和核心业务模块，API模块负责处理与后端的通信和数据交互，UI模块负责呈现页面，核心业务模块负责逻辑处理和功能实现，根据需要进一步拆分为多个模块。这样就有比较强的可移植性和可维护性，当后端接口或浏览器发生变化时，直接修改对应模块就可以。</p><h4 id="5-下载Linux-0-11-OS源代码，用SourceInsight软件打开源代码，了解其源代码的构成，大致的模块结构-做简单的文字描述。"><a href="#5-下载Linux-0-11-OS源代码，用SourceInsight软件打开源代码，了解其源代码的构成，大致的模块结构-做简单的文字描述。" class="headerlink" title="5. 下载Linux 0.11 OS源代码，用SourceInsight软件打开源代码，了解其源代码的构成，大致的模块结构,做简单的文字描述。"></a>5. 下载Linux 0.11 OS源代码，用SourceInsight软件打开源代码，了解其源代码的构成，大致的模块结构,做简单的文字描述。</h4><p>​Linux 0.11分为下面几个文件夹：</p><p>boot：计算机启动代码</p><p>init：操作系统初始化</p><p>include：各种函数的声明以及各类宏定义</p><p>kernel：与进程有关</p><p>mm：内存管理</p><p>Lib：链接时用到的库</p><p>Fs：文件系统</p><h4 id="6-下载Minix-OS源代码，用SourceInsight软件打开源代码，了解其源代码的构成，大致的模块结构-做简单的文字描述。"><a href="#6-下载Minix-OS源代码，用SourceInsight软件打开源代码，了解其源代码的构成，大致的模块结构-做简单的文字描述。" class="headerlink" title="6. 下载Minix OS源代码，用SourceInsight软件打开源代码，了解其源代码的构成，大致的模块结构,做简单的文字描述。"></a>6. 下载Minix OS源代码，用SourceInsight软件打开源代码，了解其源代码的构成，大致的模块结构,做简单的文字描述。</h4><p>minix 2.0：</p><p>include/目录包含了操作系统所有的头文件（即.h文件）</p><p>其中：</p><p>include/目录下为POSIX标准头文件；</p><p>include/sys/目录下为额外的POSIX标准头文件；</p><p>include/minix/目录下为MINIX操作系统定义的头文件</p><p>src/目录下包含了操作系统所有的源文件（.c或.s文件）</p><p>其中：</p><p>src/kernel/目录存放着MINIX操作系统第一层（进程管理）和第二层（设备管理）的源代码；</p><p>src/mm/目录存放着MINIX操作系统第三层中内存管理子系统的源代码；</p><p>src/fs目录下存放着MINIX操作系统第三层中文件管理系统的源代码；</p><p>src/lib目录下存放着MINIX操作系统使用的库例程源代码（e.g. open，read）；</p><p>src/tools目录下存放着Init源程序，用于启动Minix；</p><p>src/boot目录下存放着启动和安装MINIX操作系统的源代码；</p><p>src/commands/ ：包含公用程序（e.g. cat, cp, date, ls, pwd）的源代码；</p><p>src/test/： 包含有一些被设计用来对新编译好的Minix系统进行完整测试的工具（由于Minix是一个用于教学的操作系统，这意味着对它常常要作修改）；</p><p>src/inet/： 包含了重新编译Minix以使之支持网路的源代码 </p><p>转载于：<a href="https://www.cnblogs.com/wuyudong/p/3637477.html" target="_blank" rel="noopener">https://www.cnblogs.com/wuyudong/p/3637477.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
