<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>操作系统课程学习笔记五-死锁</title>
      <link href="/2020/03/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%94-%E6%AD%BB%E9%94%81/"/>
      <url>/2020/03/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%94-%E6%AD%BB%E9%94%81/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>编译原理学习笔记五-自上而下的语法分析</title>
      <link href="/2020/03/16/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%94-%E8%87%AA%E4%B8%8A%E8%80%8C%E4%B8%8B%E7%9A%84%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/"/>
      <url>/2020/03/16/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%94-%E8%87%AA%E4%B8%8A%E8%80%8C%E4%B8%8B%E7%9A%84%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="第五章-自上而下的语法分析"><a href="#第五章-自上而下的语法分析" class="headerlink" title="第五章 自上而下的语法分析"></a>第五章 自上而下的语法分析</h1><h4 id="自上而下"><a href="#自上而下" class="headerlink" title="自上而下"></a>自上而下</h4><p>从文法的开始符号出发，反复使用各种产生式，寻找”匹配”的推导；<br>推导：根据文法的产生式规则，把串中出现的产生式的左部符号替换成右部；<br>针对输入串，试图用一切可能的办法，从文法开始符号(根结点)出发，自上而下地为输入串建立一棵语法树；<br>递归下降分析法、预测分析程序。</p><h3 id="第一部分：LL-1-文法"><a href="#第一部分：LL-1-文法" class="headerlink" title="第一部分：LL(1)文法"></a>第一部分：LL(1)文法</h3><h4 id="1-多个产生式候选带来的问题"><a href="#1-多个产生式候选带来的问题" class="headerlink" title="1 多个产生式候选带来的问题"></a>1 多个产生式候选带来的问题</h4><p>回溯问题：分析过程中，当一个非终结符用某一个候选匹配成功时，这种匹配可能是暂时的，出错时，不得不“回溯”；<br>文法左递归问题：左递归的文法可能由于语法错误导致陷入死循环。</p><h4 id="2-直接左递归的消除"><a href="#2-直接左递归的消除" class="headerlink" title="2 直接左递归的消除"></a>2 直接左递归的消除</h4><figure class="image-box">                <img src="/2020/03/16/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%94-%E8%87%AA%E4%B8%8A%E8%80%8C%E4%B8%8B%E7%9A%84%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/1.png" alt="直接左递归的消除" title class>                <p>直接左递归的消除</p>            </figure><p><strong>公式</strong>：<br>P→Pα1 | Pα2 |……| Pαm |β1 |β2 |……|βn<br>推导为：<br>P→β1P’|β2P’|…|βnP’<br>P’→α1P’|α2P’|…|αmP’|ε  </p><p><strong>例子</strong>：<br>给定文法G(E):<br>E→E＋T | T<br>T→T<em>F | F<br>F→(E) | i<br>推导为：<br>G(E):<br>E→TE’<br>E’→+TE’ | ε<br>T→FT’<br>T’→</em>FT’ | ε<br>F→(E) | i    </p><h4 id="3-间接左递归的消除"><a href="#3-间接左递归的消除" class="headerlink" title="3 间接左递归的消除"></a>3 间接左递归的消除</h4><figure class="image-box">                <img src="/2020/03/16/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%94-%E8%87%AA%E4%B8%8A%E8%80%8C%E4%B8%8B%E7%9A%84%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/2.png" alt="间接左递归的消除" title class>                <p>间接左递归的消除</p>            </figure><h4 id="4-消除回溯"><a href="#4-消除回溯" class="headerlink" title="4 消除回溯"></a>4 消除回溯</h4><p>为了消除回溯必须保证对文法的任何非终结符，当要它去匹配输入串时，能够根据它所面临的输入符号准确地指派它的一个候选去执行任务，并且此候选的工作结果应是确信无疑的。</p><h4 id="5-𝐹𝐼𝑅𝑆𝑇集合"><a href="#5-𝐹𝐼𝑅𝑆𝑇集合" class="headerlink" title="5 𝐹𝐼𝑅𝑆𝑇集合"></a>5 𝐹𝐼𝑅𝑆𝑇集合</h4><p>令G是一个不含左递归的文法，对G的所有非终结符的每个候选𝛼定义它的终结首符集FIRST(𝛼)为：<br>𝐹𝐼𝑅𝑆𝑇(𝛼)={𝑎│𝛼∗⇒ 𝑎…, 𝑎∈𝑉𝑇}<br>特别是，若𝛼∗⇒ 𝜀，则规定𝜀∈𝐹𝐼𝑅𝑆𝑇(𝛼)。</p><h4 id="6-𝐹𝑂𝐿𝐿𝑂𝑊集合"><a href="#6-𝐹𝑂𝐿𝐿𝑂𝑊集合" class="headerlink" title="6 𝐹𝑂𝐿𝐿𝑂𝑊集合"></a>6 𝐹𝑂𝐿𝐿𝑂𝑊集合</h4><p>假定S是文法G的开始符号，对于G的任何非终结符A，我们定义A的FOLLOW集合：<br>𝐹𝑂𝐿𝐿𝑂𝑊(𝐴)={𝑎│𝑆∗⇒…𝐴𝑎…, 𝑎∈𝑉𝑇 }<br>特别是，若𝑆∗⇒…𝐴，则规定#∈𝐹𝑂𝐿𝐿𝑂𝑊(𝐴)</p><h4 id="7-LL-1-文法"><a href="#7-LL-1-文法" class="headerlink" title="7 LL(1)文法"></a>7 LL(1)文法</h4><p>特点：</p><ol><li>文法不含左递归  </li><li>对于文法中每一个非终结符A的各个产生式的候选首符集两两不相交。  </li><li>对文法中的每个非终结符A，若它存在某个候选首符集包含𝜀，则<br>FIRST(𝛼i)∩FOLLOW(A)=#，i=1,2,…,n</li></ol><p>对于LL(1)文法，可以对其输入串进行有效的无回溯的自上而下分析。<br>假设要用非终结符A进行匹配，面临的输入符号为a：  </p><ol><li>若a∈FIRST(𝛼i)，则指派𝛼i执行匹配任务；  </li><li>若a不属于任何一个候选首符集，则：<br>(1) 若𝛼属于某个FIRST(𝛼i)且 a∈FOLLOW(A)，则让A与𝛼自动匹配。<br>(2) 否则，a的出现是一种语法错误。</li></ol><h3 id="第二部分：递归下降分析程序"><a href="#第二部分：递归下降分析程序" class="headerlink" title="第二部分：递归下降分析程序"></a>第二部分：递归下降分析程序</h3><h4 id="8-递归下降分析器"><a href="#8-递归下降分析器" class="headerlink" title="8 递归下降分析器"></a>8 递归下降分析器</h4><p>分析程序由一组子程序组成， 对每一语法单位(非终结符)构造一个相应的子程序，识别对应的语法单位；<br>通过子程序间的相互调用实现对输入串的识别；<br>例如，A → B c D；<br>文法的定义通常是递归的，通常具有递归结构。</p><p>每个非终结符有对应的子程序的定义，在分析过程中，当需要从某个非终结符出发进行展开(推导)时，就调用这个非终结符对应的子程序。</p><p>例子：<br>定义全局过程和变量：<br>ADVANCE，把输入串指示器IP指向下一个输入符号，即读入一个单词符号；<br>SYM，IP当前所指的输入符号；<br>ERROR，出错处理子程序。<br>A→TE’ | BC | 𝜀    对应的递归下降子程序为：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PROCEDURE  A；</span><br><span class="line">BEGIN</span><br><span class="line">  IF  SYM ∈FIRST(TE&#39;) THEN</span><br><span class="line">    BEGIN  T；E&#39; END</span><br><span class="line">  ELSE IF  SYM ∈FIRST(BC) THEN</span><br><span class="line">    BEGIN  B; C  END</span><br><span class="line">  ELSE IF  SYM ∈FOLLOW(A) THEN</span><br><span class="line">    ERROR</span><br><span class="line">END；</span><br></pre></td></tr></table></figure><h4 id="9-扩充的巴科斯范式"><a href="#9-扩充的巴科斯范式" class="headerlink" title="9 扩充的巴科斯范式"></a>9 扩充的巴科斯范式</h4><p>在元符号“→”或“::=”和“|”的基础上，扩充几个元语言符号：<br>用花括号{α}表示闭包运算α*。<br>用表示{α}<sub>0</sub><sup>n</sup>可任意重复0次至n次。<br>用方括号[α]表示{α}<sub>0</sub><sup>1</sup>，即表示α的出现可有可无(等价于α|𝜀)。  </p><p>例如实数可定义为：<br>   Decimal→[Sign]Integer.{digit}[Exponent]<br>   Exponent→E[Sign]Integer<br>   Integer→digit{digit}<br>   Sign→ + | -</p><p>用扩充的巴科斯范式来描述语法，直观易懂，便于表示左递归消去和因子提取。</p><h3 id="第二部分：预测分析程序"><a href="#第二部分：预测分析程序" class="headerlink" title="第二部分：预测分析程序"></a>第二部分：预测分析程序</h3><h4 id="10-预测分析程序构成"><a href="#10-预测分析程序构成" class="headerlink" title="10 预测分析程序构成"></a>10 预测分析程序构成</h4><p>总控程序，根据现行栈顶符号和当前输入符号，执行动作；<br>分析表 M[A，a]矩阵，A ∈ V<sub>N</sub> ，a ∈ V<sub>T</sub> 是终结符或‘＃’；<br>分析栈 STACK  用于存放文法符号。</p><figure class="image-box">                <img src="/2020/03/16/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%94-%E8%87%AA%E4%B8%8A%E8%80%8C%E4%B8%8B%E7%9A%84%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/3.png" alt="预测分析程序构成" title class>                <p>预测分析程序构成</p>            </figure><h4 id="11-预测分析过程"><a href="#11-预测分析过程" class="headerlink" title="11 预测分析过程"></a>11 预测分析过程</h4><p>总控程序根据当前栈顶符号X和输入符号a，执行下列三动作之一：  </p><ol><li>若X＝a＝‘＃’，则宣布分析成功，停止分析。  </li><li>若X＝a ≠‘＃’，则把X从STACK栈顶逐出，让a指向下一个输入符号。  </li><li>若X是一个非终结符，则查看分析表M。<br>若M[X，a]中存放着关于X的一个产生式，把X逐出STACK栈顶，把产生式的右部符号串按反序一一推进STACK栈(若右部符号为𝜀，则意味不推什么东西进栈)。<br>若M[X，a]中存放着“出错标志”，则调用出错诊察程序ERROR。</li></ol><h4 id="12-总控程序实现"><a href="#12-总控程序实现" class="headerlink" title="12 总控程序实现"></a>12 总控程序实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">BEGIN</span><br><span class="line">  首先把‘＃’然后把文法开始符号推进STACK栈；</span><br><span class="line">  把第一个输入符号读进a；</span><br><span class="line">  FLAG:&#x3D;TRUE;</span><br><span class="line">  WHILE  FLAG  DO</span><br><span class="line">  BEGIN</span><br><span class="line">    把STACK栈顶符号上托出去并放在X中；</span><br><span class="line">    IF X属于VT THEN</span><br><span class="line">      IF X&#x3D; a  THEN 把下一输入符号读进a</span><br><span class="line">        ELSE   ERROR</span><br><span class="line">      ELSE IF X&#x3D;‘#’ THEN</span><br><span class="line">        IF X&#x3D;a THEN FLAG:&#x3D;FALSE </span><br><span class="line">          ELSE ERROR</span><br><span class="line">      ELSE IF M[X,a]&#x3D;&#123;X→X1X2…Xk&#125;THEN</span><br><span class="line">      把Xk,Xk-1,…,X1一一推进STACK栈</span><br><span class="line">      &#x2F;* 若X1X2…Xk&#x3D;𝜀，不推什么进栈 *&#x2F;</span><br><span class="line">      ELSE ERROR</span><br><span class="line">    END OF WHILE;</span><br><span class="line">  STOP &#x2F;*分析成功，过程完毕*&#x2F;</span><br><span class="line">END</span><br></pre></td></tr></table></figure><h4 id="13-预测分析示例"><a href="#13-预测分析示例" class="headerlink" title="13 预测分析示例"></a>13 预测分析示例</h4><figure class="image-box">                <img src="/2020/03/16/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%94-%E8%87%AA%E4%B8%8A%E8%80%8C%E4%B8%8B%E7%9A%84%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/4.png" alt="预测分析示例" title class>                <p>预测分析示例</p>            </figure><h4 id="13-分析表M-A，a-的构造算法"><a href="#13-分析表M-A，a-的构造算法" class="headerlink" title="13 分析表M[A，a]的构造算法"></a>13 分析表M[A，a]的构造算法</h4><p>构造G的分析表M[A，a]， 确定每个产生式A→α在表中的位置  </p><ol><li>对文法G的每个产生式A→α执行第2步和第3步；  </li><li>对每个终结符a ∈ FIRST(α)，把A→α加至M[A，a]中；  </li><li>若𝜀 ∈ FIRST(α)，则对任何b ∈ FOLLOW(A)把A→α加至M[A，b]中；  </li><li>把所有无定义的M[A，a]标上“出错标志”。  </li></ol><h4 id="14-LL-1-文法与二义性"><a href="#14-LL-1-文法与二义性" class="headerlink" title="14 LL(1)文法与二义性"></a>14 LL(1)文法与二义性</h4><p>如果G是左递归或二义的，那么，M至少含有一个多重定义入口。因此，消除左递归和提取左因子将有助于获得无多重定义的分析表M。<br>可以证明，一个文法G的预测分析表M不含多重定义入口，当且仅当该文法为LL(1)的。<br>LL(1)文法不是二义的。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法课程笔记-图论</title>
      <link href="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%9B%BE%E8%AE%BA/"/>
      <url>/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%9B%BE%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><p>分为无向图和有向图<br>分为有权图和无权图（边的值）<br>图的连通性<br><img src="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%9B%BE%E8%AE%BA/1.png" alt="自环边和平行边">  </p><h4 id="1-图的表示"><a href="#1-图的表示" class="headerlink" title="1 图的表示"></a>1 图的表示</h4><figure class="image-box">                <img src="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%9B%BE%E8%AE%BA/2.png" alt="邻接矩阵" title class>                <p>邻接矩阵</p>            </figure>  <p><img src="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%9B%BE%E8%AE%BA/3.png" alt="邻接表1">  </p><figure class="image-box">                <img src="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%9B%BE%E8%AE%BA/4.png" alt="邻接表2" title class>                <p>邻接表2</p>            </figure>  <p>邻接矩阵适合表示稠密图，邻接表适合表示稀疏图。稠密与稀疏取决于边（edge）的数量。</p><h4 id="2-深度优先遍历（dfs）与连通分量（Components）"><a href="#2-深度优先遍历（dfs）与连通分量（Components）" class="headerlink" title="2 深度优先遍历（dfs）与连通分量（Components）"></a>2 深度优先遍历（dfs）与连通分量（Components）</h4><p>深度优先遍历与树的遍历类似，但需要记录该节点是否遍历过<br><img src="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%9B%BE%E8%AE%BA/5.png" alt="连通分量"> </p><h4 id="3-寻路"><a href="#3-寻路" class="headerlink" title="3 寻路"></a>3 寻路</h4><p>与dfs相似</p><h4 id="4-广度优先遍历（bfs）与最短路径"><a href="#4-广度优先遍历（bfs）与最短路径" class="headerlink" title="4 广度优先遍历（bfs）与最短路径"></a>4 广度优先遍历（bfs）与最短路径</h4><p>广度优先遍历与树的层序遍历类似，利用队列，一个节点出队，将所有相连节点加入队列，需要记录该节点是否遍历过。<br>广度优先遍历的特点在于先遍历的元素距离起点近（无权图）。</p><h4 id="5-有权图（weighted-graph）"><a href="#5-有权图（weighted-graph）" class="headerlink" title="5 有权图（weighted graph）"></a>5 有权图（weighted graph）</h4><figure class="image-box">                <img src="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%9B%BE%E8%AE%BA/6.png" alt="有权图" title class>                <p>有权图</p>            </figure>  <figure class="image-box">                <img src="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%9B%BE%E8%AE%BA/7.png" alt="有权图邻接矩阵" title class>                <p>有权图邻接矩阵</p>            </figure>  <figure class="image-box">                <img src="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%9B%BE%E8%AE%BA/8.png" alt="有权图邻接表" title class>                <p>有权图邻接表</p>            </figure>  <h4 id="6-最小生成树和切分定理（cut-property）"><a href="#6-最小生成树和切分定理（cut-property）" class="headerlink" title="6 最小生成树和切分定理（cut property）"></a>6 最小生成树和切分定理（cut property）</h4><p>n-1条边连接了n个节点，称为生成树。若总权值最小，称为最小生成树。<br>将图进行切分，边的两个节点分属两半称为横切边。<br>切分定理：对于任意切分，横切边中权值最小的边属于最小生成树。  </p><h4 id="7-prim算法"><a href="#7-prim算法" class="headerlink" title="7 prim算法"></a>7 prim算法</h4><figure class="image-box">                <img src="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%9B%BE%E8%AE%BA/9.png" alt="有权图邻接表" title class>                <p>有权图邻接表</p>            </figure>  <h4 id="8-kruskal算法"><a href="#8-kruskal算法" class="headerlink" title="8 kruskal算法"></a>8 kruskal算法</h4><h4 id="9-最短路径问题与松弛操作（relaxation）"><a href="#9-最短路径问题与松弛操作（relaxation）" class="headerlink" title="9 最短路径问题与松弛操作（relaxation）"></a>9 最短路径问题与松弛操作（relaxation）</h4><p>松弛操作是最短路径问题的核心。</p><h4 id="10-dijkstra算法"><a href="#10-dijkstra算法" class="headerlink" title="10 dijkstra算法"></a>10 dijkstra算法</h4><p>前提：没有负权边。<br><img src="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%9B%BE%E8%AE%BA/10.png" alt="dijkstra算法"><br>如图所示，0到2的路径最短，因此0到2的最短路径可以确定为2。  </p><p><img src="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%9B%BE%E8%AE%BA/11.png" alt="dijkstra算法"><br>如图所示，2到1的距离是1，则0到1的最短距离更新为3，距离为5的边被废弃，这一操作为松弛操作。  </p><p>通过上述两种操作，可得到如下结果。<br><img src="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%9B%BE%E8%AE%BA/12.png" alt="dijkstra算法">   </p><h4 id="11-负权边与bellman-ford算法"><a href="#11-负权边与bellman-ford算法" class="headerlink" title="11 负权边与bellman-ford算法"></a>11 负权边与bellman-ford算法</h4><p>如果有负权环，则没有最短路径。<br>bellman-ford算法可解决负权边最短路径问题。<br>最短路径最多经过n个节点，否则就有负权环。<br>一个点的一次松弛操作就是找到经过这个点的另外一条路径，多一条边，权值更小。从一点到另外一点最多有n-1条边。对所有的点进行n-1次松弛操作，找到最短路径。如果n-1次松弛操作后还可以继续松弛，则有负权环。  </p><h4 id="12-拓扑排序"><a href="#12-拓扑排序" class="headerlink" title="12 拓扑排序"></a>12 拓扑排序</h4><p>用于有向无环图</p><h4 id="13-课程用到的算法思想"><a href="#13-课程用到的算法思想" class="headerlink" title="13 课程用到的算法思想"></a>13 课程用到的算法思想</h4><figure class="image-box">                <img src="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%9B%BE%E8%AE%BA/13.png" alt="总结" title class>                <p>总结</p>            </figure>  ]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法课程笔记-并查集</title>
      <link href="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
      <url>/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p>用于解决连接问题<br><img src="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%B9%B6%E6%9F%A5%E9%9B%86/1.png" alt="并查集">  </p><h4 id="1-树结构并查集"><a href="#1-树结构并查集" class="headerlink" title="1 树结构并查集"></a>1 树结构并查集</h4><p>初始条件下所有结点都为根节点，根节点指向自己。连接时，将一节点的根节点指向另一节点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> UF2&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span>&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">// 使用一个数组构建一棵指向父节点的树</span></span><br><span class="line">        <span class="comment">// parent[i]表示第一个元素所指向的父节点</span></span><br><span class="line">        <span class="keyword">int</span>* parent;</span><br><span class="line">        <span class="keyword">int</span> count;  <span class="comment">// 数据个数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 构造函数</span></span><br><span class="line">        UnionFind(<span class="keyword">int</span> count)&#123;</span><br><span class="line">            parent = <span class="keyword">new</span> <span class="keyword">int</span>[count];</span><br><span class="line">            <span class="keyword">this</span>-&gt;count = count;</span><br><span class="line">            <span class="comment">// 初始化, 每一个parent[i]指向自己, 表示每一个元素自己自成一个集合</span></span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; count ; i ++ )</span><br><span class="line">                parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 析构函数</span></span><br><span class="line">        ~UnionFind()&#123;</span><br><span class="line">            <span class="keyword">delete</span>[] parent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找过程, 查找元素p所对应的集合编号</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">            assert( p &gt;= <span class="number">0</span> &amp;&amp; p &lt; count );</span><br><span class="line">            <span class="comment">// 不断去查询自己的父亲节点, 直到到达根节点</span></span><br><span class="line">            <span class="comment">// 根节点的特点: parent[p] == p</span></span><br><span class="line">            <span class="keyword">while</span>( p != parent[p] )</span><br><span class="line">                p = parent[p];</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查看元素p和元素q是否所属一个集合</span></span><br><span class="line">        <span class="comment">// O(h)复杂度, h为树的高度</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">isConnected</span><span class="params">( <span class="keyword">int</span> p , <span class="keyword">int</span> q )</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">find</span>(p) == <span class="built_in">find</span>(q);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并元素p和元素q所属的集合</span></span><br><span class="line">        <span class="comment">// O(h)复杂度, h为树的高度</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">unionElements</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> pRoot = <span class="built_in">find</span>(p);</span><br><span class="line">            <span class="keyword">int</span> qRoot = <span class="built_in">find</span>(q);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( pRoot == qRoot )</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-树结构层数优化并查集"><a href="#2-树结构层数优化并查集" class="headerlink" title="2 树结构层数优化并查集"></a>2 树结构层数优化并查集</h4><p>合并时将层数较少的集合指向层数较多的集合，减少树的总层数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> UF4&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span>&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span>* rank;   <span class="comment">// rank[i]表示以i为根的集合所表示的树的层数</span></span><br><span class="line">        <span class="keyword">int</span>* parent; <span class="comment">// parent[i]表示第i个元素所指向的父节点</span></span><br><span class="line">        <span class="keyword">int</span> count;   <span class="comment">// 数据个数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 构造函数</span></span><br><span class="line">        UnionFind(<span class="keyword">int</span> count)&#123;</span><br><span class="line">            parent = <span class="keyword">new</span> <span class="keyword">int</span>[count];</span><br><span class="line">            rank = <span class="keyword">new</span> <span class="keyword">int</span>[count];</span><br><span class="line">            <span class="keyword">this</span>-&gt;count = count;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; count ; i ++ )&#123;</span><br><span class="line">                parent[i] = i;</span><br><span class="line">                rank[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 析构函数</span></span><br><span class="line">        ~UnionFind()&#123;</span><br><span class="line">            <span class="keyword">delete</span>[] parent;</span><br><span class="line">            <span class="keyword">delete</span>[] rank;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找过程, 查找元素p所对应的集合编号</span></span><br><span class="line">        <span class="comment">// O(h)复杂度, h为树的高度</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">            assert( p &gt;= <span class="number">0</span> &amp;&amp; p &lt; count );</span><br><span class="line">            <span class="comment">// 不断去查询自己的父亲节点, 直到到达根节点</span></span><br><span class="line">            <span class="comment">// 根节点的特点: parent[p] == p</span></span><br><span class="line">            <span class="keyword">while</span>( p != parent[p] )</span><br><span class="line">                p = parent[p];</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查看元素p和元素q是否所属一个集合</span></span><br><span class="line">        <span class="comment">// O(h)复杂度, h为树的高度</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">isConnected</span><span class="params">( <span class="keyword">int</span> p , <span class="keyword">int</span> q )</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">find</span>(p) == <span class="built_in">find</span>(q);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并元素p和元素q所属的集合</span></span><br><span class="line">        <span class="comment">// O(h)复杂度, h为树的高度</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">unionElements</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> pRoot = <span class="built_in">find</span>(p);</span><br><span class="line">            <span class="keyword">int</span> qRoot = <span class="built_in">find</span>(q);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( pRoot == qRoot )</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根据两个元素所在树的元素个数不同判断合并方向</span></span><br><span class="line">            <span class="comment">// 将元素个数少的集合合并到元素个数多的集合上</span></span><br><span class="line">            <span class="keyword">if</span>( rank[pRoot] &lt; rank[qRoot] )&#123;</span><br><span class="line">                parent[pRoot] = qRoot;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>( rank[qRoot] &lt; rank[pRoot])&#123;</span><br><span class="line">                parent[qRoot] = pRoot;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123; <span class="comment">// rank[pRoot] == rank[qRoot]</span></span><br><span class="line">                parent[pRoot] = qRoot;</span><br><span class="line">                rank[qRoot] += <span class="number">1</span>;   <span class="comment">// 此时, 我维护rank的值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-路径压缩并查集"><a href="#3-路径压缩并查集" class="headerlink" title="3 路径压缩并查集"></a>3 路径压缩并查集</h4><p>查找根节点时将父节点指向父节点的父节点。</p><figure class="image-box">                <img src="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%B9%B6%E6%9F%A5%E9%9B%86/2.png" alt="路径压缩" title class>                <p>路径压缩</p>            </figure> <pre><code class="c++"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;<span class="comment">// 我们的第五版Union-Find</span><span class="keyword">namespace</span> UF5{    <span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span>{</span>    <span class="keyword">private</span>:        <span class="comment">// rank[i]表示以i为根的集合所表示的树的层数</span>        <span class="comment">// 在后续的代码中, 我们并不会维护rank的语意, 也就是rank的值在路径压缩的过程中, 有可能不在是树的层数值</span>        <span class="comment">// 这也是我们的rank不叫height或者depth的原因, 他只是作为比较的一个标准</span>        <span class="comment">// 关于这个问题，可以参考问答区：http://coding.imooc.com/learn/questiondetail/7287.html</span>        <span class="keyword">int</span>* rank;        <span class="keyword">int</span>* parent; <span class="comment">// parent[i]表示第i个元素所指向的父节点</span>        <span class="keyword">int</span> count;   <span class="comment">// 数据个数</span>    <span class="keyword">public</span>:        <span class="comment">// 构造函数</span>        UnionFind(<span class="keyword">int</span> count){            parent = <span class="keyword">new</span> <span class="keyword">int</span>[count];            rank = <span class="keyword">new</span> <span class="keyword">int</span>[count];            <span class="keyword">this</span>-&gt;count = count;            <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; count ; i ++ ){                parent[i] = i;                rank[i] = <span class="number">1</span>;            }        }        <span class="comment">// 析构函数</span>        ~UnionFind(){            <span class="keyword">delete</span>[] parent;            <span class="keyword">delete</span>[] rank;        }        <span class="comment">// 查找过程, 查找元素p所对应的集合编号</span>        <span class="comment">// O(h)复杂度, h为树的高度</span>        <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>{            assert( p &gt;= <span class="number">0</span> &amp;&amp; p &lt; count );            <span class="comment">// path compression 1</span>            <span class="keyword">while</span>( p != parent[p] ){                parent[p] = parent[parent[p]];                p = parent[p];            }            <span class="keyword">return</span> p;            <span class="comment">// path compression 2, 递归算法</span><span class="comment">//            if( p != parent[p] )</span><span class="comment">//                parent[p] = find( parent[p] );</span><span class="comment">//            return parent[p];</span>        }        <span class="comment">// 查看元素p和元素q是否所属一个集合</span>        <span class="comment">// O(h)复杂度, h为树的高度</span>        <span class="function"><span class="keyword">bool</span> <span class="title">isConnected</span><span class="params">( <span class="keyword">int</span> p , <span class="keyword">int</span> q )</span></span>{            <span class="keyword">return</span> <span class="built_in">find</span>(p) == <span class="built_in">find</span>(q);        }        <span class="comment">// 合并元素p和元素q所属的集合</span>        <span class="comment">// O(h)复杂度, h为树的高度</span>        <span class="function"><span class="keyword">void</span> <span class="title">unionElements</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>{            <span class="keyword">int</span> pRoot = <span class="built_in">find</span>(p);            <span class="keyword">int</span> qRoot = <span class="built_in">find</span>(q);            <span class="keyword">if</span>( pRoot == qRoot )                <span class="keyword">return</span>;            <span class="comment">// 根据两个元素所在树的元素个数不同判断合并方向</span>            <span class="comment">// 将元素个数少的集合合并到元素个数多的集合上</span>            <span class="keyword">if</span>( rank[pRoot] &lt; rank[qRoot] ){                parent[pRoot] = qRoot;            }            <span class="keyword">else</span> <span class="keyword">if</span>( rank[qRoot] &lt; rank[pRoot]){                parent[qRoot] = pRoot;            }            <span class="keyword">else</span>{ <span class="comment">// rank[pRoot] == rank[qRoot]</span>                parent[pRoot] = qRoot;                rank[qRoot] += <span class="number">1</span>;   <span class="comment">// 此时, 我维护rank的值</span>            }        }    };}</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法课程笔记-二分搜索树</title>
      <link href="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
      <url>/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="二分搜索算法"><a href="#二分搜索算法" class="headerlink" title="二分搜索算法"></a>二分搜索算法</h1><p>用于解决查找问题</p><h4 id="1-二分查找法"><a href="#1-二分查找法" class="headerlink" title="1 二分查找法"></a>1 二分查找法</h4><p>只能在有序数组中查找</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分查找法,在有序数组arr中,查找target</span></span><br><span class="line"><span class="comment">// 如果找到target,返回相应的索引index</span></span><br><span class="line"><span class="comment">// 如果没有找到target,返回-1</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(T arr[], <span class="keyword">int</span> n, T target)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在arr[l...r]之中查找target</span></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>( l &lt;= r )&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//int mid = (l + r)/2;</span></span><br><span class="line">        <span class="comment">// 防止极端情况下的整形溢出，使用下面的逻辑求出mid</span></span><br><span class="line">        <span class="keyword">int</span> mid = l + (r-l)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( arr[mid] == target )</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( arr[mid] &gt; target )</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用递归的方式写二分查找法</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> __binarySearch2(T arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r, T target)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( l &gt; r )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//int mid = (l+r)/2;</span></span><br><span class="line">    <span class="comment">// 防止极端情况下的整形溢出，使用下面的逻辑求出mid</span></span><br><span class="line">    <span class="keyword">int</span> mid = l + (r-l)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( arr[mid] == target )</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( arr[mid] &gt; target )</span><br><span class="line">        <span class="keyword">return</span> __binarySearch2(arr, l, mid<span class="number">-1</span>, target);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> __binarySearch2(arr, mid+<span class="number">1</span>, r, target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch2</span><span class="params">(T arr[], <span class="keyword">int</span> n, T target)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> __binarySearch2( arr , <span class="number">0</span> , n<span class="number">-1</span>, target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较非递归和递归写法的二分查找的效率</span></span><br><span class="line"><span class="comment">// 非递归算法在性能上有微弱优势</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">1000000</span>;</span><br><span class="line">    <span class="keyword">int</span>* a = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++ )</span><br><span class="line">        a[i] = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试非递归二分查找法</span></span><br><span class="line">    <span class="keyword">clock_t</span> startTime = clock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于我们的待查找数组[0...N)</span></span><br><span class="line">    <span class="comment">// 对[0...N)区间的数值使用二分查找，最终结果应该就是数字本身</span></span><br><span class="line">    <span class="comment">// 对[N...2*N)区间的数值使用二分查找，因为这些数字不在arr中，结果为-1</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">2</span>*n ; i ++ )&#123;</span><br><span class="line">        <span class="keyword">int</span> v = binarySearch(a, n, i);</span><br><span class="line">        <span class="keyword">if</span>( i &lt; n )</span><br><span class="line">            assert( v == i );</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            assert( v == <span class="number">-1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">clock_t</span> endTime = clock();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Binary Search (Without Recursion): "</span> &lt;&lt; <span class="keyword">double</span>(endTime - startTime) / CLOCKS_PER_SEC &lt;&lt; <span class="string">" s"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试递归的二分查找法</span></span><br><span class="line">    startTime = clock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于我们的待查找数组[0...N)</span></span><br><span class="line">    <span class="comment">// 对[0...N)区间的数值使用二分查找，最终结果应该就是数字本身</span></span><br><span class="line">    <span class="comment">// 对[N...2*N)区间的数值使用二分查找，因为这些数字不在arr中，结果为-1</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">2</span>*n ; i ++ )&#123;</span><br><span class="line">        <span class="keyword">int</span> v = binarySearch2(a, n, i);</span><br><span class="line">        <span class="keyword">if</span>( i &lt; n )</span><br><span class="line">            assert( v == i );</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            assert( v == <span class="number">-1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    endTime = clock();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Binary Search (Recursion): "</span> &lt;&lt; <span class="keyword">double</span>(endTime - startTime) / CLOCKS_PER_SEC &lt;&lt; <span class="string">" s"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-O-n-2"><a href="#1-O-n-2" class="headerlink" title="1 O(n)2"></a>1 O(n)2</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++)&#123;</span><br><span class="line">    <span class="comment">// 寻找[i, n)区间里的最小值</span></span><br><span class="line">    <span class="keyword">int</span> minIndex = i;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> j = i + <span class="number">1</span> ; j &lt; n ; j ++ )</span><br><span class="line">        <span class="keyword">if</span>( arr[j] &lt; arr[minIndex] )</span><br><span class="line">            minIndex = j;</span><br><span class="line"></span><br><span class="line">    swap( arr[i] , arr[minIndex] );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-二分搜索树"><a href="#2-二分搜索树" class="headerlink" title="2 二分搜索树"></a>2 二分搜索树</h4><p>树适用于解决递归问题。<br><img src="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91/1.png" alt="二分搜索树1"> </p><figure class="image-box">                <img src="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91/2.png" alt="二分搜索树2" title class>                <p>二分搜索树2</p>            </figure>  <p>二分搜索树不一定是完全二叉树。<br>包括插入、查找、遍历、删除<br>前序遍历、中序遍历、后序遍历、层序遍历（使用队列）。</p><figure class="image-box">                <img src="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91/3.png" alt="删除节点" title class>                <p>删除节点</p>            </figure>  <p>删除节点的两边都有节点时，使用右节点二叉树的最小值代替该节点。</p><p>二分搜索树的局限性：同样的数据可能对应不同的树，树可能层数很高，退化为链表，但不如链表效率高。可以通过平衡二叉树解决。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分搜索树</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BST</span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 树中的节点为私有的结构体, 外界不需要了解二分搜索树节点的具体实现</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">        Key key;</span><br><span class="line">        Value value;</span><br><span class="line">        Node *left;</span><br><span class="line">        Node *right;</span><br><span class="line"></span><br><span class="line">        Node(Key key, Value value)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;key = key;</span><br><span class="line">            <span class="keyword">this</span>-&gt;value = value;</span><br><span class="line">            <span class="keyword">this</span>-&gt;left = <span class="keyword">this</span>-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node(Node *node)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;key = node-&gt;key;</span><br><span class="line">            <span class="keyword">this</span>-&gt;value = node-&gt;value;</span><br><span class="line">            <span class="keyword">this</span>-&gt;left = node-&gt;left;</span><br><span class="line">            <span class="keyword">this</span>-&gt;right = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Node *root; <span class="comment">// 根节点</span></span><br><span class="line">    <span class="keyword">int</span> count;  <span class="comment">// 树中的节点个数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数, 默认构造一棵空二分搜索树</span></span><br><span class="line">    BST()&#123;</span><br><span class="line">        root = <span class="literal">NULL</span>;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数, 释放二分搜索树的所有空间</span></span><br><span class="line">    ~BST()&#123;</span><br><span class="line">        destroy( root );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回二分搜索树的节点个数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回二分搜索树是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向二分搜索树中插入一个新的(key, value)数据对</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Key key, Value value)</span></span>&#123;</span><br><span class="line">        root = insert(root, key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看二分搜索树中是否存在键key</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">contain</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> contain(root, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在二分搜索树中搜索键key所对应的值。如果这个值不存在, 则返回NULL</span></span><br><span class="line">    <span class="function">Value* <span class="title">search</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> search( root , key );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二分搜索树的前序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        preOrder(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二分搜索树的中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        inOrder(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二分搜索树的后序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        postOrder(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二分搜索树的层序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span>&lt;Node*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>( !q.empty() )&#123;</span><br><span class="line"></span><br><span class="line">            Node *node = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line"></span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;node-&gt;key&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( node-&gt;left )</span><br><span class="line">                q.push( node-&gt;left );</span><br><span class="line">            <span class="keyword">if</span>( node-&gt;right )</span><br><span class="line">                q.push( node-&gt;right );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找二分搜索树的最小的键值</span></span><br><span class="line">    <span class="function">Key <span class="title">minimum</span><span class="params">()</span></span>&#123;</span><br><span class="line">        assert( count != <span class="number">0</span> );</span><br><span class="line">        Node* minNode = minimum( root );</span><br><span class="line">        <span class="keyword">return</span> minNode-&gt;key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找二分搜索树的最大的键值</span></span><br><span class="line">    <span class="function">Key <span class="title">maximum</span><span class="params">()</span></span>&#123;</span><br><span class="line">        assert( count != <span class="number">0</span> );</span><br><span class="line">        Node* maxNode = maximum(root);</span><br><span class="line">        <span class="keyword">return</span> maxNode-&gt;key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从二分搜索树中删除最小值所在节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeMin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( root )</span><br><span class="line">            root = removeMin( root );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从二分搜索树中删除最大值所在节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( root )</span><br><span class="line">            root = removeMax( root );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从二分搜索树中删除键值为key的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        root = <span class="built_in">remove</span>(root, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 向以node为根的二分搜索树中, 插入节点(key, value), 使用递归算法</span></span><br><span class="line">    <span class="comment">// 返回插入新节点后的二分搜索树的根</span></span><br><span class="line">    <span class="function">Node* <span class="title">insert</span><span class="params">(Node *node, Key key, Value value)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( node == <span class="literal">NULL</span> )&#123;</span><br><span class="line">            count ++;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Node(key, value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( key == node-&gt;key )</span><br><span class="line">            node-&gt;value = value;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( key &lt; node-&gt;key )</span><br><span class="line">            node-&gt;left = insert( node-&gt;left , key, value);</span><br><span class="line">        <span class="keyword">else</span>    <span class="comment">// key &gt; node-&gt;key</span></span><br><span class="line">            node-&gt;right = insert( node-&gt;right, key, value);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看以node为根的二分搜索树中是否包含键值为key的节点, 使用递归算法</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">contain</span><span class="params">(Node* node, Key key)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( node == <span class="literal">NULL</span> )</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( key == node-&gt;key )</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( key &lt; node-&gt;key )</span><br><span class="line">            <span class="keyword">return</span> contain( node-&gt;left , key );</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// key &gt; node-&gt;key</span></span><br><span class="line">            <span class="keyword">return</span> contain( node-&gt;right , key );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在以node为根的二分搜索树中查找key所对应的value, 递归算法</span></span><br><span class="line">    <span class="comment">// 若value不存在, 则返回NULL</span></span><br><span class="line">    <span class="function">Value* <span class="title">search</span><span class="params">(Node* node, Key key)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( node == <span class="literal">NULL</span> )</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( key == node-&gt;key )</span><br><span class="line">            <span class="keyword">return</span> &amp;(node-&gt;value);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( key &lt; node-&gt;key )</span><br><span class="line">            <span class="keyword">return</span> search( node-&gt;left , key );</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// key &gt; node-&gt;key</span></span><br><span class="line">            <span class="keyword">return</span> search( node-&gt;right, key );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对以node为根的二分搜索树进行前序遍历, 递归算法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node* node)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( node != <span class="literal">NULL</span> )&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;node-&gt;key&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            preOrder(node-&gt;left);</span><br><span class="line">            preOrder(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对以node为根的二分搜索树进行中序遍历, 递归算法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node* node)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( node != <span class="literal">NULL</span> )&#123;</span><br><span class="line">            inOrder(node-&gt;left);</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;node-&gt;key&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            inOrder(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对以node为根的二分搜索树进行后序遍历, 递归算法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Node* node)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( node != <span class="literal">NULL</span> )&#123;</span><br><span class="line">            postOrder(node-&gt;left);</span><br><span class="line">            postOrder(node-&gt;right);</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;node-&gt;key&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放以node为根的二分搜索树的所有节点</span></span><br><span class="line">    <span class="comment">// 采用后续遍历的递归算法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(Node* node)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( node != <span class="literal">NULL</span> )&#123;</span><br><span class="line">            destroy( node-&gt;left );</span><br><span class="line">            destroy( node-&gt;right );</span><br><span class="line"></span><br><span class="line">            <span class="keyword">delete</span> node;</span><br><span class="line">            count --;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回以node为根的二分搜索树的最小键值所在的节点, 递归算法</span></span><br><span class="line">    <span class="function">Node* <span class="title">minimum</span><span class="params">(Node* node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( node-&gt;left == <span class="literal">NULL</span> )</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> minimum(node-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回以node为根的二分搜索树的最大键值所在的节点, 递归算法</span></span><br><span class="line">    <span class="function">Node* <span class="title">maximum</span><span class="params">(Node* node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( node-&gt;right == <span class="literal">NULL</span> )</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maximum(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除掉以node为根的二分搜索树中的最小节点, 递归算法</span></span><br><span class="line">    <span class="comment">// 返回删除节点后新的二分搜索树的根</span></span><br><span class="line">    <span class="function">Node* <span class="title">removeMin</span><span class="params">(Node* node)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( node-&gt;left == <span class="literal">NULL</span> )&#123;</span><br><span class="line"></span><br><span class="line">            Node* rightNode = node-&gt;right;</span><br><span class="line">            <span class="keyword">delete</span> node;</span><br><span class="line">            count --;</span><br><span class="line">            <span class="keyword">return</span> rightNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node-&gt;left = removeMin(node-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除掉以node为根的二分搜索树中的最大节点, 递归算法</span></span><br><span class="line">    <span class="comment">// 返回删除节点后新的二分搜索树的根</span></span><br><span class="line">    <span class="function">Node* <span class="title">removeMax</span><span class="params">(Node* node)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( node-&gt;right == <span class="literal">NULL</span> )&#123;</span><br><span class="line"></span><br><span class="line">            Node* leftNode = node-&gt;left;</span><br><span class="line">            <span class="keyword">delete</span> node;</span><br><span class="line">            count --;</span><br><span class="line">            <span class="keyword">return</span> leftNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node-&gt;right = removeMax(node-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除掉以node为根的二分搜索树中键值为key的节点, 递归算法</span></span><br><span class="line">    <span class="comment">// 返回删除节点后新的二分搜索树的根</span></span><br><span class="line">    <span class="function">Node* <span class="title">remove</span><span class="params">(Node* node, Key key)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( node == <span class="literal">NULL</span> )</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( key &lt; node-&gt;key )&#123;</span><br><span class="line">            node-&gt;left = <span class="built_in">remove</span>( node-&gt;left , key );</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( key &gt; node-&gt;key )&#123;</span><br><span class="line">            node-&gt;right = <span class="built_in">remove</span>( node-&gt;right, key );</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;   <span class="comment">// key == node-&gt;key</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 待删除节点左子树为空的情况</span></span><br><span class="line">            <span class="keyword">if</span>( node-&gt;left == <span class="literal">NULL</span> )&#123;</span><br><span class="line">                Node *rightNode = node-&gt;right;</span><br><span class="line">                <span class="keyword">delete</span> node;</span><br><span class="line">                count --;</span><br><span class="line">                <span class="keyword">return</span> rightNode;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 待删除节点右子树为空的情况</span></span><br><span class="line">            <span class="keyword">if</span>( node-&gt;right == <span class="literal">NULL</span> )&#123;</span><br><span class="line">                Node *leftNode = node-&gt;left;</span><br><span class="line">                <span class="keyword">delete</span> node;</span><br><span class="line">                count--;</span><br><span class="line">                <span class="keyword">return</span> leftNode;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 待删除节点左右子树均不为空的情况</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 找到比待删除节点大的最小节点, 即待删除节点右子树的最小节点</span></span><br><span class="line">            <span class="comment">// 用这个节点顶替待删除节点的位置</span></span><br><span class="line">            Node *successor = <span class="keyword">new</span> Node(minimum(node-&gt;right));</span><br><span class="line">            count ++;</span><br><span class="line"></span><br><span class="line">            successor-&gt;right = removeMin(node-&gt;right);</span><br><span class="line">            successor-&gt;left = node-&gt;left;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">delete</span> node;</span><br><span class="line">            count --;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> successor;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shuffle</span><span class="params">( <span class="keyword">int</span> arr[], <span class="keyword">int</span> n )</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    srand( time(<span class="literal">NULL</span>) );</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = n<span class="number">-1</span> ; i &gt;= <span class="number">0</span> ; i -- )&#123;</span><br><span class="line">        <span class="keyword">int</span> x = rand()%(i+<span class="number">1</span>);</span><br><span class="line">        swap( arr[i] , arr[x] );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试 remove</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    BST&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; bst = BST&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取n个取值范围在[0...n)的随机整数放进二分搜索树中</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++ )&#123;</span><br><span class="line">        <span class="keyword">int</span> key = rand()%n;</span><br><span class="line">        <span class="comment">// 为了后续测试方便,这里value值取和key值一样</span></span><br><span class="line">        <span class="keyword">int</span> value = key;</span><br><span class="line">        bst.insert(key,value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意, 由于随机生成的数据有重复, 所以bst中的数据数量大概率是小于n的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// order数组中存放[0...n)的所有元素</span></span><br><span class="line">    <span class="keyword">int</span> order[n];</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++ )</span><br><span class="line">        order[i] = i;</span><br><span class="line">    <span class="comment">// 打乱order数组的顺序</span></span><br><span class="line">    shuffle( order , n );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 乱序删除[0...n)范围里的所有元素</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++ )</span><br><span class="line">        <span class="keyword">if</span>( bst.contain( order[i] ))&#123;</span><br><span class="line">            bst.<span class="built_in">remove</span>( order[i] );</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"After remove "</span>&lt;&lt;order[i]&lt;&lt;<span class="string">" size = "</span>&lt;&lt;bst.<span class="built_in">size</span>()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最终整个二分搜索树应该为空</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; bst.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构课程笔记</title>
      <link href="/2020/02/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/02/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h3><h4 id="1-最大子列和问题"><a href="#1-最大子列和问题" class="headerlink" title="1 最大子列和问题"></a>1 最大子列和问题</h4><p>给定K个整数组成的序列{ N1, N2, …, NK }，“连续子列”被定义为{ Ni, Ni+1, …, Nj }，其中 1≤i≤j≤K。“最大子列和”则被定义为所有连续子列元素的和中最大者。例如给定序列{ -2, 11, -4, 13, -5, -2 }，其连续子列{ 11, -4, 13 }有最大的和20。现要求你编写程序，计算给定整数序列的最大子列和。</p><p>输入格式:<br>输入第1行给出正整数K (≤100000)；第2行给出K个整数，其间以空格分隔。<br>输入样例：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">-2</span> <span class="number">11</span> <span class="number">-4</span> <span class="number">13</span> <span class="number">-5</span> <span class="number">-2</span></span><br></pre></td></tr></table></figure><p>输出格式:<br>在一行中输出最大子列和。如果序列中所有整数皆为负数，则输出0。<br>输出样例：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result=<span class="number">0</span>,thissum=<span class="number">0</span>,N,digit;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;N);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;digit);</span><br><span class="line">        thissum+=digit;</span><br><span class="line">        <span class="keyword">if</span>(thissum&gt;result)</span><br><span class="line">            result=thissum;</span><br><span class="line">        <span class="keyword">if</span>(thissum&lt;<span class="number">0</span>)   thissum=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-最大子列和问题"><a href="#2-最大子列和问题" class="headerlink" title="2 最大子列和问题"></a>2 最大子列和问题</h4><p>给定K个整数组成的序列{ N1, N2, …, NK }，“连续子列”被定义为{ Ni, Ni+1, …, Nj }，其中 1≤i≤j≤K。“最大子列和”则被定义为所有连续子列元素的和中最大者。例如给定序列{ -2, 11, -4, 13, -5, -2 }，其连续子列{ 11, -4, 13 }有最大的和20。现要求你编写程序，计算给定整数序列的最大子列和，并输出整个序列的第一个和最后一个数。</p><p>输入格式:<br>输入第1行给出正整数K (≤100000)；第2行给出K个整数，其间以空格分隔。<br>输入样例：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">-10</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">-5</span> <span class="number">-23</span> <span class="number">3</span> <span class="number">7</span> <span class="number">-21</span></span><br></pre></td></tr></table></figure><p>输出格式:<br>对于每个测试用例，在一行中输出最大和，以及最大子序列的第一个和最后一个数字。数字必须用一个空格隔开，但行尾不能有多余的空格。如果最大子序列不唯一，则输出索引i和j最小的子序列（如示例所示）。如果所有K个数都是负数，那么它的最大和被定义为0，你应该输出整个序列的第一个和最后一个数。<br>输出样例：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> <span class="number">1</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>, thissum = <span class="number">0</span>, N, digit, startnew = <span class="number">0</span>, start = <span class="number">0</span>, <span class="built_in">end</span>, trigger = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N)) &#123;&#125;;</span><br><span class="line">    <span class="built_in">end</span> = N <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;digit)) &#123;&#125;;</span><br><span class="line">        thissum += digit;</span><br><span class="line">        <span class="keyword">if</span> (thissum &gt; result) &#123;</span><br><span class="line">            <span class="keyword">if</span> (trigger == <span class="number">1</span>) &#123;</span><br><span class="line">                trigger = <span class="number">0</span>;</span><br><span class="line">                start = digit;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">end</span> = digit;</span><br><span class="line">            result = thissum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (thissum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            trigger = <span class="number">1</span>;</span><br><span class="line">            thissum = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>, result, start, <span class="built_in">end</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第二章-线性结构"><a href="#第二章-线性结构" class="headerlink" title="第二章 线性结构"></a>第二章 线性结构</h3><h4 id="1-一元多项式的乘法与加法运算"><a href="#1-一元多项式的乘法与加法运算" class="headerlink" title="1 一元多项式的乘法与加法运算"></a>1 一元多项式的乘法与加法运算</h4><p>设计函数分别求两个一元多项式的乘积与和。</p><p>输入格式:<br>输入分2行，每行分别先给出多项式非零项的个数，再以指数递降方式输入一个多项式非零项系数和指数（绝对值均为不超过1000的整数）。数字间以空格分隔。<br>输入样例：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">3</span> <span class="number">4</span> <span class="number">-5</span> <span class="number">2</span>  <span class="number">6</span> <span class="number">1</span>  <span class="number">-2</span> <span class="number">0</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">20</span>  <span class="number">-7</span> <span class="number">4</span>  <span class="number">3</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>输出格式:<br>输出分2行，分别以指数递降方式输出乘积多项式以及和多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。零多项式应输出0 0。<br>输出样例：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">15</span> <span class="number">24</span> <span class="number">-25</span> <span class="number">22</span> <span class="number">30</span> <span class="number">21</span> <span class="number">-10</span> <span class="number">20</span> <span class="number">-21</span> <span class="number">8</span> <span class="number">35</span> <span class="number">6</span> <span class="number">-33</span> <span class="number">5</span> <span class="number">14</span> <span class="number">4</span> <span class="number">-15</span> <span class="number">3</span> <span class="number">18</span> <span class="number">2</span> <span class="number">-6</span> <span class="number">1</span></span><br><span class="line"><span class="number">5</span> <span class="number">20</span> <span class="number">-4</span> <span class="number">4</span> <span class="number">-5</span> <span class="number">2</span> <span class="number">9</span> <span class="number">1</span> <span class="number">-2</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PolyNode</span> *<span class="title">Polynomial</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PolyNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> coef;</span><br><span class="line">    <span class="keyword">int</span> expon;</span><br><span class="line">    Polynomial link;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Attach</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> e, Polynomial* pRear)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Polynomial P;</span><br><span class="line"></span><br><span class="line">    P = (Polynomial)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct PolyNode));</span><br><span class="line">    P-&gt;coef = c;</span><br><span class="line">    P-&gt;expon = e;</span><br><span class="line">    P-&gt;link = <span class="literal">NULL</span>;</span><br><span class="line">    (*pRear)-&gt;link = P;</span><br><span class="line">    *pRear = P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Polynomial <span class="title">ReadPoly</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Polynomial P, Rear, t;</span><br><span class="line">    <span class="keyword">int</span> c, e, N;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">    P = (Polynomial)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct PolyNode)); <span class="comment">//表头空结点</span></span><br><span class="line">    P-&gt;link = <span class="literal">NULL</span>;</span><br><span class="line">    Rear = P;</span><br><span class="line">    <span class="keyword">while</span> (N--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;c, &amp;e);</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="number">0</span>)       </span><br><span class="line">            Attach(c, e, &amp;Rear);    <span class="comment">//当前项插入尾部</span></span><br><span class="line">    &#125;</span><br><span class="line">    t = P; P = P-&gt;link; <span class="built_in">free</span>(t);  <span class="comment">//删除临时头结点</span></span><br><span class="line">    <span class="keyword">return</span> P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Compare</span><span class="params">(<span class="keyword">int</span> e1, <span class="keyword">int</span> e2)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/*比较两项指数e1和e2，根据大、小、等三种情况分别返回1，-1，0 */</span></span><br><span class="line">    <span class="keyword">if</span> (e1 &gt; e2) <span class="keyword">return</span> <span class="number">1</span>;       <span class="comment">/* e1大，返回1       */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (e1 &lt; e2) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">/* e2大，返回-1      */</span></span><br><span class="line">    <span class="keyword">else</span>  <span class="keyword">return</span> <span class="number">0</span>;                <span class="comment">/* e1和e2相等，返回0 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Polynomial <span class="title">Add</span><span class="params">(Polynomial P1, Polynomial P2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Polynomial front, rear, temp;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    rear = (Polynomial)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct PolyNode));</span><br><span class="line">    front = rear;</span><br><span class="line">    <span class="keyword">while</span> (P1 &amp;&amp; P2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (Compare(P1-&gt;expon, P2-&gt;expon))</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            Attach(P1-&gt;coef, P1-&gt;expon, &amp;rear);</span><br><span class="line">            P1 = P1-&gt;link;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">            Attach(P2-&gt;coef, P2-&gt;expon, &amp;rear);</span><br><span class="line">            P2 = P2-&gt;link;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            sum = P1-&gt;coef + P2-&gt;coef;</span><br><span class="line">            <span class="keyword">if</span> (sum) Attach(sum, P1-&gt;expon, &amp;rear);</span><br><span class="line">            P1 = P1-&gt;link;</span><br><span class="line">            P2 = P2-&gt;link;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; P1; P1 = P1-&gt;link) Attach(P1-&gt;coef, P1-&gt;expon, &amp;rear);</span><br><span class="line">    <span class="keyword">for</span> (; P2; P2 = P2-&gt;link) Attach(P2-&gt;coef, P2-&gt;expon, &amp;rear);</span><br><span class="line">    rear-&gt;link = <span class="literal">NULL</span>;</span><br><span class="line">    temp = front;</span><br><span class="line">    front = front-&gt;link;</span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">    <span class="keyword">return</span> front;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Polynomial <span class="title">Mult</span><span class="params">(Polynomial P1, Polynomial P2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Polynomial P, Rear, t1, t2, t;</span><br><span class="line">    <span class="keyword">int</span> c, e;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!P1 || !P2) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    t1 = P1; t2 = P2;</span><br><span class="line">    P = (Polynomial)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct PolyNode)); P-&gt;link = <span class="literal">NULL</span>;</span><br><span class="line">    Rear = P;</span><br><span class="line">    <span class="keyword">while</span> (t2)   <span class="comment">//先使用P1第一项乘P2得到初始链表</span></span><br><span class="line">    &#123;</span><br><span class="line">        Attach(t1-&gt;coef * t2-&gt;coef, t1-&gt;expon + t2-&gt;expon, &amp;Rear);</span><br><span class="line">        t2 = t2-&gt;link;</span><br><span class="line">    &#125;</span><br><span class="line">    t1 = t1-&gt;link;</span><br><span class="line">    <span class="keyword">while</span> (t1)</span><br><span class="line">    &#123;</span><br><span class="line">        t2 = P2; Rear = P;</span><br><span class="line">        <span class="keyword">while</span> (t2)</span><br><span class="line">        &#123;</span><br><span class="line">            e = t1-&gt;expon + t2-&gt;expon;</span><br><span class="line">            c = t1-&gt;coef * t2-&gt;coef;</span><br><span class="line">            <span class="keyword">while</span> (Rear-&gt;link &amp;&amp; Rear-&gt;link-&gt;expon &gt; e)</span><br><span class="line">                Rear = Rear-&gt;link;</span><br><span class="line">            <span class="keyword">if</span> (Rear-&gt;link &amp;&amp; Rear-&gt;link-&gt;expon == e)  <span class="comment">//与下一个相等</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (Rear-&gt;link-&gt;coef + c)</span><br><span class="line">                    Rear-&gt;link-&gt;coef += c;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    t = Rear-&gt;link;</span><br><span class="line">                    Rear-&gt;link = t-&gt;link;</span><br><span class="line">                    <span class="built_in">free</span>(t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>                                <span class="comment">//比下一个大</span></span><br><span class="line">            &#123;</span><br><span class="line">                t = (Polynomial)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct PolyNode));</span><br><span class="line">                t-&gt;coef = c; t-&gt;expon = e; t-&gt;link = Rear-&gt;link;</span><br><span class="line">                Rear-&gt;link = t; Rear = Rear-&gt;link;</span><br><span class="line">            &#125;</span><br><span class="line">            t2 = t2-&gt;link;</span><br><span class="line">        &#125;</span><br><span class="line">        t1 = t1-&gt;link;</span><br><span class="line">    &#125;</span><br><span class="line">    t2 = P; P = P-&gt;link; <span class="built_in">free</span>(t2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintPoly</span><span class="params">(Polynomial P)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c, e, flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!P) &#123; <span class="built_in">printf</span>(<span class="string">"0 0"</span>); <span class="keyword">return</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (P)</span><br><span class="line">    &#123;</span><br><span class="line">        c = P-&gt;coef; e = P-&gt;expon;</span><br><span class="line">        <span class="keyword">if</span> (!flag)</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d"</span>, c, e);</span><br><span class="line">        P = P-&gt;link;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Polynomial P1, P2, PP, PS;</span><br><span class="line"></span><br><span class="line">    P1 = ReadPoly();</span><br><span class="line">    P2 = ReadPoly();</span><br><span class="line">    PP = Mult(P1, P2);</span><br><span class="line">    PrintPoly(PP);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    PS = Add(P1, P2);</span><br><span class="line">    PrintPoly(PS);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-两个有序链表序列的合并"><a href="#2-两个有序链表序列的合并" class="headerlink" title="2 两个有序链表序列的合并"></a>2 两个有序链表序列的合并</h4><p>本题要求实现一个函数，将两个链表表示的递增整数序列合并为一个非递减的整数序列。<br>L1和L2是给定的带头结点的单链表，其结点存储的数据是递增有序的；函数Merge要将L1和L2合并为一个非递减的整数序列。应直接使用原序列中的结点，返回归并后的带头结点的链表头指针。</p><p>输入样例：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">6</span> <span class="number">8</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><p>输出样例：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">8</span> <span class="number">10</span> </span><br><span class="line"><span class="literal">NULL</span></span><br><span class="line"><span class="literal">NULL</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">PtrToNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    PtrToNode   Next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToNode List;</span><br><span class="line"></span><br><span class="line"><span class="function">List <span class="title">Read</span><span class="params">()</span></span>; <span class="comment">/* 细节在此不表 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(List L)</span></span>; <span class="comment">/* 细节在此不表；空链表将输出NULL */</span></span><br><span class="line"></span><br><span class="line"><span class="function">List <span class="title">Merge</span><span class="params">(List L1, List L2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List L1, L2, L;</span><br><span class="line">    L1 = Read();</span><br><span class="line">    L2 = Read();</span><br><span class="line">    L = Merge(L1, L2);</span><br><span class="line">    Print(L);</span><br><span class="line">    Print(L1);</span><br><span class="line">    Print(L2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Attach</span><span class="params">(<span class="keyword">int</span> d, List* pRear)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List P;</span><br><span class="line"></span><br><span class="line">    P = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Node));</span><br><span class="line">    P-&gt;Data = d;</span><br><span class="line">    P-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    (*pRear)-&gt;Next = P;</span><br><span class="line">    *pRear = P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">List <span class="title">Merge</span><span class="params">(List L1, List L2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List temp1 = L1-&gt;Next;</span><br><span class="line">    List temp2 = L2-&gt;Next;</span><br><span class="line">    List p;</span><br><span class="line">    p = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Node));</span><br><span class="line">    p-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    List temp = p;</span><br><span class="line">    <span class="keyword">while</span> (temp1 &amp;&amp; temp2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (temp1-&gt;Data &lt; temp2-&gt;Data) &#123;</span><br><span class="line">            temp-&gt;Next = temp1;</span><br><span class="line">            temp1 = temp1-&gt;Next;</span><br><span class="line">            temp = temp-&gt;Next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            temp-&gt;Next = temp2;</span><br><span class="line">            temp2 = temp2-&gt;Next;</span><br><span class="line">            temp = temp-&gt;Next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (temp1 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        temp-&gt;Next = temp1;</span><br><span class="line">        temp1 = temp1-&gt;Next;</span><br><span class="line">        temp = temp-&gt;Next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (temp2 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        temp-&gt;Next = temp2;</span><br><span class="line">        temp2 = temp2-&gt;Next;</span><br><span class="line">        temp = temp-&gt;Next;</span><br><span class="line">    &#125;</span><br><span class="line">    L1-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    L2-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    temp-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">List <span class="title">Read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List P, Rear, t;</span><br><span class="line">    <span class="keyword">int</span> d, N;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">    P = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Node)); <span class="comment">//表头空结点</span></span><br><span class="line">    P-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    Rear = P;</span><br><span class="line">    <span class="keyword">while</span> (N--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;d);</span><br><span class="line">        Attach(d, &amp;Rear);    <span class="comment">//当前项插入尾部</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(List L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L-&gt;Next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"NULL\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    List temp = L-&gt;Next;</span><br><span class="line">    <span class="keyword">while</span> (temp) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, temp-&gt;Data);</span><br><span class="line">        temp = temp-&gt;Next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-Pop-Sequence"><a href="#3-Pop-Sequence" class="headerlink" title="3 Pop Sequence"></a>3 Pop Sequence</h4><p>给定一个最多能保存M个数的堆栈。按1，2，3，…，N的顺序推N个数字，然后随机弹出。您应该知道给定的数字序列是否可能是堆栈的弹出序列。例如，如果M是5，N是7，我们可以从堆栈中获得1，2，3，4，5，6，7，但不能从3，2，1，7，5，6，4。</p><p>输入格式:<br>每个输入文件包含一个测试用例。对于每种情况，第一行包含3个数字（都不超过1000）：M（堆栈的最大容量）、N（推送序列的长度）和K（要检查的pop序列的数量）。接下来是K行，每行包含N个数字的pop序列。一行中的所有数字都用空格隔开。<br>输入样例：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">7</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">7</span> <span class="number">5</span> <span class="number">6</span> <span class="number">4</span></span><br><span class="line"><span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">5</span> <span class="number">6</span> <span class="number">4</span> <span class="number">3</span> <span class="number">7</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p>输出格式:<br>对于每个弹出序列，如果确实是堆栈的可能弹出序列，则在一行中打印“YES”，如果不是，则打印“NO”。<br>输出样例：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">YES</span><br><span class="line">NO</span><br><span class="line">NO</span><br><span class="line">YES</span><br><span class="line">NO</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, m, n, k, a[<span class="number">1000</span>][<span class="number">1000</span>], b[<span class="number">1000</span>], <span class="built_in">stack</span>[<span class="number">1000</span>], stack_index, top;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;m, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)    <span class="comment">//读取每一行</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i][j]);                   </span><br><span class="line">        &#125;</span><br><span class="line">        stack_index = <span class="number">1</span>;      <span class="comment">//模拟栈</span></span><br><span class="line">        top = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">stack</span>[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (a[i][j] &gt; top)</span><br><span class="line">            &#123;</span><br><span class="line">                stack_index++;</span><br><span class="line">                top++;</span><br><span class="line">                <span class="built_in">stack</span>[stack_index] = top;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (stack_index &gt; m || a[i][j] &lt; <span class="built_in">stack</span>[stack_index])</span><br><span class="line">            &#123;</span><br><span class="line">                b[i] = <span class="number">0</span>;       <span class="comment">//无法实现栈则结果为0，退出</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a[i][j] == <span class="built_in">stack</span>[stack_index])</span><br><span class="line">            &#123;</span><br><span class="line">                stack_index--;</span><br><span class="line">                <span class="comment">//top = stack[stack_index];</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stack_index == <span class="number">0</span>)   <span class="comment">//成功实现栈则结果为1</span></span><br><span class="line">            b[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b[i] == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"NO"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (b[i] == <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"YES"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第三章-树结构（上）"><a href="#第三章-树结构（上）" class="headerlink" title="第三章 树结构（上）"></a>第三章 树结构（上）</h3><h4 id="1-树的同构"><a href="#1-树的同构" class="headerlink" title="1 树的同构"></a>1 树的同构</h4><p>给定两棵树T1和T2。如果T1可以通过若干次左右孩子互换就变成T2，则我们称两棵树是“同构”的。例如图1给出的两棵树就是同构的，因为我们把其中一棵树的结点A、B、G的左右孩子互换后，就得到另外一棵树。而图2就不是同构的。</p><figure class="image-box">                <img src="/2020/02/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/1.png" alt="1" title class>                <p>1</p>            </figure>  <p>图1<br><img src="/2020/02/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/2.png" alt="2"><br>图2<br>输入格式:<br>输入给出2棵二叉树树的信息。对于每棵树，首先在一行中给出一个非负整数N (≤10)，即该树的结点数（此时假设结点从0到N−1编号）；随后N行，第i行对应编号第i个结点，给出该结点中存储的1个英文大写字母、其左孩子结点的编号、右孩子结点的编号。如果孩子结点为空，则在相应位置上给出“-”。给出的数据间用一个空格分隔。注意：题目保证每个结点中存储的字母是不同的。  </p><p>输出格式:<br>如果两棵树是同构的，输出“Yes”，否则输出“No”。</p><p>输入样例1（对应图1）：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span></span><br><span class="line">A <span class="number">1</span> <span class="number">2</span></span><br><span class="line">B <span class="number">3</span> <span class="number">4</span></span><br><span class="line">C <span class="number">5</span> -</span><br><span class="line">D - -</span><br><span class="line">E <span class="number">6</span> -</span><br><span class="line">G <span class="number">7</span> -</span><br><span class="line">F - -</span><br><span class="line">H - -</span><br><span class="line"><span class="number">8</span></span><br><span class="line">G - <span class="number">4</span></span><br><span class="line">B <span class="number">7</span> <span class="number">6</span></span><br><span class="line">F - -</span><br><span class="line">A <span class="number">5</span> <span class="number">1</span></span><br><span class="line">H - -</span><br><span class="line">C <span class="number">0</span> -</span><br><span class="line">D - -</span><br><span class="line">E <span class="number">2</span> -</span><br></pre></td></tr></table></figure><p>输出样例1（对应图1）：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br></pre></td></tr></table></figure><p>输入样例2（对应图2）：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span></span><br><span class="line">B <span class="number">5</span> <span class="number">7</span></span><br><span class="line">F - -</span><br><span class="line">A <span class="number">0</span> <span class="number">3</span></span><br><span class="line">C <span class="number">6</span> -</span><br><span class="line">H - -</span><br><span class="line">D - -</span><br><span class="line">G <span class="number">4</span> -</span><br><span class="line">E <span class="number">1</span> -</span><br><span class="line"><span class="number">8</span></span><br><span class="line">D <span class="number">6</span> -</span><br><span class="line">B <span class="number">5</span> -</span><br><span class="line">E - -</span><br><span class="line">H - -</span><br><span class="line">C <span class="number">0</span> <span class="number">2</span></span><br><span class="line">G - <span class="number">3</span></span><br><span class="line">F - -</span><br><span class="line">A <span class="number">1</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p>输出样例2（对应图2）：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    String val;</span><br><span class="line">    <span class="keyword">int</span> left;</span><br><span class="line">    <span class="keyword">int</span> right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> TreeNode[] T1 = <span class="keyword">new</span> TreeNode[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> TreeNode[] T2 = <span class="keyword">new</span> TreeNode[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] check = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> T = scan.nextInt();</span><br><span class="line">        Arrays.fill(check, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T; i++) &#123;</span><br><span class="line">            T1[i] = <span class="keyword">new</span> TreeNode();</span><br><span class="line">            T1[i].val = scan.next();</span><br><span class="line">            String left = scan.next();</span><br><span class="line">            String right = scan.next();</span><br><span class="line">            <span class="keyword">if</span> (left.equals(<span class="string">"-"</span>)) &#123;</span><br><span class="line">                T1[i].left = -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                T1[i].left = Integer.parseInt(left);</span><br><span class="line">                check[Integer.parseInt(left)] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (right.equals(<span class="string">"-"</span>)) &#123;</span><br><span class="line">                T1[i].right = -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                T1[i].right = Integer.parseInt(right);</span><br><span class="line">                check[Integer.parseInt(right)] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> root = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (check[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                root = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        T = scan.nextInt();</span><br><span class="line">        Arrays.fill(check, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T; i++) &#123;</span><br><span class="line">            T2[i] = <span class="keyword">new</span> TreeNode();</span><br><span class="line">            T2[i].val = scan.next();</span><br><span class="line">            String left = scan.next();</span><br><span class="line">            String right = scan.next();</span><br><span class="line">            <span class="keyword">if</span> (left.equals(<span class="string">"-"</span>)) &#123;</span><br><span class="line">                T2[i].left = -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                T2[i].left = Integer.parseInt(left);</span><br><span class="line">                check[Integer.parseInt(left)] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (right.equals(<span class="string">"-"</span>)) &#123;</span><br><span class="line">                T2[i].right = -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                T2[i].right = Integer.parseInt(right);</span><br><span class="line">                check[Integer.parseInt(right)] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> root1 = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (check[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                root1 = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Isomorphic(root, root1) ? <span class="string">"Yes"</span> : <span class="string">"No"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//传递进来root的索引值可以避免数组越界</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">Isomorphic</span><span class="params">(<span class="keyword">int</span> node1, <span class="keyword">int</span> node2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node1 == -<span class="number">1</span> &amp;&amp; node2 == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((node1 == -<span class="number">1</span> &amp;&amp; node2 != -<span class="number">1</span>) || (node1 != -<span class="number">1</span> &amp;&amp; node2 == -<span class="number">1</span>) || (!T1[node1].val.equals(T2[node2].val))) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (T1[node1].left == -<span class="number">1</span> &amp;&amp; T2[node2].left == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Isomorphic(T1[node1].right, T2[node2].right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((T1[node1].left != -<span class="number">1</span> &amp;&amp; T2[node2].left != -<span class="number">1</span>) &amp;&amp; T1[T1[node1].left].val.equals(T2[T2[node2].left].val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> (Isomorphic(T1[node1].left, T2[node2].left) &amp;&amp; Isomorphic(T1[node1].right, T2[node2].right));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Isomorphic(T1[node1].left, T2[node2].right) &amp;&amp; Isomorphic(T1[node1].right, T2[node2].left));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-List-Leaves"><a href="#2-List-Leaves" class="headerlink" title="2 List Leaves"></a>2 List Leaves</h4><p>给定一棵树，您应该按照从上到下，从左到右的顺序列出所有叶子。</p><p>输入格式:<br>每个输入文件包含一个测试用例。对于每种情况，第一行给出一个正整数N（≤ 1 0），这是树中的节点的总数-并且因此节点编号从0到N − 1。然后N行跟随，每行对应一个节点，并给出该节点的左，右子级的索引。如果孩子不存在，将在该位置放置一个“-”。任何一对孩子都用空格隔开。</p><p>输出格式:<br>对于每个测试用例，按从上到下，从左到右的顺序在一行中打印所有叶子的索引。相邻数字之间必须恰好有一个空格，并且在行尾不能有多余的空格。</p><p>输入样例：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">1</span> -</span><br><span class="line">- -</span><br><span class="line"><span class="number">0</span> -</span><br><span class="line"><span class="number">2</span> <span class="number">7</span></span><br><span class="line">- -</span><br><span class="line">- -</span><br><span class="line"><span class="number">5</span> -</span><br><span class="line"><span class="number">4</span> <span class="number">6</span></span><br></pre></td></tr></table></figure><p>输出样例：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">1</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left;</span><br><span class="line">    <span class="keyword">int</span> right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> TreeNode[] tree = <span class="keyword">new</span> TreeNode[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] check = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> T = scan.nextInt();</span><br><span class="line">        Arrays.fill(check, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T; i++) &#123;</span><br><span class="line">            tree[i] = <span class="keyword">new</span> TreeNode();</span><br><span class="line">            String left = scan.next();</span><br><span class="line">            String right = scan.next();</span><br><span class="line">            <span class="keyword">if</span> (left.equals(<span class="string">"-"</span>)) &#123;</span><br><span class="line">                tree[i].left = -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tree[i].left = Integer.parseInt(left);</span><br><span class="line">                check[Integer.parseInt(left)] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (right.equals(<span class="string">"-"</span>)) &#123;</span><br><span class="line">                tree[i].right = -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tree[i].right = Integer.parseInt(right);</span><br><span class="line">                check[Integer.parseInt(right)] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> root = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (check[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                root = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printLeaves(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printLeaves</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tree[node].left != -<span class="number">1</span>) &#123;</span><br><span class="line">            queue.offer(tree[node].left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tree[node].right != -<span class="number">1</span>) &#123;</span><br><span class="line">            queue.offer(tree[node].right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tree[node].left == -<span class="number">1</span> &amp;&amp; tree[node].right == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                System.out.print(<span class="string">" "</span> + node);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                System.out.print(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Object n = queue.poll();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            printLeaves((<span class="keyword">int</span>)n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>编译原理学习笔记四-词法分析</title>
      <link href="/2020/02/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/"/>
      <url>/2020/02/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="第四章-词法分析"><a href="#第四章-词法分析" class="headerlink" title="第四章 词法分析"></a>第四章 词法分析</h1><h3 id="第一部分：词法分析器的设计"><a href="#第一部分：词法分析器的设计" class="headerlink" title="第一部分：词法分析器的设计"></a>第一部分：词法分析器的设计</h3><h4 id="1-词法分析的任务"><a href="#1-词法分析的任务" class="headerlink" title="1 词法分析的任务"></a>1 词法分析的任务</h4><p>词法分析的任务：从左至右逐个字符地对源程序进行扫描，产生一个个单词符号  </p><p>词法分析器(Lexical Analyzer)：扫描器(Scanner)、执行词法分析的程序</p><h4 id="2-词法分析器的功能"><a href="#2-词法分析器的功能" class="headerlink" title="2 词法分析器的功能"></a>2 词法分析器的功能</h4><p>功能：输入源程序、输出单词符号</p><p>单词符号的种类：<br>基本字：如 begin，repeat，for，…<br>标识符：用来表示各种名字，如变量名、数组名和过程名<br>常数：各种类型的常数<br>运算符：+，-，*，/，…<br>界符：逗号、分号、括号和空白</p><h4 id="3-词法分析器的输出"><a href="#3-词法分析器的输出" class="headerlink" title="3 词法分析器的输出"></a>3 词法分析器的输出</h4><p>输出：输出的单词符号的表示形式(单词种别，单词自身的值)</p><p>单词种别通常用整数编码表示：<br>若一个种别只有一个单词符号，则种别编码就代表该单词符号。假定基本字、运算符和界符都是一符一种。<br>若一个种别有多个单词符号，则对于每个单词符号，给出种别编码和自身的值。</p><h4 id="4-词法分析器在编译器中的地位"><a href="#4-词法分析器在编译器中的地位" class="headerlink" title="4 词法分析器在编译器中的地位"></a>4 词法分析器在编译器中的地位</h4><figure class="image-box">                <img src="/2020/02/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/2.png" alt="词法分析器在编译器中的地位" title class>                <p>词法分析器在编译器中的地位</p>            </figure><h4 id="5-词法分析器的结构"><a href="#5-词法分析器的结构" class="headerlink" title="5 词法分析器的结构"></a>5 词法分析器的结构</h4><figure class="image-box">                <img src="/2020/02/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/1.png" alt="词法分析器的结构" title class>                <p>词法分析器的结构</p>            </figure><h4 id="6-避免超前搜索"><a href="#6-避免超前搜索" class="headerlink" title="6 避免超前搜索"></a>6 避免超前搜索</h4><p>所有基本字都是保留字;用户不能用它们作自己的标识符；<br>基本字作为特殊的标识符来处理，使用保留字表；<br>如果基本字、标识符和常数(或标号)之间没有确定的运算符或界符作间隔，则必须使用一个空白符作间隔。</p><h4 id="7-状态转换图"><a href="#7-状态转换图" class="headerlink" title="7 状态转换图"></a>7 状态转换图</h4><p>状态转换图是一张有限方向图。<br>结点代表状态，用圆圈表示；<br>状态之间用箭弧连结，箭弧上的标记(字符)代表射出结状态下可能出现的输入字符或字符类；<br>一张转换图只包含有限个状态，其中有一个为初态，至少要有一个终态。</p><p>状态转换图可用于识别(或接受)一定的字符串。<br>若存在一条从初态到某一终态的道路，且这条路上所有弧上的标记符连接成的字等于α，则称α被该状态转换图所识别(接受)</p><h4 id="8-词法分析器的设计示例"><a href="#8-词法分析器的设计示例" class="headerlink" title="8 词法分析器的设计示例"></a>8 词法分析器的设计示例</h4><figure class="image-box">                <img src="/2020/02/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/3.png" alt="词法分析器的设计示例" title class>                <p>词法分析器的设计示例</p>            </figure><h4 id="9-状态转换图的程序实现"><a href="#9-状态转换图的程序实现" class="headerlink" title="9 状态转换图的程序实现"></a>9 状态转换图的程序实现</h4><p>不含回路的分叉结点：可用一个CASE语句或一组IF-THEN-ELSE语句实现；<br>含回路的状态结点：对应一段由WHILE结构和IF语句构成的程序；<br>终态结点：表示识别出某种单词符号，对应返回语句。</p><h3 id="第二部分：词法规则的形式化"><a href="#第二部分：词法规则的形式化" class="headerlink" title="第二部分：词法规则的形式化"></a>第二部分：词法规则的形式化</h3><h4 id="10-正规式和正规集"><a href="#10-正规式和正规集" class="headerlink" title="10 正规式和正规集"></a>10 正规式和正规集</h4><p>正规集可以用正规式表示，正规式是表示正规集一种方法。<br>一个字集合是正规集当且仅当它能用正规式表示。<br>递归定义：<br>&nbsp;&nbsp;&nbsp;&nbsp;ε和Ø都是Σ上的正规式，它们所表示的正规集为{ε}和Ø;<br>&nbsp;&nbsp;&nbsp;&nbsp;任何a∈Σ，a是Σ上的正规式，它所表示的正规集为{a};<br>&nbsp;&nbsp;&nbsp;&nbsp;假定e1和e2都是上的正规式，它们所表示的正规集为L(e1)和L(e2)，则：(e1|e2)为正规式，它所表示的正规集为L(e1)∪L(e2)，(e1.e2)为正规式，它所表示的正规集为L(e1)L(e2)，(e1)*为正规式，它所表示的正规集为(L(e1))*。</p><p>若两个正规式所表示的正规集相同，则称这两个正规式等价。</p><p>正规式满足交换律、结合律、分配律。但e1e2 &lt;&gt; e2e1。</p><h4 id="11-确定有限自动机-DFA"><a href="#11-确定有限自动机-DFA" class="headerlink" title="11 确定有限自动机(DFA)"></a>11 确定有限自动机(DFA)</h4><p>确定有限自动机(Deterministic Finite Automata，DFA) M是一个五元式，M=(S, Σ, f, S0, F)，其中：<br>S：有穷状态集；<br>Σ：输入字母表(有穷)；<br>f：状态转换函数，为S×Σ→S的单值部分映射，f(s，a)=s’表示：当现行状态为s，输入字符为a时，将状态转换到下一状态s’，s’称为s的一个后继状态；<br>S0∈S是唯一的一个初态；<br>F⊆S：终态集(可空)。</p><p>例如：<br><img src="/2020/02/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/4.png" alt="确定有限自动机(DFA)"></p><p>对于Σ*中的任何字α，若存在一条从初态到某一终态的道路，且这条路上所有弧上的标记符连接成的字等于α，则称α为DFA M所识别(接收)。<br>DFA M所识别的字的全体记为L(M)。</p><h4 id="12-非确定有限自动机-NFA"><a href="#12-非确定有限自动机-NFA" class="headerlink" title="12 非确定有限自动机(NFA)"></a>12 非确定有限自动机(NFA)</h4><p>非确定有限自动机(Nondeterministic Finite Automata，NFA) M是一个五元式M=(S, Σ, f, S0, F)，其中：<br>S：有穷状态集<br>Σ：输入字母表(有穷)<br>f：状态转换函数，为S×Σ*→2S的部分映射<br>S0⊆S是非空的初态集<br>F⊆S：终态集(可空)</p><p>NFA 和DFA的区别：<br>NFA可以有多个初态；<br>弧上的标记可以是Σ*中的一个字(甚至可以是一个正规式)，而不一定是单个字符；<br>同一个字可能出现在同状态射出的多条弧上。</p><h4 id="13-DFA和NFA"><a href="#13-DFA和NFA" class="headerlink" title="13 DFA和NFA"></a>13 DFA和NFA</h4><p>对于任何两个有限自动机M和M’，如果L(M)=L(M’)，则称M与M’等价。<br>自动机理论中一个重要的结论：判定两个自动机等价性的算法是存在的。<br>对于每个NFA M存在一个DFA M’，使得 L(M)=L(M’)。<br>DFA与NFA识别能力相同。</p><h3 id="第三部分：有限自动机的等价性"><a href="#第三部分：有限自动机的等价性" class="headerlink" title="第三部分：有限自动机的等价性"></a>第三部分：有限自动机的等价性</h3><h4 id="14-DFA的化简"><a href="#14-DFA的化简" class="headerlink" title="14 DFA的化简"></a>14 DFA的化简</h4><p>对于给定的DFA M，寻找一个状态数比M少的DFA M’，使得L(M)=L(M’)。  </p><p>状态的等价性：<br>假设s和t为M的两个状态，如果从状态s出发能读出某个字α而停止于终态，那么同样，从t出发也能读出α而停止于终态；反之亦然，称s和t等价；<br>两个状态不等价，则称它们是可区别的。</p><p>基本思想：<br>把M的状态集划分为一些不相交的子集，使得任何两个不同子集的状态是可区别的，而同一子集的任何两个状态是等价的。<br>最后，让每个子集选出一个代表，同时消去其他状态。</p><p>子集划分：<br>首先，把S划分为终态和非终态两个子集，形成基本划分Π；<br>假定到某个时候，Π已含m个子集，记为Π={I(1)，I(2)，…，I(m)}，检查Π中的每个子集看是否能进一步划分；<br>一般地，对某个a和I(i)，若Ia(i) 落入现行Π中N个不同子集，则应把I(i)划分成N个不相交的组，使得每个组J的Ja都落入的Π同一子集；<br>重复上述过程，直到Π所含子集数不再增长；<br>对于上述最后划分Π中的每个子集，我们选取每个子集I中的一个状态代表其他状态，则可得到化简后的DFA M’；<br>若I含有原来的初态，则其代表为新的初态，若I含有原来的终态，则其代表为新的终态。</p><h4 id="15-NFA与正规式的转换"><a href="#15-NFA与正规式的转换" class="headerlink" title="15 NFA与正规式的转换"></a>15 NFA与正规式的转换</h4><p>对转换图概念拓广，令每条弧可用一个正规式作标记。</p><ol><li>对任何FA M，都存在一个正规式r，使得L(r)=L(M)。</li><li>对任何正规式r，都存在一个FA M，使得L(M)=L(r)。</li></ol><p>状态转换图消去结点的方法：</p><figure class="image-box">                <img src="/2020/02/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/5.png" alt="状态转换图消去结点的方法" title class>                <p>状态转换图消去结点的方法</p>            </figure><h4 id="16-词法分析程序自动生成–LEX"><a href="#16-词法分析程序自动生成–LEX" class="headerlink" title="16 词法分析程序自动生成–LEX"></a>16 词法分析程序自动生成–LEX</h4><figure class="image-box">                <img src="/2020/02/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/6.png" alt="词法分析程序自动生成--LEX" title class>                <p>词法分析程序自动生成--LEX</p>            </figure>  <p>工作过程：<br>对每条识别规则Pi构造一个相应的非确定有限自动机Mi；<br>引进一个新初态X，通过弧，将这些自动机连接成一个新的NFA；<br>把M确定化、最小化，生成该DFA的状态转换表和控制执行程序。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>编译原理学习笔记三-高级程序设计语言的语法描述</title>
      <link href="/2020/02/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E7%9A%84%E8%AF%AD%E6%B3%95%E6%8F%8F%E8%BF%B0/"/>
      <url>/2020/02/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E7%9A%84%E8%AF%AD%E6%B3%95%E6%8F%8F%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="第三章-高级程序设计语言的语法描述"><a href="#第三章-高级程序设计语言的语法描述" class="headerlink" title="第三章 高级程序设计语言的语法描述"></a>第三章 高级程序设计语言的语法描述</h1><h4 id="1-文法"><a href="#1-文法" class="headerlink" title="1 文法"></a>1 文法</h4><p>文法： 描述语言的语法结构的形式规则。</p><p>例：He gave me a book.<br>&lt;句子&gt; → &lt;主语&gt;&lt;谓语&gt;&lt;间接宾语&gt;&lt;直接宾语&gt;<br>&lt;主语&gt; → &lt;代词&gt;<br>&lt;谓语&gt; → &lt;动词&gt;<br>&lt;间接宾语&gt; → &lt;代词&gt;<br>&lt;直接宾语&gt; → &lt;冠词&gt; &lt;名词&gt;<br>&lt;代词&gt; → He<br>&lt;代词&gt; → me<br>&lt;名词&gt; → book<br>&lt;冠词&gt; → a<br>&lt;动词&gt; → gave  </p><h4 id="2-语法描述的几个基本概念"><a href="#2-语法描述的几个基本概念" class="headerlink" title="2 语法描述的几个基本概念"></a>2 语法描述的几个基本概念</h4><p>字母表：一个有穷字符集，记为∑<br>字母表中每个元素称为字符<br>∑上的字(也叫字符串)  是指由∑中的字符所构成的一个有穷序列<br>不包含任何字符的序列称为空字，记为ε<br>用∑*表示∑上的所有字的全体，包含空字ε<br>∑*的子集U和V的连接（积）定义为UV＝{ αβ | α∈U &amp; β∈V }<br>V自身的n次积记为Vn=V V … V<br>V0={ε}<br>V*是V的闭包： V<em>=V0∪V1∪V2∪V3∪…<br>V+是V的正规闭包：V＋＝V V</em></p><h4 id="3-上下文无关文法"><a href="#3-上下文无关文法" class="headerlink" title="3 上下文无关文法"></a>3 上下文无关文法</h4><p>上下文无关文法G是一个四元组G=(VT，VN，S，P)，其中<br>VT：终结符(Terminal)集合(非空)<br>VN：非终结符(Noterminal)集合(非空)，且VT ∩ VN=Ø<br>S：文法的开始符号，S∈VN<br>P：产生式集合(有限)，每个产生式形式为<br>P→α， P∈VN， α ∈ (VT ∪ VN)*<br>开始符S至少必须在某个产生式的左部出现一次</p><p>例，定义只含+，*的算术表达式的文法<br>  G=&lt; {i，+，*，(，)}，{E}，E， P &gt;， 其中，P由下列产生式组成：<br>E → i<br>E → E+E<br>E → E*E<br>E → (E)  </p><h4 id="4-最左推导、最右推导、语法树"><a href="#4-最左推导、最右推导、语法树" class="headerlink" title="4 最左推导、最右推导、语法树"></a>4 最左推导、最右推导、语法树</h4><p>最左推导：任何一步α⇒β都是对α中的最左非终结符进行替换<br>最右推导：任何一步α⇒β都是对α中的最右非终结符进行替换<br>用一张图表示一个句型的推导,称为语法树</p><h4 id="5-二义性-ambiguity"><a href="#5-二义性-ambiguity" class="headerlink" title="5 二义性(ambiguity)"></a>5 二义性(ambiguity)</h4><p>文法的二义性：如果一个文法存在某个句子对应两棵不同的语法树，则说这个文法是二义的<br>G(E)： E → i|E+E|E*E|(E) 是二义文法<br>语言的二义性：一个语言是二义的，如果对它不存在无二义的文法</p><h4 id="6-不论是程序设计语言还是自然语言，都可能有二义性，也称为歧义。请你针对某个程序语言或者自然语言，例举其中的二义性的例子。"><a href="#6-不论是程序设计语言还是自然语言，都可能有二义性，也称为歧义。请你针对某个程序语言或者自然语言，例举其中的二义性的例子。" class="headerlink" title="6 不论是程序设计语言还是自然语言，都可能有二义性，也称为歧义。请你针对某个程序语言或者自然语言，例举其中的二义性的例子。"></a>6 不论是程序设计语言还是自然语言，都可能有二义性，也称为歧义。请你针对某个程序语言或者自然语言，例举其中的二义性的例子。</h4><p>英语是一种二义性的语言，介词短语较易引起歧义。如“Tom saw Sam at the boat.”既可理解为Sam在船上，也可理解为Tom在船上。</p><p>但中文却不存在这样的歧义，“Tom看到Sam在船上”就是指Sam在船上。如果是Tom在船上就会表示为“Tom在船上看到Sam”。原因是中文附加了一些语法规则，会将介词短语的指代方指向前面的语法成分。因此可以通过增加规则消除二义性。因此在常见的高级程序语言中，较少见到二义性的例子。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统课程学习笔记四-进程管理</title>
      <link href="/2020/02/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
      <url>/2020/02/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="第四章-进程管理"><a href="#第四章-进程管理" class="headerlink" title="第四章 进程管理"></a>第四章 进程管理</h1><h4 id="4-1-进程具有异步性，是进程的优点还是缺点呢？"><a href="#4-1-进程具有异步性，是进程的优点还是缺点呢？" class="headerlink" title="4.1 进程具有异步性，是进程的优点还是缺点呢？"></a>4.1 进程具有异步性，是进程的优点还是缺点呢？</h4><p>是优点。异步可以提高系统运行效率，例如当某进程在加载资源时，可以异步执行，将系统资源让给其他进程。同时，异步运行也不影响进程的同步性，当需要同步执行某些进程时，可以使用进程的消息管理机制控制进程的运行。</p><h4 id="4-2-为何没有“阻塞到运行”或“就绪到阻塞”这样的状态迁移？"><a href="#4-2-为何没有“阻塞到运行”或“就绪到阻塞”这样的状态迁移？" class="headerlink" title="4.2 为何没有“阻塞到运行”或“就绪到阻塞”这样的状态迁移？"></a>4.2 为何没有“阻塞到运行”或“就绪到阻塞”这样的状态迁移？</h4><p>个人的理解是，就绪态的操作相当于一个队列等待。想要运行，在一定的优先级条件下首先要进入队列排队，而排队中的进程直到进入运行状态才能进行进入阻塞态等操作。</p><p>如果有“阻塞到运行”或“就绪到阻塞”的操作，实质上就打破了常规的流程，需要专门写一段代码处理这两种情况，降低系统稳定性。</p><h4 id="4-3-进程控制块中“内部进程通信信息”这一类成员变量的作用是什么？"><a href="#4-3-进程控制块中“内部进程通信信息”这一类成员变量的作用是什么？" class="headerlink" title="4.3 进程控制块中“内部进程通信信息”这一类成员变量的作用是什么？"></a>4.3 进程控制块中“内部进程通信信息”这一类成员变量的作用是什么？</h4><p>不同进程间的交互，数据通信，互斥与同步。</p><h4 id="4-4-列举你知道的WINDOWS中，在程序启动exe程序创建相应进程的方法？"><a href="#4-4-列举你知道的WINDOWS中，在程序启动exe程序创建相应进程的方法？" class="headerlink" title="4.4 列举你知道的WINDOWS中，在程序启动exe程序创建相应进程的方法？"></a>4.4 列举你知道的WINDOWS中，在程序启动exe程序创建相应进程的方法？</h4><p>1、system()</p><p>2、WinExec()</p><p>3、SheelExcute()</p><p>4、CreateProcess()</p><p>CreateProcess()是最底层的创建进程方法，创建进程内核对象，创建虚拟地址空间，装载exe、dll代码和数据到地址空间，创建主线程和线程内核对象，启动主线程并进入main函数。前三种函数是对CreateProcess()的封装简化，system()最简单，直接传入exe文件目录就可以直接开启进程。</p><h4 id="4-5-如何理解fork（）函数的返回值有2个取值？"><a href="#4-5-如何理解fork（）函数的返回值有2个取值？" class="headerlink" title="4.5 如何理解fork（）函数的返回值有2个取值？"></a>4.5 如何理解fork（）函数的返回值有2个取值？</h4><p>fork()会返回pid参数，用于判断是子进程还是父进程。pid=0，是子进程；pid&gt;0,是父进程，且值为子进程ID；pid=-1，出错。</p><h4 id="4-6-画圆和画方两个过程是完全同步的吗？"><a href="#4-6-画圆和画方两个过程是完全同步的吗？" class="headerlink" title="4.6 画圆和画方两个过程是完全同步的吗？"></a>4.6 画圆和画方两个过程是完全同步的吗？</h4><p>不会完全同步，因为首先创建的线程会先执行。要提高同步性，应首先创建好两个进程，然后采用时钟触发的方式同时执行。</p><h4 id="4-7-你有没有可用“线程编程技术”去改造和完善的编程项目？"><a href="#4-7-你有没有可用“线程编程技术”去改造和完善的编程项目？" class="headerlink" title="4.7 你有没有可用“线程编程技术”去改造和完善的编程项目？"></a>4.7 你有没有可用“线程编程技术”去改造和完善的编程项目？</h4><p>有。在前端页面开发中，获取网络资源应采用异步获取的方式，否则当网速较低时，页面会出现卡顿，影响体验效果。因此获取网络资源时应新建一线程获取，不影响页面其他内容的交互。</p><h4 id="4-8-临界区的设置大些好还是小些好？各有什么缺点？"><a href="#4-8-临界区的设置大些好还是小些好？各有什么缺点？" class="headerlink" title="4.8 临界区的设置大些好还是小些好？各有什么缺点？"></a>4.8 临界区的设置大些好还是小些好？各有什么缺点？</h4><p>应在满足访问控制的条件下尽可能小。太大会造成不必要的阻塞。</p><h4 id="4-9-Lock-S-，unLock-S-两个函数能否用于控制多线程之间的临界区访问"><a href="#4-9-Lock-S-，unLock-S-两个函数能否用于控制多线程之间的临界区访问" class="headerlink" title="4.9 Lock(S)，unLock(S)两个函数能否用于控制多线程之间的临界区访问?"></a>4.9 Lock(S)，unLock(S)两个函数能否用于控制多线程之间的临界区访问?</h4><p>可以是可以，但并不是一种好方法，线程间的临界区访问有其他更好的方式来实现。</p><h4 id="4-10-举出生活中类似“司机和售票员”的同步例子，并分析其中的关键操作。"><a href="#4-10-举出生活中类似“司机和售票员”的同步例子，并分析其中的关键操作。" class="headerlink" title="4.10 举出生活中类似“司机和售票员”的同步例子，并分析其中的关键操作。"></a>4.10 举出生活中类似“司机和售票员”的同步例子，并分析其中的关键操作。</h4><p>超市购物结算。收银员将商品全部扫码完毕，出示总金额，客户根据总金额付款，收银员根据客户付款方式执行相应操作，将商品打包交给客户。</p><h4 id="4-11-V操作定义中的q队列里面的进程都是阻塞进程。请问这些进程是从何而来的？或者说这些进程是怎么变成阻塞状态进入q队列的？"><a href="#4-11-V操作定义中的q队列里面的进程都是阻塞进程。请问这些进程是从何而来的？或者说这些进程是怎么变成阻塞状态进入q队列的？" class="headerlink" title="4.11 V操作定义中的q队列里面的进程都是阻塞进程。请问这些进程是从何而来的？或者说这些进程是怎么变成阻塞状态进入q队列的？"></a>4.11 V操作定义中的q队列里面的进程都是阻塞进程。请问这些进程是从何而来的？或者说这些进程是怎么变成阻塞状态进入q队列的？</h4><p>V操作和P操作是成对出现的。只有一种操作是无意义的。V操作中q队列的阻塞进程是P操作转入的。</p><h4 id="4-12-3个进程Pa-Pb-Pc-。临界资源数量为1，CSa-b-c是临界区”中，三个进程并发过程中，是不是一定会发生阻塞或唤醒操作？如果mutex初值设置为0或2会有什么结果？在实际应用中，应该怎么合理的设置互斥量的初值？"><a href="#4-12-3个进程Pa-Pb-Pc-。临界资源数量为1，CSa-b-c是临界区”中，三个进程并发过程中，是不是一定会发生阻塞或唤醒操作？如果mutex初值设置为0或2会有什么结果？在实际应用中，应该怎么合理的设置互斥量的初值？" class="headerlink" title="4.12 3个进程Pa,Pb,Pc 。临界资源数量为1，CSa,b,c是临界区”中，三个进程并发过程中，是不是一定会发生阻塞或唤醒操作？如果mutex初值设置为0或2会有什么结果？在实际应用中，应该怎么合理的设置互斥量的初值？"></a>4.12 3个进程Pa,Pb,Pc 。临界资源数量为1，CSa,b,c是临界区”中，三个进程并发过程中，是不是一定会发生阻塞或唤醒操作？如果mutex初值设置为0或2会有什么结果？在实际应用中，应该怎么合理的设置互斥量的初值？</h4><p>不一定。例如并发过程中，三个进程恰好是分别先后执行PV操作。设置为0的话，所有进程都无法进入临界区；设置为1的话，可以同时有两个进程进入临界区。在实际应用中，根据可最多同时进入临界区的进程个数设置互斥量初值。</p><h4 id="4-13-在4-5-4节“实现进程同步的例子：司机vs售票员”中，如果把两个信号量S1-S2的初值都设置为1，司机和售票员还能否正确同步？如果不能，请给出反例证明。在实际应用中，应该怎么合理的设置信号量的初值？"><a href="#4-13-在4-5-4节“实现进程同步的例子：司机vs售票员”中，如果把两个信号量S1-S2的初值都设置为1，司机和售票员还能否正确同步？如果不能，请给出反例证明。在实际应用中，应该怎么合理的设置信号量的初值？" class="headerlink" title="4.13 在4.5.4节“实现进程同步的例子：司机vs售票员”中，如果把两个信号量S1,S2的初值都设置为1，司机和售票员还能否正确同步？如果不能，请给出反例证明。在实际应用中，应该怎么合理的设置信号量的初值？"></a>4.13 在4.5.4节“实现进程同步的例子：司机vs售票员”中，如果把两个信号量S1,S2的初值都设置为1，司机和售票员还能否正确同步？如果不能，请给出反例证明。在实际应用中，应该怎么合理的设置信号量的初值？</h4><p>不能。因为会出现未关门就起步或未停车就开门的情况。在实际应用中，应根据正确的逻辑关系确定初值。如果是分属两个进程的两个步骤先后执行，应将初值设为0，如果是临界区互斥，应将初值设为1。</p><h4 id="4-14-编者和读者”同步问题在严格意义上讲是一个同步问题还是一个互斥问题？如果把题目的同步要求做一个加强：如果有读者和编者同时在等一个编者“写完”，则当前的“写”操作完后，等待的编者能优先进入。新的情形应当如何完成P-V同步操作？"><a href="#4-14-编者和读者”同步问题在严格意义上讲是一个同步问题还是一个互斥问题？如果把题目的同步要求做一个加强：如果有读者和编者同时在等一个编者“写完”，则当前的“写”操作完后，等待的编者能优先进入。新的情形应当如何完成P-V同步操作？" class="headerlink" title="4.14 编者和读者”同步问题在严格意义上讲是一个同步问题还是一个互斥问题？如果把题目的同步要求做一个加强：如果有读者和编者同时在等一个编者“写完”，则当前的“写”操作完后，等待的编者能优先进入。新的情形应当如何完成P-V同步操作？"></a>4.14 编者和读者”同步问题在严格意义上讲是一个同步问题还是一个互斥问题？如果把题目的同步要求做一个加强：如果有读者和编者同时在等一个编者“写完”，则当前的“写”操作完后，等待的编者能优先进入。新的情形应当如何完成P-V同步操作？</h4><p>写者优先:</p><p>1.写者线程的优先级高于读者线程。</p><p>2.当有写者到来时应该阻塞读者线程的队列。</p><p>3.当有一个写者正在写时或在阻塞队列时应当阻塞读者进程的读操作，直到所有写者进程完成写操作时放开读者进程。</p><p>4.当没有写者进程时读者进程应该能够同时读取文件。</p><p>具体实现:</p><p>1.通过添加信号量read实现写者到来时能够打断读者进程。</p><p>2.设置信号量fileSrc实现读写者对临界资源的访问。</p><p>3.设置计数器writeCount来统计当前阻塞的写者进程的数目，设置信号量writeCountSignal完成对writeCount计数器资源的互斥访问。</p><p>4.设置计数器readCount来统计访问临界资源的读者数目，设置信号量readCountSignal完成对readCount计数器资源的互斥访问。</p><h4 id="4-15-在控制台上直接启动的一个应用程序，其末尾的exit-函数返回参数由谁处理或接收？"><a href="#4-15-在控制台上直接启动的一个应用程序，其末尾的exit-函数返回参数由谁处理或接收？" class="headerlink" title="4.15 在控制台上直接启动的一个应用程序，其末尾的exit( )函数返回参数由谁处理或接收？"></a>4.15 在控制台上直接启动的一个应用程序，其末尾的exit( )函数返回参数由谁处理或接收？</h4><p>应该是init进程。init进程是系统中所有其它用户进程的祖先进程，Linux中的所有进程都是有init进程创建并运行的。首先Linux内核启动，然后在用户空间中启动init进程，再启动其他系统进程。在系统启动完成完成后，init将变为守护进程监视系统其他进程。</p><h4 id="4-16-举出生活中类似“司机和售票员”的同步例子，并分析其中的关键操作。"><a href="#4-16-举出生活中类似“司机和售票员”的同步例子，并分析其中的关键操作。" class="headerlink" title="4.16 举出生活中类似“司机和售票员”的同步例子，并分析其中的关键操作。"></a>4.16 举出生活中类似“司机和售票员”的同步例子，并分析其中的关键操作。</h4><p>个人理解，匿名管道实质上是有主从关系的，用来实现父进程对子进程的控制，因此是由父进程单方面的读写，子进程被动的响应。</p><h4 id="4-17-Linux信号机制与中断机制有什么异同？"><a href="#4-17-Linux信号机制与中断机制有什么异同？" class="headerlink" title="4.17 Linux信号机制与中断机制有什么异同？"></a>4.17 Linux信号机制与中断机制有什么异同？</h4><p>信号和中断的相似点：</p><p>都采用了异步通信的方式，同步就是排队，信息一个接一个的处理，异步就是插队；</p><p>都是暂停当前的, 去执行对应的handle程序；</p><p>都是处理完返回原来位置；</p><p>对于信号和中断, 都是可以屏蔽的。</p><p>信号与中断的区别：</p><p>中断有优先级, 信号没有；</p><p>信号处理程序在用户态下运行的, 中断程序在核心态下运行的；</p><p>中断响应是及时的, 当信号响应一般有延迟。</p><h3 id="单元作业"><a href="#单元作业" class="headerlink" title="单元作业"></a>单元作业</h3><h4 id="1-进程有哪4个特征？"><a href="#1-进程有哪4个特征？" class="headerlink" title="1 进程有哪4个特征？"></a>1 进程有哪4个特征？</h4><p>动态性：进程是程序的一次执行过程，动态产生和消亡；</p><p>并发性：进程同其他进程一起向前推进；</p><p>异步性：进程按各自速度向前推进；</p><p>独立性：进程是系统分配资源和调度CPU的单位。</p><h4 id="2-进程有哪3个基本状态，它们之间如何迁移？"><a href="#2-进程有哪3个基本状态，它们之间如何迁移？" class="headerlink" title="2 进程有哪3个基本状态，它们之间如何迁移？"></a>2 进程有哪3个基本状态，它们之间如何迁移？</h4><p>运行状态：进程已占有CPU，在CPU上运行；</p><p>就绪状态：举报运行条件但由于无CPU，暂时不能运行；</p><p>阻塞状态：因为等待某项服务完成或信号不能运行的状态。</p><p>新建的进程会进入就绪状态，根据进程调度进入运行状态，若有退出信号则进入终止状态，若需等待I/O或事件则进入阻塞状态，若时间片已到则进入就绪状态，组赛状态的进程等到I/O信号或事件信号后进入就绪状态。</p><h4 id="3-什么是进程控制，有哪4个典型的进程控制行为？"><a href="#3-什么是进程控制，有哪4个典型的进程控制行为？" class="headerlink" title="3 什么是进程控制，有哪4个典型的进程控制行为？"></a>3 什么是进程控制，有哪4个典型的进程控制行为？</h4><p>进程控制是指在进程生成全周期内，对其全部行为的控制。</p><p>四个典型控制行为包括：创建进程、阻塞进程、撤销进程和唤醒进行。</p><h4 id="4-什么是原语，有何特点？"><a href="#4-什么是原语，有何特点？" class="headerlink" title="4 什么是原语，有何特点？"></a>4 什么是原语，有何特点？</h4><p>原语是由若干指令构成的具有特定功能的函数。具有原子性，其操作不可分割。</p><h4 id="5-试述fork-函数的作用和特点？"><a href="#5-试述fork-函数的作用和特点？" class="headerlink" title="5 试述fork()函数的作用和特点？"></a>5 试述fork()函数的作用和特点？</h4><p>fork()是一个系统调用，用于创建进程。一个进程调用fork()函数后，系统先给新的进程分配资源，例如存储数据和代码的空间。新进程是当前进程的子进程，子进程是父进程的复制，子进程和父进程并发运行。</p><p>fork()会返回pid参数，用于判断是子进程还是父进程。pid=0，是子进程；pid&gt;0,是父进程，且值为子进程ID；pid=-1，出错。</p><h4 id="6-试述线程的概念（Thread）或特点？"><a href="#6-试述线程的概念（Thread）或特点？" class="headerlink" title="6 试述线程的概念（Thread）或特点？"></a>6 试述线程的概念（Thread）或特点？</h4><p>线程是可由CPU直接运行的实体；一个进程可以创建多个线程；多个线程共享CPU可以实现并发运行。</p><h4 id="7-试述线程有哪些典型应用场合？"><a href="#7-试述线程有哪些典型应用场合？" class="headerlink" title="7 试述线程有哪些典型应用场合？"></a>7 试述线程有哪些典型应用场合？</h4><p>1、程序需要并发运行多个功能；</p><p>2、需要改善窗口交互性的地方，例如用户输入、文件操作、网络操作、搜索等；</p><p>3、需要改善程序结构的地方，后台程序；</p><p>4、多核CPU上的应用，重复发挥多核性能。</p><h4 id="8-何为临界资源，何为临界区？"><a href="#8-何为临界资源，何为临界区？" class="headerlink" title="8 何为临界资源，何为临界区？"></a>8 何为临界资源，何为临界区？</h4><p>临界资源是指一次只允许一个进程独占访问的资源。临界区是指进程中访问临界资源的程序段。</p><h4 id="9-试述设计临界资源或临界区访问机制的四个原则是什么？"><a href="#9-试述设计临界资源或临界区访问机制的四个原则是什么？" class="headerlink" title="9 试述设计临界资源或临界区访问机制的四个原则是什么？"></a>9 试述设计临界资源或临界区访问机制的四个原则是什么？</h4><p>忙则等待、空闲让进、有限等待、让权等待</p><h4 id="10-临界区访问机制为什么要实现让权等待原则？锁机制为什么没有满足该原则？"><a href="#10-临界区访问机制为什么要实现让权等待原则？锁机制为什么没有满足该原则？" class="headerlink" title="10 临界区访问机制为什么要实现让权等待原则？锁机制为什么没有满足该原则？"></a>10 临界区访问机制为什么要实现让权等待原则？锁机制为什么没有满足该原则？</h4><p>让权等待可以让其它进程有机会得到CPU。锁机制阻止了其他进程对临界区资源的使用，且让调用该资源的进程处于阻塞状态，直到该进程调用完临界资源，执行解锁操作。</p><h4 id="11-什么是进程的互斥，什么是进程的同步？各举一个例子说明。"><a href="#11-什么是进程的互斥，什么是进程的同步？各举一个例子说明。" class="headerlink" title="11 什么是进程的互斥，什么是进程的同步？各举一个例子说明。"></a>11 什么是进程的互斥，什么是进程的同步？各举一个例子说明。</h4><p>进程的互斥是指多个进程由于共享了独占性资源，必须协调各进程对资源的存取顺序，确保没有两个或两个以上的进程同时进行存取操作。例如临界资源的使用。</p><p>进程的同步是指若干进程为了完成一个共同的任务，需要相互协调运行步伐，一个进程开始某个操作之前必须要求另一个进程已经完成某个操作，否则前面的进程只能等待。例如司机和售票员之间的操作。</p><h4 id="12-P-V操作的作用是什么？P操作和V操作各自的原理是什么？"><a href="#12-P-V操作的作用是什么？P操作和V操作各自的原理是什么？" class="headerlink" title="12 P-V操作的作用是什么？P操作和V操作各自的原理是什么？"></a>12 P-V操作的作用是什么？P操作和V操作各自的原理是什么？</h4><p>P-V操作为了实现信号灯进程同步机制。信号灯包含S和q两个属性，S表示信号量，q表示PCB队列。进程可以通过P-V操作改变信号灯的状态，同时进程的状态也受信号灯状态的约束。</p><p>P操作将S减1；若差大于等于0，该进程继续；若差小于0，则进程阻塞并加入队列q。</p><p>V操作将S加1；若和大于0，进程继续；若和小于等于0，该进程继续同时从q唤醒一个进程。</p><h4 id="13-试述P-V操作解决互斥问题的思路是什么？"><a href="#13-试述P-V操作解决互斥问题的思路是什么？" class="headerlink" title="13 试述P-V操作解决互斥问题的思路是什么？"></a>13 试述P-V操作解决互斥问题的思路是什么？</h4><p>​1、设定合适的S初值；</p><p>2、进入临界区前执行P操作；</p><p>3、离开临界区之后执行V操作。</p><h4 id="14-试述P-V操作解决同步问题的思路是什么？"><a href="#14-试述P-V操作解决同步问题的思路是什么？" class="headerlink" title="14 试述P-V操作解决同步问题的思路是什么？"></a>14 试述P-V操作解决同步问题的思路是什么？</h4><p>1、​定义有意义的信号量S，并设置合适的初值；</p><p>2、暂停进程时在关键操作前执行P操作；</p><p>3、继续进程时在关键操作后执行V操作。</p><h4 id="15-试分析“司机vs售票员”同步问题中，哪些操作是关键操作，哪些不是？为什么？"><a href="#15-试分析“司机vs售票员”同步问题中，哪些操作是关键操作，哪些不是？为什么？" class="headerlink" title="15 试分析“司机vs售票员”同步问题中，哪些操作是关键操作，哪些不是？为什么？"></a>15 试分析“司机vs售票员”同步问题中，哪些操作是关键操作，哪些不是？为什么？</h4><p>关键操作有关门、起步和停车、开门。行驶和售票不是关键操作。关键操作涉及到与其他进程的交互，非关键操作不涉及其他进程，只需满足进程内的逻辑。</p><h4 id="16-试分析“生产者与消费者”问题中，P-V操作是如何阻止生产者生产速度过快的，又是如何阻止消费者消费速度过快的？又是如何及时唤醒生产者去尽快生产的，又是如何及时唤醒消费者去尽快消费的？"><a href="#16-试分析“生产者与消费者”问题中，P-V操作是如何阻止生产者生产速度过快的，又是如何阻止消费者消费速度过快的？又是如何及时唤醒生产者去尽快生产的，又是如何及时唤醒消费者去尽快消费的？" class="headerlink" title="16 试分析“生产者与消费者”问题中，P-V操作是如何阻止生产者生产速度过快的，又是如何阻止消费者消费速度过快的？又是如何及时唤醒生产者去尽快生产的，又是如何及时唤醒消费者去尽快消费的？"></a>16 试分析“生产者与消费者”问题中，P-V操作是如何阻止生产者生产速度过快的，又是如何阻止消费者消费速度过快的？又是如何及时唤醒生产者去尽快生产的，又是如何及时唤醒消费者去尽快消费的？</h4><p>添加规则，不能向满缓存区存产品，不能从空缓存区取产品，当缓存区已满，生产者处于阻塞态，只有消费者可以运行，当缓存区已空，消费者处于阻塞态，只有生产者可以运行。</p><h4 id="17-试述Windows的信号量（Semaphore）机制的工作原理（或如何应用该机制）？"><a href="#17-试述Windows的信号量（Semaphore）机制的工作原理（或如何应用该机制）？" class="headerlink" title="17 试述Windows的信号量（Semaphore）机制的工作原理（或如何应用该机制）？"></a>17 试述Windows的信号量（Semaphore）机制的工作原理（或如何应用该机制）？</h4><p>信号量允许指定数目的多个线程或进程访问临界区，是一种资源计数器，用于限制并发线程的数量。</p><p>WaitForSingleObject将信号量减1，ReleaseSemaphore将信号量加1，信号量大于0为有信号状态，小于等于0为无信号状态。</p><h4 id="18-试述Linux中wait函数和exit函数的作用和它们之间的联系？"><a href="#18-试述Linux中wait函数和exit函数的作用和它们之间的联系？" class="headerlink" title="18 试述Linux中wait函数和exit函数的作用和它们之间的联系？"></a>18 试述Linux中wait函数和exit函数的作用和它们之间的联系？</h4><p>wait(int status)可以阻塞自己，当有子进程结束，wait收集该子进程信息并销毁该子进程后返回。</p><p>exit(int status)可以终止进程，利用status传递进程结束时的状态，然后变为僵尸状态，保留部分PCB信息供wait收集。</p><h4 id="19-试述Windows管道通信或Linux信号机制的原理（或如何应用该机制）？"><a href="#19-试述Windows管道通信或Linux信号机制的原理（或如何应用该机制）？" class="headerlink" title="19 试述Windows管道通信或Linux信号机制的原理（或如何应用该机制）？"></a>19 试述Windows管道通信或Linux信号机制的原理（或如何应用该机制）？</h4><p>管道是一种用于在进程间共享数据的机制，其实质是一段共享内存。Windows系统为这段共享的内存设计采用数据流I/0的方式来访问。由一个进程读、另一个进程写，类似于一个管道两端，因此这种进程间的通信方式称作“管道”。</p><p>管道分为匿名管道和命名管道：</p><p>匿名管道只能在父子进程间进行通信，不能在网络间通信，而且数据传输是单向的，只能一端写，另一端读，为实现双向通信，需建立两个匿名管道；</p><p>命令管道可以在任意进程间通信，通信是双向的，任意一端都可读可写，但是在同一时间只能有一端读、一端写。</p><p>匿名管道使用方法：</p><p>1、创建一个安全属性描述符，设置句柄可继承</p><p>2、创建两个管道，父读子写和子读父写</p><p>3、重定向输出，将子进程的读写重定向</p><p>4、创建子进程</p><p>5、读写数据给子进程</p><h4 id="20-阅读Linux2-6或更早早期的版本，查看task-struct结构的定义，了解每个成员变量的含义。"><a href="#20-阅读Linux2-6或更早早期的版本，查看task-struct结构的定义，了解每个成员变量的含义。" class="headerlink" title="20 阅读Linux2.6或更早早期的版本，查看task_struct结构的定义，了解每个成员变量的含义。"></a>20 阅读Linux2.6或更早早期的版本，查看task_struct结构的定义，了解每个成员变量的含义。</h4><p>state 进程状态</p><p>pid 进程标识符</p><p>tgid 线程组标识符</p><p>flags 进程标记符</p><p>real_parent 当前执行进程的父进程</p><p>parent 父进程</p><p>children 子进程</p><p>prio 优先级</p><p>mm 地址空间</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>编译原理学习笔记二-高级程序设计语言概述</title>
      <link href="/2020/02/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/"/>
      <url>/2020/02/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-引论"><a href="#第一章-引论" class="headerlink" title="第一章 引论"></a>第一章 引论</h1><h4 id="1-高级程序设计语言的优点"><a href="#1-高级程序设计语言的优点" class="headerlink" title="1 高级程序设计语言的优点"></a>1 高级程序设计语言的优点</h4><p>相对机器语言或汇编语言，高级程序设计语言更接近于数学语言和工程语言，更直观、自然和易于理解，更容易验证其正确性、改错，编写程序的效率更高，更容易移植</p><h4 id="2-程序语言的定义"><a href="#2-程序语言的定义" class="headerlink" title="2 程序语言的定义"></a>2 程序语言的定义</h4><p>语法、语义、语用</p><h4 id="3-语法"><a href="#3-语法" class="headerlink" title="3 语法"></a>3 语法</h4><p>程序本质上是一定字符集上的字符串。语法：一组规则，用它可以形成和产生一个合式(well-formed)的程序。<br>词法规则：单词符号的形成规则，单词符号是语言中具有独立意义的最基本结构，一般包括常数、标识符、基本字、算符、界符等，描述工具为有限自动机。<br>语法规则：语法单位的形成规则，语法单位通常包括表达式、语句、分程序、过程、函数、程序等，描述工具为上下文无关文法。<br>语法规则和词法规则定义了程序的形式结构，定义语法单位的意义属于语义问题。</p><h4 id="4-语义"><a href="#4-语义" class="headerlink" title="4 语义"></a>4 语义</h4><p>语义指一组规则，用它可以定义一个程序的意义，描述方法有自然语言描述和形式描述。</p><p>自然语言描述有二义性、隐藏错误和不完整性，形式描述有操作语义、指称语义、代数语义</p><h4 id="5-高级语言的分类"><a href="#5-高级语言的分类" class="headerlink" title="5 高级语言的分类"></a>5 高级语言的分类</h4><p>强制式语言(Imperative Languge)/过程式语言：命令驱动，面向语句。FORTRAN、C、Pascal，Ada<br>应用式语言(Applicative Language)：注重程序所表示的功能，而不是一个语句接一个语句地执行。LISP、ML<br>基于规则的语言( Rule-based Language)：检查一定的条件，当它满足值，则执行适当的动作、Prolog<br>面向对象语言(Object-Oriented Language)：封装、继承和多态性。Smalltalk，C++，Java </p><h4 id="6-数据类型与操作"><a href="#6-数据类型与操作" class="headerlink" title="6 数据类型与操作"></a>6 数据类型与操作</h4><p>数据类型通常包括三要素：<br>用于区别这种类型数据对象的<strong>属性</strong>；<br>这种类型的数据对象可以具有的<strong>值</strong>；<br>可以作用于这种类型的数据对象的<strong>操作</strong>。</p><h4 id="7-初等数据类型"><a href="#7-初等数据类型" class="headerlink" title="7 初等数据类型"></a>7 初等数据类型</h4><p>数值类型：整型、实型、复数、双精度。运算有+，-，*，/等<br>逻辑类型：true、false。布尔运算有∨，∧，┑等<br>字符类型：符号处理<br>指针类型</p><h4 id="8-名字"><a href="#8-名字" class="headerlink" title="8 名字"></a>8 名字</h4><p>名字的意义和属性：值，单元中的内容；属性，类型和作用域<br>名字的说明方式：由说明语句来明确规定的，如int score；隐含说明，如FORTRAN中以I,J,K,…N为首的名字代表整型，否则为实型；动态确定，走到哪里，是什么，算什么，如Python。</p><h4 id="9-标识符与名字"><a href="#9-标识符与名字" class="headerlink" title="9 标识符与名字"></a>9 标识符与名字</h4><p>标识符是以字母开头的，由字母数字组成的字符串。<br>标识符与名字两者有本质区别，标识符是语法概念，名字有确切的意义和属性。</p><h4 id="10-数据结构"><a href="#10-数据结构" class="headerlink" title="10 数据结构"></a>10 数据结构</h4><p>数组，字符串、表格、栈</p><h4 id="11-抽象数据类型"><a href="#11-抽象数据类型" class="headerlink" title="11 抽象数据类型"></a>11 抽象数据类型</h4><p>抽象数据类型(Abstract Data Type)：一组独立于任何特定实现而精确指定的数据值和相关操作。<br>抽象数据类型由数据集合、及其相关的操作组成，这些操作有明确的定义，而且定义不依赖于具体的实现。</p><p>一个抽象数据类型包括数据对象集合、作用于这些数据对象的抽象运算的集合、这种类型对象的封装。</p><h4 id="12-表达式"><a href="#12-表达式" class="headerlink" title="12 表达式"></a>12 表达式</h4><p>表达式由运算量（也称操作数，即数据引用或函数调用）和算符（运算符，操作符）组成</p><p>形式：中缀、前缀、后缀：X*Y、-A、P↑</p><p>表达式形成规则：变量（包括下标变量）、常数是表达式；若E1、E2为表达式，是一个二元算符，则E1E2是表达式；若E是表达式，为一元算符，则E（或E）是表达式；若E是表达式，则（E）是表达式。</p><h4 id="13-名字的左值和右值"><a href="#13-名字的左值和右值" class="headerlink" title="13 名字的左值和右值"></a>13 名字的左值和右值</h4><p>赋值语句<br>A := B</p><p>名字的左值：该名字代表的存储单元的地址</p><p>名字的右值：该名字代表的存贮单元的内容</p><h4 id="14-语句的分类"><a href="#14-语句的分类" class="headerlink" title="14 语句的分类"></a>14 语句的分类</h4><p>按功能：执行语句，描述程序的动作；说明语句，定义各种不同数据类型的变量或运算，定义名字的性质</p><p>按形式：简单句，不包含其他语句成分的基本句；复合句，句中有句的语句</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>编译原理学习笔记一-引论</title>
      <link href="/2020/02/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80-%E5%BC%95%E8%AE%BA/"/>
      <url>/2020/02/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80-%E5%BC%95%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-引论"><a href="#第一章-引论" class="headerlink" title="第一章 引论"></a>第一章 引论</h1><h4 id="1-翻译程序-Translator-、编译程序-Compiler-、解释程序-Interpreter"><a href="#1-翻译程序-Translator-、编译程序-Compiler-、解释程序-Interpreter" class="headerlink" title="1 翻译程序(Translator)、编译程序(Compiler)、解释程序(Interpreter)"></a>1 翻译程序(Translator)、编译程序(Compiler)、解释程序(Interpreter)</h4><p>翻译程序是把某一种语言程序(称为源语言程序)等价地转换成另一种语言程序(称为目标语言程序)的程序。</p><p>编译程序是把某一种高级语言程序等价地转换成另一种低级语言程序(如汇编语言或机器语言程序)的程序。</p><p>解释程序是把源语言写的源程序作为输入，但不产生目标程序，而是边解释边执行源程序。</p><h4 id="2-编译过程"><a href="#2-编译过程" class="headerlink" title="2 编译过程"></a>2 编译过程</h4><figure class="image-box">                <img src="/2020/02/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80-%E5%BC%95%E8%AE%BA/1.png" alt="词法分析程序自动生成--LEX" title class>                <p>词法分析程序自动生成--LEX</p>            </figure>  <p>词法分析：输入源程序，对构成源程序的字符串进行扫描和分解，识别出单词符号；<br>语法分析：在词法分析的基础上，根据语法规则把单词符号串分解成各类语法单位(语法范畴)；<br>中间代码生成：对各类语法单位按语言的语义进行初步翻译；<br>优化：依据程序的等价变换规则，对前阶段产生的中间代码进行加工变换，以期在最后阶段产生更高效的目标代码；<br>目标代码产生：把中间代码变换成特定机器上的目标代码，目标代码有三种形式，汇编指令代码、绝对指令代码、可重新定位指令代码。</p><h4 id="3-编译程序结构"><a href="#3-编译程序结构" class="headerlink" title="3 编译程序结构"></a>3 编译程序结构</h4><p>包括词法分析器、语法分析器、语义分析与中间代码生成器、优化段、目标代码生成器、符号表管理和出错处理</p><h4 id="4-遍-pass"><a href="#4-遍-pass" class="headerlink" title="4 遍(pass)"></a>4 遍(pass)</h4><p>所谓”遍”， 就是对源程序或源程序的中间表示从头到尾扫描一次.阶段与遍是不同的概念，一遍可以由若干段组成，一个阶段也可以分若干遍来完成</p><h4 id="5-编译前端与后端"><a href="#5-编译前端与后端" class="headerlink" title="5 编译前端与后端"></a>5 编译前端与后端</h4><p>编译前端：与源语言有关，如词法分析，语法分析，语义分析与中间代码产生，与机器无关的优化；<br>编译后端：与目标机有关，与目标机有关的优化，目标代码产生；<br>带来的好处：程序逻辑结构清晰；优化更充分，有利于移植。</p><h3 id="5-编译语言的生成"><a href="#5-编译语言的生成" class="headerlink" title="5 编译语言的生成"></a>5 编译语言的生成</h3><p>以汇编语言和机器语言为工具。<br>优点:  可以针对具体的机器，充分发挥计算机的系统功能；生成的程序效率高<br>缺点:  程序难读、难写、易出错、难维护、生产的效率低</p><p>以高级语言为工具。程序易读、易理解、容易维护、生产的效率高</p><p>自编译方式。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法课程笔记-堆和堆排序</title>
      <link href="/2020/02/12/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%A0%86%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/02/12/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%A0%86%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="堆和堆排序"><a href="#堆和堆排序" class="headerlink" title="堆和堆排序"></a>堆和堆排序</h1><figure class="image-box">                <img src="/2020/02/12/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%A0%86%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F/1.png" alt="三路快速排序" title class>                <p>三路快速排序</p>            </figure>   <p>基本规则：<br>从数组1号位置开始，每个元素的leftChild为2k，rightChild为2k+1。<br>从数组0号位置开始，每个元素的leftChild为2k+1，rightChild为2k+2。</p><h4 id="1-二叉树存取数据的实现"><a href="#1-二叉树存取数据的实现" class="headerlink" title="1 二叉树存取数据的实现"></a>1 二叉树存取数据的实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Item&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxHeap</span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Item *data;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shiftUp</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>( k &gt; <span class="number">1</span> &amp;&amp; data[k/<span class="number">2</span>] &lt; data[k] )&#123;</span><br><span class="line">            swap( data[k/<span class="number">2</span>], data[k] );</span><br><span class="line">            k /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shiftDown</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>( <span class="number">2</span>*k &lt;= count )&#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">2</span>*k; <span class="comment">// 在此轮循环中,data[k]和data[j]交换位置</span></span><br><span class="line">            <span class="keyword">if</span>( j+<span class="number">1</span> &lt;= count &amp;&amp; data[j+<span class="number">1</span>] &gt; data[j] )</span><br><span class="line">                j ++;</span><br><span class="line">            <span class="comment">// data[j] 是 data[2*k]和data[2*k+1]中的最大值</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( data[k] &gt;= data[j] ) <span class="keyword">break</span>;</span><br><span class="line">            swap( data[k] , data[j] );</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数, 构造一个空堆, 可容纳capacity个元素</span></span><br><span class="line">    MaxHeap(<span class="keyword">int</span> capacity)&#123;</span><br><span class="line">        data = <span class="keyword">new</span> Item[capacity+<span class="number">1</span>];</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数, 通过一个给定数组创建一个最大堆</span></span><br><span class="line">    <span class="comment">// 该构造堆的过程, 时间复杂度为O(n)</span></span><br><span class="line">    MaxHeap(Item arr[], <span class="keyword">int</span> n)&#123;</span><br><span class="line">        data = <span class="keyword">new</span> Item[n+<span class="number">1</span>];</span><br><span class="line">        capacity = n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++ )</span><br><span class="line">            data[i+<span class="number">1</span>] = arr[i];</span><br><span class="line">        count = n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = count/<span class="number">2</span> ; i &gt;= <span class="number">1</span> ; i -- )</span><br><span class="line">            shiftDown(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~MaxHeap()&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回堆中的元素个数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个布尔值, 表示堆中是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 像最大堆中插入一个新的元素 item</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Item item)</span></span>&#123;</span><br><span class="line">        assert( count + <span class="number">1</span> &lt;= capacity );</span><br><span class="line">        data[count+<span class="number">1</span>] = item;</span><br><span class="line">        shiftUp(count+<span class="number">1</span>);</span><br><span class="line">        count ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从最大堆中取出堆顶元素, 即堆中所存储的最大数据</span></span><br><span class="line">    <span class="function">Item <span class="title">extractMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">        assert( count &gt; <span class="number">0</span> );</span><br><span class="line">        Item ret = data[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        swap( data[<span class="number">1</span>] , data[count] );</span><br><span class="line">        count --;</span><br><span class="line">        shiftDown(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最大堆中的堆顶元素</span></span><br><span class="line">    <span class="function">Item <span class="title">getMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">        assert( count &gt; <span class="number">0</span> );</span><br><span class="line">        <span class="keyword">return</span> data[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-基础堆排序"><a href="#2-基础堆排序" class="headerlink" title="2 基础堆排序"></a>2 基础堆排序</h4><p>基础堆排序在静态数据中的效率慢于常规排序算法，适用于动态数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// heapSort1, 将所有的元素依次添加到堆中, 在将所有元素从堆中依次取出来, 即完成了排序</span></span><br><span class="line"><span class="comment">// 无论是创建堆的过程, 还是从堆中依次取出元素的过程, 时间复杂度均为O(nlogn)</span></span><br><span class="line"><span class="comment">// 整个堆排序的整体时间复杂度为O(nlogn)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort1</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    MaxHeap&lt;T&gt; maxheap = MaxHeap&lt;T&gt;(n);</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++ )</span><br><span class="line">        maxheap.insert(arr[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = n<span class="number">-1</span> ; i &gt;= <span class="number">0</span> ; i-- )</span><br><span class="line">        arr[i] = maxheap.extractMax();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// heapSort2, 借助我们的heapify过程创建堆，整体添加到堆中</span></span><br><span class="line"><span class="comment">// 此时, 创建堆的过程时间复杂度为O(n), 将所有元素依次从堆中取出来, 实践复杂度为O(nlogn)</span></span><br><span class="line"><span class="comment">// 堆排序的总体时间复杂度依然是O(nlogn), 但是比上述heapSort1性能更优, 因为创建堆的性能更优</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort2</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    MaxHeap&lt;T&gt; maxheap = MaxHeap&lt;T&gt;(arr,n);</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = n<span class="number">-1</span> ; i &gt;= <span class="number">0</span> ; i-- )</span><br><span class="line">        arr[i] = maxheap.extractMax();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-优化堆排序"><a href="#3-优化堆排序" class="headerlink" title="3 优化堆排序"></a>3 优化堆排序</h4><p>原地堆排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原始的shiftDown过程</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> __shiftDown(T arr[], <span class="keyword">int</span> n, <span class="keyword">int</span> k)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>( <span class="number">2</span>*k+<span class="number">1</span> &lt; n )&#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">2</span>*k+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>( j+<span class="number">1</span> &lt; n &amp;&amp; arr[j+<span class="number">1</span>] &gt; arr[j] )</span><br><span class="line">            j += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( arr[k] &gt;= arr[j] )<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        swap( arr[k] , arr[j] );</span><br><span class="line">        k = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化的shiftDown过程, 使用赋值的方式取代不断的swap,</span></span><br><span class="line"><span class="comment">// 该优化思想和我们之前对插入排序进行优化的思路是一致的</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> __shiftDown2(T arr[], <span class="keyword">int</span> n, <span class="keyword">int</span> k)&#123;</span><br><span class="line"></span><br><span class="line">    T e = arr[k];</span><br><span class="line">    <span class="keyword">while</span>( <span class="number">2</span>*k+<span class="number">1</span> &lt; n )&#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">2</span>*k+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>( j+<span class="number">1</span> &lt; n &amp;&amp; arr[j+<span class="number">1</span>] &gt; arr[j] )</span><br><span class="line">            j += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( e &gt;= arr[j] ) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        arr[k] = arr[j];</span><br><span class="line">        k = j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    arr[k] = e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不使用一个额外的最大堆, 直接在原数组上进行原地的堆排序</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意，此时我们的堆是从0开始索引的</span></span><br><span class="line">    <span class="comment">// 从(最后一个元素的索引-1)/2开始</span></span><br><span class="line">    <span class="comment">// 最后一个元素的索引 = n-1</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = (n<span class="number">-1</span><span class="number">-1</span>)/<span class="number">2</span> ; i &gt;= <span class="number">0</span> ; i -- )</span><br><span class="line">        __shiftDown2(arr, n, i);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将顶部数据置于末尾，将树的容量减一，再次排序，也就是extractMax()</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt; <span class="number">0</span> ; i-- )&#123;</span><br><span class="line">        swap( arr[<span class="number">0</span>] , arr[i] );</span><br><span class="line">        __shiftDown2(arr, i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-索引堆"><a href="#4-索引堆" class="headerlink" title="4 索引堆"></a>4 索引堆</h4><figure class="image-box">                <img src="/2020/02/12/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%A0%86%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F/2.png" alt="索引堆" title class>                <p>索引堆</p>            </figure>   <p>对索引进行操作，而不是对值进行操作，可以在打乱顺序后找到数据对应的索引</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SortTestHelper.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大索引堆</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Item&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IndexMaxHeap</span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Item *data;     <span class="comment">// 最大索引堆中的数据</span></span><br><span class="line">    <span class="keyword">int</span> *indexes;   <span class="comment">// 最大索引堆中的索引</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 索引堆中, 数据之间的比较根据data的大小进行比较, 但实际操作的是索引</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shiftUp</span><span class="params">( <span class="keyword">int</span> k )</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( k &gt; <span class="number">1</span> &amp;&amp; data[indexes[k/<span class="number">2</span>]] &lt; data[indexes[k]] )&#123;</span><br><span class="line">            swap( indexes[k/<span class="number">2</span>] , indexes[k] );</span><br><span class="line">            k /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 索引堆中, 数据之间的比较根据data的大小进行比较, 但实际操作的是索引</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shiftDown</span><span class="params">( <span class="keyword">int</span> k )</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( <span class="number">2</span>*k &lt;= count )&#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">2</span>*k;</span><br><span class="line">            <span class="keyword">if</span>( j + <span class="number">1</span> &lt;= count &amp;&amp; data[indexes[j+<span class="number">1</span>]] &gt; data[indexes[j]] )</span><br><span class="line">                j += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( data[indexes[k]] &gt;= data[indexes[j]] )</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            swap( indexes[k] , indexes[j] );</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数, 构造一个空的索引堆, 可容纳capacity个元素</span></span><br><span class="line">    IndexMaxHeap(<span class="keyword">int</span> capacity)&#123;</span><br><span class="line"></span><br><span class="line">        data = <span class="keyword">new</span> Item[capacity+<span class="number">1</span>];</span><br><span class="line">        indexes = <span class="keyword">new</span> <span class="keyword">int</span>[capacity+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~IndexMaxHeap()&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data;</span><br><span class="line">        <span class="keyword">delete</span>[] indexes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回索引堆中的元素个数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个布尔值, 表示索引堆中是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向最大索引堆中插入一个新的元素, 新元素的索引为i, 元素为item</span></span><br><span class="line">    <span class="comment">// 传入的i对用户而言,是从0索引的</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> i, Item item)</span></span>&#123;</span><br><span class="line">        assert( count + <span class="number">1</span> &lt;= capacity );</span><br><span class="line">        assert( i + <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp; i + <span class="number">1</span> &lt;= capacity );</span><br><span class="line"></span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">        data[i] = item;</span><br><span class="line">        indexes[count+<span class="number">1</span>] = i;</span><br><span class="line">        count++;</span><br><span class="line"></span><br><span class="line">        shiftUp(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从最大索引堆中取出堆顶元素, 即索引堆中所存储的最大数据</span></span><br><span class="line">    <span class="function">Item <span class="title">extractMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">        assert( count &gt; <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">        Item ret = data[indexes[<span class="number">1</span>]];</span><br><span class="line">        swap( indexes[<span class="number">1</span>] , indexes[count] );</span><br><span class="line">        count--;</span><br><span class="line">        shiftDown(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从最大索引堆中取出堆顶元素的索引</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">extractMaxIndex</span><span class="params">()</span></span>&#123;</span><br><span class="line">        assert( count &gt; <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret = indexes[<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">        swap( indexes[<span class="number">1</span>] , indexes[count] );</span><br><span class="line">        count--;</span><br><span class="line">        shiftDown(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最大索引堆中的堆顶元素</span></span><br><span class="line">    <span class="function">Item <span class="title">getMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">        assert( count &gt; <span class="number">0</span> );</span><br><span class="line">        <span class="keyword">return</span> data[indexes[<span class="number">1</span>]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最大索引堆中的堆顶元素的索引</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMaxIndex</span><span class="params">()</span></span>&#123;</span><br><span class="line">        assert( count &gt; <span class="number">0</span> );</span><br><span class="line">        <span class="keyword">return</span> indexes[<span class="number">1</span>]<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最大索引堆中索引为i的元素</span></span><br><span class="line">    <span class="function">Item <span class="title">getItem</span><span class="params">( <span class="keyword">int</span> i )</span></span>&#123;</span><br><span class="line">        assert( i + <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp; i + <span class="number">1</span> &lt;= capacity );</span><br><span class="line">        <span class="keyword">return</span> data[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将最大索引堆中索引为i的元素修改为newItem</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">( <span class="keyword">int</span> i , Item newItem )</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">        data[i] = newItem;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到indexes[j] = i, j表示data[i]在堆中的位置</span></span><br><span class="line">        <span class="comment">// 之后shiftUp(j), 再shiftDown(j)</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= count ; j ++ )</span><br><span class="line">            <span class="keyword">if</span>( indexes[j] == i )&#123;</span><br><span class="line">                shiftUp(j);</span><br><span class="line">                shiftDown(j);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试索引堆中的索引数组index</span></span><br><span class="line">    <span class="comment">// 注意:这个测试在向堆中插入元素以后, 不进行extract操作有效</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">testIndexes</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> *copyIndexes = <span class="keyword">new</span> <span class="keyword">int</span>[count+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= count ; i ++ )</span><br><span class="line">            copyIndexes[i] = indexes[i];</span><br><span class="line"></span><br><span class="line">        copyIndexes[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">std</span>::sort(copyIndexes, copyIndexes + count + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在对索引堆中的索引进行排序后, 应该正好是1...count这count个索引</span></span><br><span class="line">        <span class="keyword">bool</span> res = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= count ; i ++ )</span><br><span class="line">            <span class="keyword">if</span>( copyIndexes[i<span class="number">-1</span>] + <span class="number">1</span> != copyIndexes[i] )&#123;</span><br><span class="line">                res = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span>[] copyIndexes;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( !res )&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"Error!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用最大索引堆进行堆排序, 来验证我们的最大索引堆的正确性</span></span><br><span class="line"><span class="comment">// 最大索引堆的主要作用不是用于排序, 我们在这里使用排序只是为了验证我们的最大索引堆实现的正确性</span></span><br><span class="line"><span class="comment">// 在后续的图论中, 无论是最小生成树算法, 还是最短路径算法, 我们都需要使用索引堆进行优化:)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSortUsingIndexMaxHeap</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    IndexMaxHeap&lt;T&gt; indexMaxHeap = IndexMaxHeap&lt;T&gt;(n);</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++ )</span><br><span class="line">        indexMaxHeap.insert( i , arr[i] );</span><br><span class="line">    assert( indexMaxHeap.testIndexes() );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = n<span class="number">-1</span> ; i &gt;= <span class="number">0</span> ; i -- )</span><br><span class="line">        arr[i] = indexMaxHeap.extractMax();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>* arr = SortTestHelper::generateRandomArray(n, <span class="number">0</span>, n);</span><br><span class="line">    SortTestHelper::testSort(<span class="string">"Heap Sort Using Index-Max-Heap"</span>, heapSortUsingIndexMaxHeap, arr, n);</span><br><span class="line">    <span class="keyword">delete</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-优化索引堆"><a href="#5-优化索引堆" class="headerlink" title="5 优化索引堆"></a>5 优化索引堆</h4><figure class="image-box">                <img src="/2020/02/12/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%A0%86%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F/3.png" alt="优化索引堆" title class>                <p>优化索引堆</p>            </figure>   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SortTestHelper.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大索引堆</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Item&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IndexMaxHeap</span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Item *data;     <span class="comment">// 最大索引堆中的数据</span></span><br><span class="line">    <span class="keyword">int</span> *indexes;   <span class="comment">// 最大索引堆中的索引, indexes[x] = i 表示索引i在x的位置</span></span><br><span class="line">    <span class="keyword">int</span> *reverse;   <span class="comment">// 最大索引堆中的反向索引, reverse[i] = x 表示索引i在x的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 索引堆中, 数据之间的比较根据data的大小进行比较, 但实际操作的是索引</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shiftUp</span><span class="params">( <span class="keyword">int</span> k )</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( k &gt; <span class="number">1</span> &amp;&amp; data[indexes[k/<span class="number">2</span>]] &lt; data[indexes[k]] )&#123;</span><br><span class="line">            swap( indexes[k/<span class="number">2</span>] , indexes[k] );</span><br><span class="line">            reverse[indexes[k/<span class="number">2</span>]] = k/<span class="number">2</span>;</span><br><span class="line">            reverse[indexes[k]] = k;</span><br><span class="line">            k /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 索引堆中, 数据之间的比较根据data的大小进行比较, 但实际操作的是索引</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shiftDown</span><span class="params">( <span class="keyword">int</span> k )</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( <span class="number">2</span>*k &lt;= count )&#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">2</span>*k;</span><br><span class="line">            <span class="keyword">if</span>( j + <span class="number">1</span> &lt;= count &amp;&amp; data[indexes[j+<span class="number">1</span>]] &gt; data[indexes[j]] )</span><br><span class="line">                j += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( data[indexes[k]] &gt;= data[indexes[j]] )</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            swap( indexes[k] , indexes[j] );</span><br><span class="line">            reverse[indexes[k]] = k;</span><br><span class="line">            reverse[indexes[j]] = j;</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数, 构造一个空的索引堆, 可容纳capacity个元素</span></span><br><span class="line">    IndexMaxHeap(<span class="keyword">int</span> capacity)&#123;</span><br><span class="line"></span><br><span class="line">        data = <span class="keyword">new</span> Item[capacity+<span class="number">1</span>];</span><br><span class="line">        indexes = <span class="keyword">new</span> <span class="keyword">int</span>[capacity+<span class="number">1</span>];</span><br><span class="line">        reverse = <span class="keyword">new</span> <span class="keyword">int</span>[capacity+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= capacity ; i ++ )</span><br><span class="line">            reverse[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~IndexMaxHeap()&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data;</span><br><span class="line">        <span class="keyword">delete</span>[] indexes;</span><br><span class="line">        <span class="keyword">delete</span>[] reverse;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回索引堆中的元素个数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个布尔值, 表示索引堆中是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向最大索引堆中插入一个新的元素, 新元素的索引为i, 元素为item</span></span><br><span class="line">    <span class="comment">// 传入的i对用户而言,是从0索引的</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> i, Item item)</span></span>&#123;</span><br><span class="line">        assert( count + <span class="number">1</span> &lt;= capacity );</span><br><span class="line">        assert( i + <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp; i + <span class="number">1</span> &lt;= capacity );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再插入一个新元素前,还需要保证索引i所在的位置是没有元素的。</span></span><br><span class="line">        assert( !contain(i) );</span><br><span class="line"></span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">        data[i] = item;</span><br><span class="line">        indexes[count+<span class="number">1</span>] = i;</span><br><span class="line">        reverse[i] = count+<span class="number">1</span>;</span><br><span class="line">        count++;</span><br><span class="line"></span><br><span class="line">        shiftUp(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从最大索引堆中取出堆顶元素, 即索引堆中所存储的最大数据</span></span><br><span class="line">    <span class="function">Item <span class="title">extractMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">        assert( count &gt; <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">        Item ret = data[indexes[<span class="number">1</span>]];</span><br><span class="line">        swap( indexes[<span class="number">1</span>] , indexes[count] );</span><br><span class="line">        reverse[indexes[count]] = <span class="number">0</span>;</span><br><span class="line">        count--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(count)&#123;</span><br><span class="line">            reverse[indexes[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">            shiftDown(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从最大索引堆中取出堆顶元素的索引</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">extractMaxIndex</span><span class="params">()</span></span>&#123;</span><br><span class="line">        assert( count &gt; <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret = indexes[<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">        swap( indexes[<span class="number">1</span>] , indexes[count] );</span><br><span class="line">        reverse[indexes[count]] = <span class="number">0</span>;</span><br><span class="line">        count--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(count) &#123;</span><br><span class="line">            reverse[indexes[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">            shiftDown(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最大索引堆中的堆顶元素</span></span><br><span class="line">    <span class="function">Item <span class="title">getMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">        assert( count &gt; <span class="number">0</span> );</span><br><span class="line">        <span class="keyword">return</span> data[indexes[<span class="number">1</span>]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最大索引堆中的堆顶元素的索引</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMaxIndex</span><span class="params">()</span></span>&#123;</span><br><span class="line">        assert( count &gt; <span class="number">0</span> );</span><br><span class="line">        <span class="keyword">return</span> indexes[<span class="number">1</span>]<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 看索引i所在的位置是否存在元素</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">contain</span><span class="params">( <span class="keyword">int</span> i )</span></span>&#123;</span><br><span class="line">        assert( i + <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp; i + <span class="number">1</span> &lt;= capacity );</span><br><span class="line">        <span class="keyword">return</span> reverse[i+<span class="number">1</span>] != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最大索引堆中索引为i的元素</span></span><br><span class="line">    <span class="function">Item <span class="title">getItem</span><span class="params">( <span class="keyword">int</span> i )</span></span>&#123;</span><br><span class="line">        assert( contain(i) );</span><br><span class="line">        <span class="keyword">return</span> data[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将最大索引堆中索引为i的元素修改为newItem</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">( <span class="keyword">int</span> i , Item newItem )</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        assert( contain(i) );</span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">        data[i] = newItem;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到indexes[j] = i, j表示data[i]在堆中的位置</span></span><br><span class="line">        <span class="comment">// 之后shiftUp(j), 再shiftDown(j)</span></span><br><span class="line"><span class="comment">//        for( int j = 1 ; j &lt;= count ; j ++ )</span></span><br><span class="line"><span class="comment">//            if( indexes[j] == i )&#123;</span></span><br><span class="line"><span class="comment">//                shiftUp(j);</span></span><br><span class="line"><span class="comment">//                shiftDown(j);</span></span><br><span class="line"><span class="comment">//                return;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有了 reverse 之后,</span></span><br><span class="line">        <span class="comment">// 我们可以非常简单的通过reverse直接定位索引i在indexes中的位置</span></span><br><span class="line">        shiftUp( reverse[i] );</span><br><span class="line">        shiftDown( reverse[i] );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试索引堆中的索引数组index和反向数组reverse</span></span><br><span class="line">    <span class="comment">// 注意:这个测试在向堆中插入元素以后, 不进行extract操作有效</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">testIndexesAndReverseIndexes</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> *copyIndexes = <span class="keyword">new</span> <span class="keyword">int</span>[count+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> *copyReverseIndexes = <span class="keyword">new</span> <span class="keyword">int</span>[count+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= count ; i ++ )&#123;</span><br><span class="line">            copyIndexes[i] = indexes[i];</span><br><span class="line">            copyReverseIndexes[i] = reverse[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        copyIndexes[<span class="number">0</span>] = copyReverseIndexes[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">std</span>::sort(copyIndexes, copyIndexes + count + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">std</span>::sort(copyReverseIndexes, copyReverseIndexes + count + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在对索引堆中的索引和反向索引进行排序后,</span></span><br><span class="line">        <span class="comment">// 两个数组都应该正好是1...count这count个索引</span></span><br><span class="line">        <span class="keyword">bool</span> res = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= count ; i ++ )</span><br><span class="line">            <span class="keyword">if</span>( copyIndexes[i<span class="number">-1</span>] + <span class="number">1</span> != copyIndexes[i] ||</span><br><span class="line">                    copyReverseIndexes[i<span class="number">-1</span>] + <span class="number">1</span> != copyReverseIndexes[i] )&#123;</span><br><span class="line">                res = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span>[] copyIndexes;</span><br><span class="line">        <span class="keyword">delete</span>[] copyReverseIndexes;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( !res )&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"Error!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= count ; i ++ )</span><br><span class="line">            <span class="keyword">if</span>( reverse[ indexes[i] ] != i )&#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"Error 2"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用最大索引堆进行堆排序, 来验证我们的最大索引堆的正确性</span></span><br><span class="line"><span class="comment">// 最大索引堆的主要作用不是用于排序, 我们在这里使用排序只是为了验证我们的最大索引堆实现的正确性</span></span><br><span class="line"><span class="comment">// 在后续的图论中, 无论是最小生成树算法, 还是最短路径算法, 我们都需要使用索引堆进行优化:)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSortUsingIndexMaxHeap</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    IndexMaxHeap&lt;T&gt; indexMaxHeap = IndexMaxHeap&lt;T&gt;(n);</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++ )</span><br><span class="line">        indexMaxHeap.insert( i , arr[i] );</span><br><span class="line">    assert( indexMaxHeap.testIndexesAndReverseIndexes() );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = n<span class="number">-1</span> ; i &gt;= <span class="number">0</span> ; i -- )</span><br><span class="line">        arr[i] = indexMaxHeap.extractMax();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>* arr = SortTestHelper::generateRandomArray(n, <span class="number">0</span>, n);</span><br><span class="line">    SortTestHelper::testSort(<span class="string">"Heap Sort Using Index-Max-Heap"</span>, heapSortUsingIndexMaxHeap, arr, n);</span><br><span class="line">    <span class="keyword">delete</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法课程笔记-排序算法</title>
      <link href="/2020/02/12/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2020/02/12/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h4 id="1-O-n-2"><a href="#1-O-n-2" class="headerlink" title="1 O(n)2"></a>1 O(n)2</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++)&#123;</span><br><span class="line">    <span class="comment">// 寻找[i, n)区间里的最小值</span></span><br><span class="line">    <span class="keyword">int</span> minIndex = i;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> j = i + <span class="number">1</span> ; j &lt; n ; j ++ )</span><br><span class="line">        <span class="keyword">if</span>( arr[j] &lt; arr[minIndex] )</span><br><span class="line">            minIndex = j;</span><br><span class="line"></span><br><span class="line">    swap( arr[i] , arr[minIndex] );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-插入排序"><a href="#2-插入排序" class="headerlink" title="2 插入排序"></a>2 插入排序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; i ++ ) &#123;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">// 寻找元素arr[i]合适的插入位置</span></span><br><span class="line">     <span class="comment">// 写法1</span></span><br><span class="line">     <span class="keyword">for</span>( <span class="keyword">int</span> j = i ; j &gt; <span class="number">0</span> ; j-- )</span><br><span class="line">         <span class="keyword">if</span>( arr[j] &lt; arr[j<span class="number">-1</span>] )</span><br><span class="line">             swap( arr[j] , arr[j<span class="number">-1</span>] );</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">// 写法2</span></span><br><span class="line">     <span class="keyword">for</span>( <span class="keyword">int</span> j = i ; j &gt; <span class="number">0</span> &amp;&amp; arr[j] &lt; arr[j<span class="number">-1</span>] ; j -- )</span><br><span class="line">         swap( arr[j] , arr[j<span class="number">-1</span>] );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-插入排序优化"><a href="#3-插入排序优化" class="headerlink" title="3 插入排序优化"></a>3 插入排序优化</h4><p>swap交换需要赋值三次，可以改进。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++)&#123;</span><br><span class="line">    T e = arr[i];</span><br><span class="line">    <span class="keyword">int</span> j; <span class="comment">// j保存元素e应该插入的位置</span></span><br><span class="line">    <span class="keyword">for</span> (j = i; j &gt; <span class="number">0</span> &amp;&amp; arr[j<span class="number">-1</span>] &gt; e; j--)</span><br><span class="line">        arr[j] = arr[j<span class="number">-1</span>];</span><br><span class="line">    arr[j] = e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-冒泡排序"><a href="#4-冒泡排序" class="headerlink" title="4 冒泡排序"></a>4 冒泡排序</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">bool swapped;</span><br><span class="line"></span><br><span class="line">    do&#123;</span><br><span class="line">        swapped &#x3D; false;</span><br><span class="line">        for( int i &#x3D; 1 ; i &lt; n ; i ++ )</span><br><span class="line">            if( arr[i-1] &gt; arr[i] )&#123;</span><br><span class="line">                swap( arr[i-1] , arr[i] );</span><br><span class="line">                swapped &#x3D; true;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 优化, 每一趟Bubble Sort都将最大的元素放在了最后的位置</span><br><span class="line">        &#x2F;&#x2F; 所以下一次排序, 最后的元素可以不再考虑</span><br><span class="line">        n --;</span><br><span class="line"></span><br><span class="line">    &#125;while(swapped);</span><br></pre></td></tr></table></figure><h4 id="5-希尔排序"><a href="#5-希尔排序" class="headerlink" title="5 希尔排序"></a>5 希尔排序</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 计算 increment sequence: 1, 4, 13, 40, 121, 364, 1093...</span><br><span class="line">    int h &#x3D; 1;</span><br><span class="line">    while( h &lt; n&#x2F;3 )</span><br><span class="line">        h &#x3D; 3 * h + 1;</span><br><span class="line"></span><br><span class="line">    while( h &gt;&#x3D; 1 )&#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; h-sort the array</span><br><span class="line">        for( int i &#x3D; h ; i &lt; n ; i ++ )&#123;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 对 arr[i], arr[i-h], arr[i-2*h], arr[i-3*h]... 使用插入排序</span><br><span class="line">            T e &#x3D; arr[i];</span><br><span class="line">            int j;</span><br><span class="line">            for( j &#x3D; i ; j &gt;&#x3D; h &amp;&amp; e &lt; arr[j-h] ; j -&#x3D; h )</span><br><span class="line">                arr[j] &#x3D; arr[j-h];</span><br><span class="line">            arr[j] &#x3D; e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        h &#x2F;&#x3D; 3;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="6-归并排序"><a href="#6-归并排序" class="headerlink" title="6 归并排序"></a>6 归并排序</h4><p>数组分成两半进行排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __merge(T arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> mid, <span class="keyword">int</span> r)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//* VS不支持动态长度数组, 即不能使用 T aux[r-l+1]的方式申请aux的空间</span></span><br><span class="line">    <span class="comment">//* 使用VS的同学, 请使用new的方式申请aux空间</span></span><br><span class="line">    <span class="comment">//* 使用new申请空间, 不要忘了在__merge函数的最后, delete掉申请的空间:)</span></span><br><span class="line">    T aux[r-l+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//T *aux = new T[r-l+1];</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = l ; i &lt;= r; i ++ )</span><br><span class="line">        aux[i-l] = arr[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化，i指向左半部分的起始索引位置l；j指向右半部分起始索引位置mid+1</span></span><br><span class="line">    <span class="keyword">int</span> i = l, j = mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> k = l ; k &lt;= r; k ++ )&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( i &gt; mid )&#123;  <span class="comment">// 如果左半部分元素已经全部处理完毕</span></span><br><span class="line">            arr[k] = aux[j-l]; j ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( j &gt; r )&#123;  <span class="comment">// 如果右半部分元素已经全部处理完毕</span></span><br><span class="line">            arr[k] = aux[i-l]; i ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( aux[i-l] &lt; aux[j-l] ) &#123;  <span class="comment">// 左半部分所指元素 &lt; 右半部分所指元素</span></span><br><span class="line">            arr[k] = aux[i-l]; i ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;  <span class="comment">// 左半部分所指元素 &gt;= 右半部分所指元素</span></span><br><span class="line">            arr[k] = aux[j-l]; j ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//delete[] aux;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归使用归并排序,对arr[l...r]的范围进行排序</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> __mergeSort(T arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)&#123;</span><br><span class="line">    <span class="comment">//判断数组合法性</span></span><br><span class="line">    <span class="keyword">if</span>( l &gt;= r )</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">    __mergeSort(arr, l, mid);</span><br><span class="line">    __mergeSort(arr, mid+<span class="number">1</span>, r);</span><br><span class="line">    __merge(arr, l, mid, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    __mergeSort( arr , <span class="number">0</span> , n<span class="number">-1</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-归并排序优化"><a href="#7-归并排序优化" class="headerlink" title="7 归并排序优化"></a>7 归并排序优化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> __mergeSort2(T arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 优化2: 对于小规模数组, 使用插入排序</span></span><br><span class="line">    <span class="keyword">if</span>( r - l &lt;= <span class="number">15</span> )&#123;</span><br><span class="line">        insertionSort(arr, l, r);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">    __mergeSort2(arr, l, mid);</span><br><span class="line">    __mergeSort2(arr, mid+<span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 优化1: 对于arr[mid] &lt;= arr[mid+1]的情况,即完全有序，不进行merge</span></span><br><span class="line">    <span class="comment">// 对于近乎有序的数组非常有效,但是对于一般情况,有一定的性能损失</span></span><br><span class="line">    <span class="keyword">if</span>( arr[mid] &gt; arr[mid+<span class="number">1</span>] )</span><br><span class="line">        __merge(arr, l, mid, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort2</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    __mergeSort2( arr , <span class="number">0</span> , n<span class="number">-1</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-自底向上归并排序"><a href="#8-自底向上归并排序" class="headerlink" title="8 自底向上归并排序"></a>8 自底向上归并排序</h4><p>变递归为迭代，而且可用于链表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSortBU</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Merge Sort Bottom Up 无优化版本</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> sz = <span class="number">1</span>; sz &lt; n ; sz += sz )</span><br><span class="line">        <span class="comment">//保证i+sz&lt;n</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n - sz ; i += sz+sz )</span><br><span class="line">            <span class="comment">// 对 arr[i...i+sz-1] 和 arr[i+sz...i+2*sz-1] 进行归并</span></span><br><span class="line">            __merge(arr, i, i+sz<span class="number">-1</span>, <span class="built_in">min</span>(i+sz+sz<span class="number">-1</span>,n<span class="number">-1</span>) );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Merge Sort Bottom Up 优化</span></span><br><span class="line">    <span class="comment">// 对于小数组, 使用插入排序优化</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i += <span class="number">16</span> )</span><br><span class="line">        insertionSort(arr,i,<span class="built_in">min</span>(i+<span class="number">15</span>,n<span class="number">-1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> sz = <span class="number">16</span>; sz &lt; n ; sz += sz )</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n - sz ; i += sz+sz )</span><br><span class="line">            <span class="comment">// 对于arr[mid] &lt;= arr[mid+1]的情况,不进行merge</span></span><br><span class="line">            <span class="keyword">if</span>( arr[i+sz<span class="number">-1</span>] &gt; arr[i+sz] )</span><br><span class="line">                __merge(arr, i, i+sz<span class="number">-1</span>, <span class="built_in">min</span>(i+sz+sz<span class="number">-1</span>,n<span class="number">-1</span>) );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Merge Sort BU 也是一个O(nlogn)复杂度的算法，虽然只使用两重for循环</span></span><br><span class="line">    <span class="comment">// 所以，Merge Sort BU也可以在1秒之内轻松处理100万数量级的数据</span></span><br><span class="line">    <span class="comment">// 注意：不要轻易根据循环层数来判断算法的复杂度，Merge Sort BU就是一个反例</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较Merge Sort和Merge Sort Bottom Up两种排序算法的性能效率</span></span><br><span class="line"><span class="comment">// 整体而言, 两种算法的效率是差不多的。但是如果进行仔细测试, 自底向上的归并排序会略胜一筹。</span></span><br></pre></td></tr></table></figure><h4 id="9-快速排序"><a href="#9-快速排序" class="headerlink" title="9 快速排序"></a>9 快速排序</h4><p>将第一个元素作为标记点，找到该标记的正确位置，之前的元素小于标记元素，之后的元素大于标记元素。</p><figure class="image-box">                <img src="/2020/02/12/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/1.png" alt="快速排序" title class>                <p>快速排序</p>            </figure> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __partition(T arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)&#123;</span><br><span class="line"></span><br><span class="line">    T v = arr[l];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> j = l; <span class="comment">// arr[l+1...j] &lt; v ; arr[j+1...i) &gt; v</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = l + <span class="number">1</span> ; i &lt;= r ; i ++ )</span><br><span class="line">        <span class="keyword">if</span>( arr[i] &lt; v )&#123;</span><br><span class="line">            j ++;</span><br><span class="line">            swap( arr[j] , arr[i] );</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//最后将v放入正确位置</span></span><br><span class="line">    swap( arr[l] , arr[j]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对arr[l...r]部分进行快速排序</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> __quickSort(T arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( l &gt;= r )</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> p = __partition(arr, l, r);</span><br><span class="line">    __quickSort(arr, l, p<span class="number">-1</span> );</span><br><span class="line">    __quickSort(arr, p+<span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    __quickSort(arr, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较Merge Sort和Quick Sort两种排序算法的性能效率</span></span><br><span class="line"><span class="comment">// 两种排序算法虽然都是O(nlogn)级别的, 但是Quick Sort算法有常数级的优势</span></span><br><span class="line"><span class="comment">// Quick Sort要比Merge Sort快, 即使我们对Merge Sort进行了优化</span></span><br></pre></td></tr></table></figure><h4 id="10-随机化快速排序"><a href="#10-随机化快速排序" class="headerlink" title="10 随机化快速排序"></a>10 随机化快速排序</h4><p>随机选择标定点，改善近似顺序列表排序性能</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对arr[l...r]部分进行partition操作</span></span><br><span class="line"><span class="comment">// 返回p, 使得arr[l...p-1] &lt; arr[p] ; arr[p+1...r] &gt; arr[p]</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> _partition(T arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 随机在arr[l...r]的范围中, 选择一个数值作为标定点pivot</span></span><br><span class="line">    swap( arr[l] , arr[rand()%(r-l+<span class="number">1</span>)+l] );</span><br><span class="line"></span><br><span class="line">    T v = arr[l];</span><br><span class="line">    <span class="keyword">int</span> j = l;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = l + <span class="number">1</span> ; i &lt;= r ; i ++ )</span><br><span class="line">        <span class="keyword">if</span>( arr[i] &lt; v )&#123;</span><br><span class="line">            j ++;</span><br><span class="line">            swap( arr[j] , arr[i] );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    swap( arr[l] , arr[j]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对arr[l...r]部分进行快速排序</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> _quickSort(T arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于小规模数组, 使用插入排序进行优化</span></span><br><span class="line">    <span class="keyword">if</span>( r - l &lt;= <span class="number">15</span> )&#123;</span><br><span class="line">        insertionSort(arr,l,r);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> p = _partition(arr, l, r);</span><br><span class="line">    _quickSort(arr, l, p<span class="number">-1</span> );</span><br><span class="line">    _quickSort(arr, p+<span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    _quickSort(arr, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11-双路快速排序"><a href="#11-双路快速排序" class="headerlink" title="11 双路快速排序"></a>11 双路快速排序</h4><p>从两头向中间执行partition，使等于v的元素分散在两边，使两部分尽量平衡，适用于大量重复数据的场合</p><figure class="image-box">                <img src="/2020/02/12/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/2.png" alt="双路快速排序" title class>                <p>双路快速排序</p>            </figure> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双路快速排序的partition</span></span><br><span class="line"><span class="comment">// 返回p, 使得arr[l...p-1] &lt;= arr[p] ; arr[p+1...r] &gt;= arr[p]</span></span><br><span class="line"><span class="comment">// 双路快排处理的元素正好等于arr[p]的时候要注意，详见下面的注释：）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> _partition2(T arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 随机在arr[l...r]的范围中, 选择一个数值作为标定点pivot</span></span><br><span class="line">    swap( arr[l] , arr[rand()%(r-l+<span class="number">1</span>)+l] );</span><br><span class="line">    T v = arr[l];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// arr[l+1...i) &lt;= v; arr(j...r] &gt;= v</span></span><br><span class="line">    <span class="keyword">int</span> i = l+<span class="number">1</span>, j = r;</span><br><span class="line">    <span class="keyword">while</span>( <span class="literal">true</span> )&#123;</span><br><span class="line">        <span class="comment">// 注意这里的边界, arr[i] &lt; v, 不能是arr[i] &lt;= v</span></span><br><span class="line">        <span class="keyword">while</span>( i &lt;= r &amp;&amp; arr[i] &lt; v )</span><br><span class="line">            i ++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意这里的边界, arr[j] &gt; v, 不能是arr[j] &gt;= v</span></span><br><span class="line">        <span class="keyword">while</span>( j &gt;= l+<span class="number">1</span> &amp;&amp; arr[j] &gt; v )</span><br><span class="line">            j --;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 多了个等号的判断会造成两棵子树不平衡</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( i &gt; j )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        swap( arr[i] , arr[j] );</span><br><span class="line">        i ++;</span><br><span class="line">        j --;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    swap( arr[l] , arr[j]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对arr[l...r]部分进行快速排序</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> _quickSort(T arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于小规模数组, 使用插入排序进行优化</span></span><br><span class="line">    <span class="keyword">if</span>( r - l &lt;= <span class="number">15</span> )&#123;</span><br><span class="line">        insertionSort(arr,l,r);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用双路快速排序的partition</span></span><br><span class="line">    <span class="keyword">int</span> p = _partition2(arr, l, r);</span><br><span class="line">    _quickSort(arr, l, p<span class="number">-1</span> );</span><br><span class="line">    _quickSort(arr, p+<span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    _quickSort(arr, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="12-三路快速排序"><a href="#12-三路快速排序" class="headerlink" title="12 三路快速排序"></a>12 三路快速排序</h4><figure class="image-box">                <img src="/2020/02/12/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/3.png" alt="三路快速排序" title class>                <p>三路快速排序</p>            </figure> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归的三路快速排序算法</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> __quickSort3Ways(T arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于小规模数组, 使用插入排序进行优化</span></span><br><span class="line">    <span class="keyword">if</span>( r - l &lt;= <span class="number">15</span> )&#123;</span><br><span class="line">        insertionSort(arr,l,r);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 随机在arr[l...r]的范围中, 选择一个数值作为标定点pivot</span></span><br><span class="line">    swap( arr[l], arr[rand()%(r-l+<span class="number">1</span>)+l ] );</span><br><span class="line"></span><br><span class="line">    T v = arr[l];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> lt = l;     <span class="comment">// arr[l+1...lt] &lt; v</span></span><br><span class="line">    <span class="keyword">int</span> gt = r + <span class="number">1</span>; <span class="comment">// arr[gt...r] &gt; v</span></span><br><span class="line">    <span class="keyword">int</span> i = l+<span class="number">1</span>;    <span class="comment">// arr[lt+1...i) == v</span></span><br><span class="line">    <span class="keyword">while</span>( i &lt; gt )&#123;</span><br><span class="line">        <span class="keyword">if</span>( arr[i] &lt; v )&#123;</span><br><span class="line">            swap( arr[i], arr[lt+<span class="number">1</span>]);</span><br><span class="line">            i ++;</span><br><span class="line">            lt ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( arr[i] &gt; v )&#123;</span><br><span class="line">            swap( arr[i], arr[gt<span class="number">-1</span>]);</span><br><span class="line">            gt --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123; <span class="comment">// arr[i] == v</span></span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    swap( arr[l] , arr[lt] );</span><br><span class="line"></span><br><span class="line">    __quickSort3Ways(arr, l, lt<span class="number">-1</span>);</span><br><span class="line">    __quickSort3Ways(arr, gt, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort3Ways</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    __quickSort3Ways( arr, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较Merge Sort和双路快速排序和三路快排三种排序算法的性能效率</span></span><br><span class="line"><span class="comment">// 对于包含有大量重复数据的数组, 三路快排有巨大的优势</span></span><br><span class="line"><span class="comment">// 对于一般性的随机数组和近乎有序的数组, 三路快排的效率虽然不是最优的, 但是是在非常可以接受的范围里</span></span><br><span class="line"><span class="comment">// 因此, 在一些语言中, 三路快排是默认的语言库函数中使用的排序算法。比如Java:)</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统课程学习笔记三-操作系统用户界面</title>
      <link href="/2020/02/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2/"/>
      <url>/2020/02/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="第三章-操作系统用户界面"><a href="#第三章-操作系统用户界面" class="headerlink" title="第三章 操作系统用户界面"></a>第三章 操作系统用户界面</h1><h4 id="3-1-BIOS中断是INT-XXh的形式，例如INT-13H是磁盘读写服务。那么INT-21H与这些BIOS中断的机制是不是一样的呢？"><a href="#3-1-BIOS中断是INT-XXh的形式，例如INT-13H是磁盘读写服务。那么INT-21H与这些BIOS中断的机制是不是一样的呢？" class="headerlink" title="3.1 BIOS中断是INT XXh的形式，例如INT 13H是磁盘读写服务。那么INT 21H与这些BIOS中断的机制是不是一样的呢？"></a>3.1 BIOS中断是INT XXh的形式，例如INT 13H是磁盘读写服务。那么INT 21H与这些BIOS中断的机制是不是一样的呢？</h4><p>机制一样，但实现方法有区别。二者都是中断，过程表现为识别中断源、保护断点和现场、装入中断服务程序的入口地址、进入中断服务程序、结束中断程序后恢复现场和断点、中断返回。但BIOS中断由硬件电路实现，INT 21H由软件程序指令实现。</p><h4 id="3-2-操作系统的初始引导过程涉及哪些程序模块，各自存放的介质是什么，存放的形式是什么？"><a href="#3-2-操作系统的初始引导过程涉及哪些程序模块，各自存放的介质是什么，存放的形式是什么？" class="headerlink" title="3.2 操作系统的初始引导过程涉及哪些程序模块，各自存放的介质是什么，存放的形式是什么？"></a>3.2 操作系统的初始引导过程涉及哪些程序模块，各自存放的介质是什么，存放的形式是什么？</h4><p>操作系统初始引导是指通过引导程序把操作系统核心装入内存并使之接管计算机系统的过程。首先BIOS读取MRB引导程序到内存运行，MRB的引导程序根据BIOS提供的参数读取硬盘指定位置的文件到内存，该文件加载指定操作系统的内核并初始化基本参数，操作系统内核逐步加载剩余操作系统程序，最后完全控制计算机。</p><h4 id="3-3-比较DOS、Windows7与Linux早期版本都有哪些典型的操作界面？操作界面对普通用户（办公或娱乐）选择操作系统有何影响？"><a href="#3-3-比较DOS、Windows7与Linux早期版本都有哪些典型的操作界面？操作界面对普通用户（办公或娱乐）选择操作系统有何影响？" class="headerlink" title="3.3 比较DOS、Windows7与Linux早期版本都有哪些典型的操作界面？操作界面对普通用户（办公或娱乐）选择操作系统有何影响？"></a>3.3 比较DOS、Windows7与Linux早期版本都有哪些典型的操作界面？操作界面对普通用户（办公或娱乐）选择操作系统有何影响？</h4><p>主要有GUI界面（win7）和命令行（DOS、Linux）两种。GUI界面更易被初学者或普通用户接受，操作简单并且可以浏览使用各种图形数据，命令行界面的操作需要学会使用指令，入门成本高，且难以处理复杂图像应用。</p><h4 id="3-4-Linux的Shell能否看成操作系统的内核功能？如何理解Shell与内核之间的交互？"><a href="#3-4-Linux的Shell能否看成操作系统的内核功能？如何理解Shell与内核之间的交互？" class="headerlink" title="3.4 Linux的Shell能否看成操作系统的内核功能？如何理解Shell与内核之间的交互？"></a>3.4 Linux的Shell能否看成操作系统的内核功能？如何理解Shell与内核之间的交互？</h4><p>不能。Shell可以看作是用户和操作系统信息交互的中间桥梁。用户用过Shell将命令下达给操作系统，操作系统通过Shell将需要展示给用户的信息返回，Shell本身不执行命令，仅仅是组织和管理命令。</p><h4 id="3-5-printf，open都是Linux中典型的隐式系统调用。当我们在“为Linux内核增加新的系统调用实验”中增加一个新的系统调用后，我们在应用程序中是如何调用的它们的？为何我们不能像printf，open等函数一样简单地调用？"><a href="#3-5-printf，open都是Linux中典型的隐式系统调用。当我们在“为Linux内核增加新的系统调用实验”中增加一个新的系统调用后，我们在应用程序中是如何调用的它们的？为何我们不能像printf，open等函数一样简单地调用？" class="headerlink" title="3.5 printf，open都是Linux中典型的隐式系统调用。当我们在“为Linux内核增加新的系统调用实验”中增加一个新的系统调用后，我们在应用程序中是如何调用的它们的？为何我们不能像printf，open等函数一样简单地调用？"></a>3.5 printf，open都是Linux中典型的隐式系统调用。当我们在“为Linux内核增加新的系统调用实验”中增加一个新的系统调用后，我们在应用程序中是如何调用的它们的？为何我们不能像printf，open等函数一样简单地调用？</h4><p>不能。printf和open是高级语言的API接口，Linux中隐式系统调用也会在编译时转化为显式的系统调用，最终用到INT80h。我们在自己制作的操作系统中加入的自定义系统调用，并没有现成的高级语言API接口供我们使用，可以通过汇编语言调用INT80端口使用或封装成高级语言API接口直接调用。</p><h3 id="单元作业"><a href="#单元作业" class="headerlink" title="单元作业"></a>单元作业</h3><h4 id="1-系统BIOS的功能有哪些？"><a href="#1-系统BIOS的功能有哪些？" class="headerlink" title="1 系统BIOS的功能有哪些？"></a>1 系统BIOS的功能有哪些？</h4><p>BIOS全程Basic I/O System，是一种固件（Firmware），是以硬件形式储存的软件，储存主板启动配置信息、基本设备I/O服务，完成系统的加电自检、初始化基本硬件。</p><h4 id="2-计算机加电后执行的第一条指令存放在哪里，有什么特点？"><a href="#2-计算机加电后执行的第一条指令存放在哪里，有什么特点？" class="headerlink" title="2 计算机加电后执行的第一条指令存放在哪里，有什么特点？"></a>2 计算机加电后执行的第一条指令存放在哪里，有什么特点？</h4><p>BIOS的指令位置位于F0000-FFFFF处，按下开机或重启键后执行的第一条指令位于FFFFQ处，执行JUMP POST（加电自检）动作，POST位于BIOS内部，该指令由硬件电路实现，功能是初始化基本硬件，若自检错误通过喇叭或数显二极管的方式提示。</p><h4 id="3-何为操作系统的生成？简述Linux内核的生成过程。"><a href="#3-何为操作系统的生成？简述Linux内核的生成过程。" class="headerlink" title="3 何为操作系统的生成？简述Linux内核的生成过程。"></a>3 何为操作系统的生成？简述Linux内核的生成过程。</h4><p>​操作系统的生成是指满足特定硬件环境和用户需要，组装和构建操作系统的过程。<br>Linux操作系统的生成过程如下：</p><p>1、获取Linux内核的源代码</p><p>2、选择和启动内核配置程序</p><p>3、根据需要配置内核模块的参数</p><p>4、程序编译新的内核</p><p>5、编译和安装模块</p><p>6、启动新内核</p><h4 id="4-何为用户界面？有哪些类别？各有什么特点？"><a href="#4-何为用户界面？有哪些类别？各有什么特点？" class="headerlink" title="4 何为用户界面？有哪些类别？各有什么特点？"></a>4 何为用户界面？有哪些类别？各有什么特点？</h4><p>用户界面是指操作系统提供给用户控制计算机的机制，又称用户接口。分为操作界面和系统调用。</p><p>操作界面通过GUI或控制台接受普通命令、批处理程序或Shell指令，一般不涉及核心资源或硬件操作。</p><p>系统调用需要操作系统内核为应用程序提供服务或函数，CPU运行于核态，调用过程会产生自愿中断。</p><h4 id="5-何为shell？有哪4类典型的shell？"><a href="#5-何为shell？有哪4类典型的shell？" class="headerlink" title="5 何为shell？有哪4类典型的shell？"></a>5 何为shell？有哪4类典型的shell？</h4><p>Shell可以看作是用户和操作系统信息交互的中间桥梁。用户用过Shell将命令下达给操作系统，操作系统通过Shell将需要展示给用户的信息返回，Shell本身不执行命令，仅仅是组织和管理命令。</p><p>Shell有Bsh、Csh、Ksh、Bash四种，前三种是早期版本，各有优缺点，Bsh有较强编程功能，Csh交互方便，Ksh结合Bsh和Csh优势，Bash是Bsh的升级并且吸收了Ksh的特性。</p><h4 id="6-何为输出重定向？举一个Linux或Windows中的重定向的应用命令或例子。"><a href="#6-何为输出重定向？举一个Linux或Windows中的重定向的应用命令或例子。" class="headerlink" title="6 何为输出重定向？举一个Linux或Windows中的重定向的应用命令或例子。"></a>6 何为输出重定向？举一个Linux或Windows中的重定向的应用命令或例子。</h4><p>输出重定向是指将命令输出由默认的显示器更改为指定的文件。</p><p>在Linux命令行中输入<code>ls /etc/ &gt; etcdir.log</code>，可以将原本会在命令行中显示的etc目录信息储存在当前目录下的etcdir.log文件中。</p><h4 id="7-试述运行shell脚本程序的三种方式？"><a href="#7-试述运行shell脚本程序的三种方式？" class="headerlink" title="7 试述运行shell脚本程序的三种方式？"></a>7 试述运行shell脚本程序的三种方式？</h4><p>第一种是直接运行，用缺省版本的Shell运行程序；</p><p>第二种是使用特定版本，在运行程序时输入Shell版本+程序名可以使用特定版本，如bash my_script 。</p><p>第三种是在脚本文件首行指定。在脚本开头加一行：#!/bin/bush 。</p><h4 id="8-系统调用与普通用户态函数比较，有何异同点？"><a href="#8-系统调用与普通用户态函数比较，有何异同点？" class="headerlink" title="8 系统调用与普通用户态函数比较，有何异同点？"></a>8 系统调用与普通用户态函数比较，有何异同点？</h4><p>系统调用一般设计核心资源或硬件的操作，CPU运行于核态，每个系统调用具有唯一ID，调用过程会产生自愿中断，实现过程较复杂。相同点是都属于用户接口，实现用户对计算机的控制。</p><h4 id="9-何为隐式系统调用？"><a href="#9-何为隐式系统调用？" class="headerlink" title="9 何为隐式系统调用？"></a>9 何为隐式系统调用？</h4><p>隐式调用是指通过高级语言的API接口在编译时转化为显式的系统调用，最终用到特定的中断执行系统调用指令。使用隐式系统调用可以快捷方便的使用计算的机某些内核资源。</p><h4 id="10-试述Linux系统调用-INT-80H-的工作原理？"><a href="#10-试述Linux系统调用-INT-80H-的工作原理？" class="headerlink" title="10 试述Linux系统调用(INT 80H)的工作原理？"></a>10 试述Linux系统调用(INT 80H)的工作原理？</h4><p>应用程序调用库函数（API）；</p><p>API将系统调用号存入EAX，然后通过中断调用使系统进入内核态；</p><p>内核中的中断处理函数根据系统调用号，调用对应的内核函数（系统调用）；</p><p>系统调用完成相应功能，将返回值存入EAX，返回到中断处理函数；</p><p>中断处理函数返回到API中；</p><p>API将EAX返回给应用程序。</p><h4 id="11-试述为Linux增加新的系统调用的过程？"><a href="#11-试述为Linux增加新的系统调用的过程？" class="headerlink" title="11 试述为Linux增加新的系统调用的过程？"></a>11 试述为Linux增加新的系统调用的过程？</h4><p>1、在sys.c中加入函数</p><p>2、添加声明</p><p>3、添加ID</p><p>4、重新配置安装内核</p><h4 id="12-回顾汇编语言中关于寄存器结构和定义部分的知识，理解各个寄存器的基本作用和用法。"><a href="#12-回顾汇编语言中关于寄存器结构和定义部分的知识，理解各个寄存器的基本作用和用法。" class="headerlink" title="12 回顾汇编语言中关于寄存器结构和定义部分的知识，理解各个寄存器的基本作用和用法。"></a>12 回顾汇编语言中关于寄存器结构和定义部分的知识，理解各个寄存器的基本作用和用法。</h4><p>寄存器是中央处理器内的组成部份。寄存器是有限存贮容量的高速存贮部件，它们可用来暂存指令、数据和位址。在中央处理器的控制部件中，包含的寄存器有指令寄存器(IR)和程序计数器(PC)。在中央处理器的算术及逻辑部件中，包含的寄存器有累加器(ACC)。</p><p>寄存器的作用：可将寄存器内的数据执行算术及逻辑运算；存于寄存器内的地址可用来指向内存的某个位置，即寻址；可以用来读写数据到电脑的周边设备。</p><p>数据寄存器主要用来保存操作数和运算结果等信息，从而节省读取操作数所需占用总线和访问存储器的时间。</p><p>寄存器 ESI、EDI称为变址寄存器(Index Register)，它们主要用于存放存储单元在段内的偏移量，用它们可实现多种存储器操作数的寻址方式，为以不同的地址形式访问存储单元提供方便。</p><p>寄存器EBP、ESP、BP和SP称为指针寄存器(Pointer Register)，主要用于存放堆栈内存储单元的偏移量，用它们可实现多种存储器操作数的寻址方式，为以不同的地址形式访问存储单元提供方便。</p><p>段寄存器是根据内存分段的管理模式而设置的。内存单元的物理地址由段寄存器的值和一个偏移量组合而成的，这样可用两个较少位数的值组合成一个可访问较大物理空间的内存地址。</p><p>​指令指针EIP、IP(InstructionPointer)是存放下次将要执行的指令在代码段的偏移量。</p><p>标志寄存器用于实现特定功能。</p><h4 id="13-尝试去理解用-menucofig命令去配置Linux内核时，配置界面上每个条目的含义和作用？"><a href="#13-尝试去理解用-menucofig命令去配置Linux内核时，配置界面上每个条目的含义和作用？" class="headerlink" title="13 尝试去理解用 menucofig命令去配置Linux内核时，配置界面上每个条目的含义和作用？"></a>13 尝试去理解用 menucofig命令去配置Linux内核时，配置界面上每个条目的含义和作用？</h4><p>Code maturity level options：代码成熟等级</p><p>Loadable module support：对模块的支持</p><p>General setup：常规内核选项</p><p>Memory Technology Devices (MTD)：配置存储设备</p><p>Parallel port support：配置并口</p><p>Plug and Play configuration：即插即用支持</p><p>Block devices：块设备支持</p><p>Multiple devices driver support：多设备驱动支持</p><p>Networking options：网络选项</p><p>Telephony Support：电话支持</p><p>ATA/IDE/MFM/RLL support：配置对ATA，IDE，MFM和RLL的支持</p><p>SCSI support：SCSI设备的支持</p><p>I2O Device Support：I20设备支持</p><p>Network Device Support：网络设备支持</p><p>Amateur Radio support：配置业余广播支持</p><p>IrDA（infrared）support：配置红外线（无线）通讯支持</p><p>ISDN subsystem：配置ISDN</p><p>Old CD-ROM drivers（not SCSI、not IDE）：配置老CDROM</p><p>Input Core Support：提供USB支持</p><p>Character devices：字符设备</p><p>Multimedia Devices：配置多媒体设备</p><p>File System：配置文件系统</p><p>Console drivers：配置控制台驱动</p><p>USB support：配置USB支持</p><p>kernel hacking：配置“kernel hacking”</p><p>​<a href="https://blog.csdn.net/xuyuefei1988/article/details/8635539" target="_blank" rel="noopener">https://blog.csdn.net/xuyuefei1988/article/details/8635539</a></p><h4 id="14-在Linux上练习使用管道命令。"><a href="#14-在Linux上练习使用管道命令。" class="headerlink" title="14 在Linux上练习使用管道命令。"></a>14 在Linux上练习使用管道命令。</h4><p><code>curl -s https://api.github.com/repos/iissnan/hexo-theme-next/releases/latest | grep tarball_url | cut -d &#39;&quot;&#39; -f 4 | wget -i - -O- | tar -zx -C themes/next --strip-components=1</code></p><p>这条指令是一个管道指令，首先打开指定网络文件，获取tarball_url对应的值，去掉首末端双引号得到一个网址，下载对应文件并解压到指定目录，去掉第一层目录。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统课程学习笔记一-操作系统概述</title>
      <link href="/2020/02/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"/>
      <url>/2020/02/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-操作系统概述"><a href="#第一章-操作系统概述" class="headerlink" title="第一章 操作系统概述"></a>第一章 操作系统概述</h1><h4 id="1-1-没有安装操作系统的计算机启动过程和结果？"><a href="#1-1-没有安装操作系统的计算机启动过程和结果？" class="headerlink" title="1.1 没有安装操作系统的计算机启动过程和结果？"></a>1.1 没有安装操作系统的计算机启动过程和结果？</h4><p>启动会比较快，但功能很局限，无法使用常见的软件应用，对于普通用户来说，功能很局限，对于专业工程师来说，想使用没有操作系统的计算机也有难度。</p><h4 id="1-2-常见的虚拟机软件（例如VMware，VirtualPC等）能不能理解为操作系统？"><a href="#1-2-常见的虚拟机软件（例如VMware，VirtualPC等）能不能理解为操作系统？" class="headerlink" title="1.2 常见的虚拟机软件（例如VMware，VirtualPC等）能不能理解为操作系统？"></a>1.2 常见的虚拟机软件（例如VMware，VirtualPC等）能不能理解为操作系统？</h4><p>不能理解为完全的操作系统。因为操作系统是作为硬件部分和应用软件的中间桥梁而存在的，硬件与软件的交互必须通过操作系统。因此虚拟机虽然可以模拟操作系统的功能，但仍是作为应用软件通过真实操作系统与硬件进行交互</p><h4 id="1-3-现代操作系统会不会因为内存太小，而让应用程序无法启动运行或让系统崩溃？"><a href="#1-3-现代操作系统会不会因为内存太小，而让应用程序无法启动运行或让系统崩溃？" class="headerlink" title="1.3 现代操作系统会不会因为内存太小，而让应用程序无法启动运行或让系统崩溃？"></a>1.3 现代操作系统会不会因为内存太小，而让应用程序无法启动运行或让系统崩溃？</h4><p>一般不会。现代操作系统可以合理分配内存，即使软件所需内存大大超过实际内存，也仅仅是使计算机响应变慢，甚至是出现类似“死机”的情况，表现为计算机无法加载软件初始页面，难以响应输入设备的状态变化，只能通过强制重启计算机解决。但不会无法启动软件或使系统出现故障</p><h4 id="1-4-在多道批处理中尝试不断增加程序的数量，系统的效率会不会持续增加？结果会如何？"><a href="#1-4-在多道批处理中尝试不断增加程序的数量，系统的效率会不会持续增加？结果会如何？" class="headerlink" title="1.4 在多道批处理中尝试不断增加程序的数量，系统的效率会不会持续增加？结果会如何？"></a>1.4 在多道批处理中尝试不断增加程序的数量，系统的效率会不会持续增加？结果会如何？</h4><p>如果在CPU工作未饱和的情况下，增加程序会增加系统工作效率。但若CPU工作饱和的情况下增加程序，不会增加工作效率。</p><h4 id="1-5-分时技术的时间片设置太大或太小，应该根据哪些因素来考虑？是尽量大好还是尽量小好？"><a href="#1-5-分时技术的时间片设置太大或太小，应该根据哪些因素来考虑？是尽量大好还是尽量小好？" class="headerlink" title="1.5 分时技术的时间片设置太大或太小，应该根据哪些因素来考虑？是尽量大好还是尽量小好？"></a>1.5 分时技术的时间片设置太大或太小，应该根据哪些因素来考虑？是尽量大好还是尽量小好？</h4><p>要根据实际情况选择合适的时间片大小，比如软件的实时性要求以及程序结构特点。时间片太长，应用软件交互性变差，时间片太短，CPU频繁进行切换进程的操作，耗费不必要的运算资源</p><p>###单元作业</p><h4 id="1-站在普通用户的角度，总结操作系统有哪些基本功能？"><a href="#1-站在普通用户的角度，总结操作系统有哪些基本功能？" class="headerlink" title="1 站在普通用户的角度，总结操作系统有哪些基本功能？"></a>1 站在普通用户的角度，总结操作系统有哪些基本功能？</h4><p>1、提供操作界面</p><p>2、控制程序运行</p><p>3、管理系统资源</p><p>4、配置系统参数</p><p>5、监控系统状态</p><p>6、提供工具软件集合</p><h4 id="2-操作系统有哪4大核心功能？"><a href="#2-操作系统有哪4大核心功能？" class="headerlink" title="2 操作系统有哪4大核心功能？"></a>2 操作系统有哪4大核心功能？</h4><p>1、进程管理（CPU管理）：<br>实现进程控制、调度和通信</p><p>2、内存管理：<br>实现内存分配、共享、保护以及虚拟内存技术</p><p>3、设备管理：<br>实现设备的分配调度、传输控制等</p><p>4、文件管理：<br>实现储存空间的管理、文件的操作、目录的操作以及文件目录的存取权限管理</p><h4 id="3-操作系统有哪4个典型的发展阶段，各有什么特点？"><a href="#3-操作系统有哪4个典型的发展阶段，各有什么特点？" class="headerlink" title="3 操作系统有哪4个典型的发展阶段，各有什么特点？"></a>3 操作系统有哪4个典型的发展阶段，各有什么特点？</h4><p>1、手工操作（无操作系统）：<br>对应计算机的电子管时代。程序启动、运行、结束需要手工处理，操作繁琐，CPU利用率低、用户独占使用、缺少交互。</p><p>2、单通道批处理系统：<br>对应计算机的晶体管时代。管理员事先将多个作业输入到磁盘形成作业队列，系统依次运行各个作业任务，自动完成程序装入和撤出。外设与CPU交替运行，设备利用率低</p><p>3、多通道批处理系统：<br>内存中存放多道程序，当某道程序因为某种原因不能继续运行而放弃CPU时，系统调用零一程序投入运行。CPU利用率高，宏观上程序并行处理，微观上串行处理，作业处理时间长、用户与程序交互性差、程序运行状态不确定。</p><p>4、分时系统：<br>随着中断技术和通道技术的发展，分时技术开始运用于操作系统中。以时间片为单位把CPU轮流分配给每个终端使用。具有多路调制性、用户独占性（感觉上）、良好的交互性。</p><h4 id="4-多道批处理系统为什么工作效率比单道的高？"><a href="#4-多道批处理系统为什么工作效率比单道的高？" class="headerlink" title="4 多道批处理系统为什么工作效率比单道的高？"></a>4 多道批处理系统为什么工作效率比单道的高？</h4><p>对于单道处理系统来说，在CPU处理程序前需要通过I/O读程序，在CPU处理程序后需要通过I/O写程序，系统在读写程序时CPU处于空闲状态，造成资源的浪费。<br>而多道批处理系统可以在读写程序的同时进行CPU处理程序的任务，这样当系统加载多个任务时，可以尽量保证CPU和外设处于工作状态，提高工作效率。</p><h4 id="5-分时技术与多道批处理都能完成多个程序的切换。这两种切换情形有什么差别？"><a href="#5-分时技术与多道批处理都能完成多个程序的切换。这两种切换情形有什么差别？" class="headerlink" title="5 分时技术与多道批处理都能完成多个程序的切换。这两种切换情形有什么差别？"></a>5 分时技术与多道批处理都能完成多个程序的切换。这两种切换情形有什么差别？</h4><p>多道批处理是在内存中同时存放多道程序，用户将一批程序提交给操作系统后就不再干预，由操作系统控制它们自动运行。<br>分时技术是给不同终端用户的程序提供轮流使用CPU的机会，多个程序分时（分时间片）共享硬件和软件资源，以交互方式使用计算机，共享主机中的资源。<br>批处理系统没有人机交互，而分时系统允许多个用户同时使用；批处理系统中允许程序长时间地占用CPU，而分时系统不允许。<br>分时技术一般要优于多道批处理，二者的出现主要与硬件性能决定，随着计算机性能的显著提升，分时技术出现，成为当前操作系统主要采用的多程序切换原理</p><h4 id="6-思考运行应用程序（例如记事本程序）需要操作系统提供哪些支持？"><a href="#6-思考运行应用程序（例如记事本程序）需要操作系统提供哪些支持？" class="headerlink" title="6 思考运行应用程序（例如记事本程序）需要操作系统提供哪些支持？"></a>6 思考运行应用程序（例如记事本程序）需要操作系统提供哪些支持？</h4><p>1、文件系统，将程序置入内存中<br>2、内存管理<br>3、设备管理，从键盘、鼠标读取设备状态，向屏幕显示信息<br>4、进程管理，应用程序可能会同时操作多个进程</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>万事开头难，但过程也并不轻松</title>
      <link href="/2020/02/11/%E4%B8%87%E4%BA%8B%E5%BC%80%E5%A4%B4%E9%9A%BE/"/>
      <url>/2020/02/11/%E4%B8%87%E4%BA%8B%E5%BC%80%E5%A4%B4%E9%9A%BE/</url>
      
        <content type="html"><![CDATA[<p>这是第一篇博客文章，主要写一下搭建博客的过程。</p><h2 id="第一步：Hexo"><a href="#第一步：Hexo" class="headerlink" title="第一步：Hexo"></a>第一步：Hexo</h2><p>使用了<a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>脚手架。<br>首先找一个放置脚手架的目录，输入以下命令完成安装：<br> <a id="more"></a> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">hexo init blog</span><br><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>文件目录大致如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── <span class="built_in">source</span></span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure><p>-config.yml中是博客参数配置<br>scaffoles中是模板文件，可以修改文章的模板<br>source中是博客中的静态资源，这篇文章就是通过source/_posts目录下的md文档写的<br>themes中是主题样式，是编写博客样式的地方，可以自己编，也可以用现成的</p><p>然后就可以在配置文件<code>-config.yml</code>中绑定自己的域名。我用的是github.io，可以参考<a href="https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html" target="_blank" rel="noopener">搭建免费个人博客详细教程</a>进行配置。<br>绑定域名后就可以上传博客页面了。</p><p>下面是一些常用hexo命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo g          //生成项目</span><br><span class="line">hexo s --debug  //本地调试（热更新）</span><br><span class="line">hexo clean      //清除生成项目</span><br><span class="line">hexo d          //部署项目</span><br></pre></td></tr></table></figure><p>如果直接生成并部署项目，打开网页会看到Hexo提供的默认主题。主题存放于themes文件夹下，默认的主题名为landscape，文件夹名即为主题名，可在配置文件<code>-config.yml</code>的<code>theme</code>项中更改。但前提是themes目录下有其他的主题。</p><h2 id="第二步：主题"><a href="#第二步：主题" class="headerlink" title="第二步：主题"></a>第二步：主题</h2><p>说实话，Hexo默认的主题landscape就不错，简洁大气，但直接用默认主题就没意思了。GitHub上页有一些不错的主题模板，比如Next，星星是最高的，但感觉页面效果也没那么好，而且想用Next也有不少配置要学，索性自己从零开始搭建。</p><p>我的主题主要是仿照默认主题的结构编写。landscape主题目录下有languages、layout、scripts和source四个文件夹，languages存放语言配置文件，layout存放页面模板文件，scripts存放Hexo脚本，source存放页面样式、图片、字体等资源文件。</p><p>由于主题文件的编写是采用<a href="https://ejs.bootcss.com/" target="_blank" rel="noopener">ejs</a>模板引擎，所以如果没接触过ejs可能不好上手。可以参考<a href="https://www.cnblogs.com/mmzuo-798/p/10451385.html" target="_blank" rel="noopener">从零开始制作Hexo主题</a>进行编写。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统课程学习笔记二-操作系统逻辑结构</title>
      <link href="/2020/02/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84/"/>
      <url>/2020/02/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="第二章-操作系统逻辑结构"><a href="#第二章-操作系统逻辑结构" class="headerlink" title="第二章 操作系统逻辑结构"></a>第二章 操作系统逻辑结构</h1><h4 id="2-1-操作系统的微内核结构的优点对我们设计大规模的应用程序有什么启示？"><a href="#2-1-操作系统的微内核结构的优点对我们设计大规模的应用程序有什么启示？" class="headerlink" title="2.1 操作系统的微内核结构的优点对我们设计大规模的应用程序有什么启示？"></a>2.1 操作系统的微内核结构的优点对我们设计大规模的应用程序有什么启示？</h4><p>微内核架构包含两类组件：核心系统（core system）和插件模块（plug-in modules）。</p><p>核心系统负责和具体业务功能无关的通用功能，例如模块加载、模块间通信等；插件模块负责实现具体的业务逻辑。核心系统功能比较稳定，不会因为业务功能扩展而不断修改，插件模块可以根据业务功能的需要不断地扩展。微内核的架构本质就是将变化部分封装在插件里面，从而达到快速灵活扩展的目的，而又不影响整体系统的稳定。</p><p>比如vue和react等前端框架都采用这种结构，简洁的核心组件和丰富的插件模块，实现功能的按需加载，各个部分易于维护和修改。</p><h4 id="2-2-用户态向内核态转有多种情形（用户请求OS提供服务、发生中断、用户进程产生错误、用户态企图执行特权指令），但是本质上就是一种情形，即通过中断的形式进入。如何理解这句话？"><a href="#2-2-用户态向内核态转有多种情形（用户请求OS提供服务、发生中断、用户进程产生错误、用户态企图执行特权指令），但是本质上就是一种情形，即通过中断的形式进入。如何理解这句话？" class="headerlink" title="2.2 用户态向内核态转有多种情形（用户请求OS提供服务、发生中断、用户进程产生错误、用户态企图执行特权指令），但是本质上就是一种情形，即通过中断的形式进入。如何理解这句话？"></a>2.2 用户态向内核态转有多种情形（用户请求OS提供服务、发生中断、用户进程产生错误、用户态企图执行特权指令），但是本质上就是一种情形，即通过中断的形式进入。如何理解这句话？</h4><p>中断是指CPU对突发的外部事件的反应过程或机制，用户请求OS提供服务、用户进程产生错误、用户态企图执行特权指令都是中断的几种情况，中断响应的本质是交换指令执行地址和交换CPU的态.</p><h4 id="2-3-CPU收到外部中断信号后，是如何响应该外部信号，完成中断服务程序后，并最后自动回到原程序继续运行的？这个过程中硬件，软件会做哪些工作？"><a href="#2-3-CPU收到外部中断信号后，是如何响应该外部信号，完成中断服务程序后，并最后自动回到原程序继续运行的？这个过程中硬件，软件会做哪些工作？" class="headerlink" title="2.3 CPU收到外部中断信号后，是如何响应该外部信号，完成中断服务程序后，并最后自动回到原程序继续运行的？这个过程中硬件，软件会做哪些工作？"></a>2.3 CPU收到外部中断信号后，是如何响应该外部信号，完成中断服务程序后，并最后自动回到原程序继续运行的？这个过程中硬件，软件会做哪些工作？</h4><p>1、识别中断源</p><p>2、保护断点和现场</p><p>3、装入中断服务程序的入口地址</p><p>4、进入中断服务程序</p><p>5、结束中断程序后恢复现场和断点</p><p>6、中断返回</p><p>###单元作业</p><h4 id="1-何为操作系统的逻辑结构？有哪几种典型逻辑结构？"><a href="#1-何为操作系统的逻辑结构？有哪几种典型逻辑结构？" class="headerlink" title="1. 何为操作系统的逻辑结构？有哪几种典型逻辑结构？"></a>1. 何为操作系统的逻辑结构？有哪几种典型逻辑结构？</h4><p>操作系统的逻辑结构是指操作系统的设计实现思路。分为整体式结构、层次式结构和微内核结构。</p><p>1、整体式结构以模块为基本单位，但信息传递随意，维护更新困难。</p><p>2、层次式结构根据模块功能分为多个层级，相邻层级只有单向调用，结构清晰，利于系统维护移植。</p><p>3、微内核结构包含两类组件：核心系统（core system）和插件模块（plug-in modules）。核心系统负责和具体业务功能无关的通用功能，例如模块加载、模块间通信等，插件模块负责实现具体的业务逻辑。</p><h4 id="2-分层结构的分层原则是什么？"><a href="#2-分层结构的分层原则是什么？" class="headerlink" title="2. 分层结构的分层原则是什么？"></a>2. 分层结构的分层原则是什么？</h4><p>1、最底层与硬件相关</p><p>2、最外层与外部特性相关</p><p>3、中间层按调用次序和消息传递顺序规划</p><p>4、共性服务置于较低层</p><p>5、活跃功能置于较低层</p><h4 id="3-何为CPU的态？定义态的作用什么？有哪些态？"><a href="#3-何为CPU的态？定义态的作用什么？有哪些态？" class="headerlink" title="3. 何为CPU的态？定义态的作用什么？有哪些态？"></a>3. 何为CPU的态？定义态的作用什么？有哪些态？</h4><p>CPU的态（Mode）是指CPU的工作状态，是对资源和指令使用权限的描述。</p><p>定义态可以实现对资源和指令的分级管理，避免用户直接操作计算机硬件。</p><p>CPU的态分为核态（Kernel mode）、用户态（User mode）和管态（Supervisor mode）。核态能访问所有资源，能执行所有指令，一般宫管理程序和操作系统内核使用；用户态仅能访问操作系统提供的部分接口，一般供用户程序使用；管态是介于核态和用户态之间的状态。</p><h4 id="4-操作系统分层结构有何作用？在应用编程中，我们如何使用分层的编程思想提升程序的可移植性和可维护性？"><a href="#4-操作系统分层结构有何作用？在应用编程中，我们如何使用分层的编程思想提升程序的可移植性和可维护性？" class="headerlink" title="4. 操作系统分层结构有何作用？在应用编程中，我们如何使用分层的编程思想提升程序的可移植性和可维护性？"></a>4. 操作系统分层结构有何作用？在应用编程中，我们如何使用分层的编程思想提升程序的可移植性和可维护性？</h4><p>层次结构结构清晰，可以避免循环调用。将整体问题局部化，易于保证系统的正确性。最底层与硬件相关、最外层与外部特性相关的结构有利于操作系统的维护扩充和移植。</p><p>对于前端工程师来说，在设计程序时，可大致分为API模块、UI模块和核心业务模块，API模块负责处理与后端的通信和数据交互，UI模块负责呈现页面，核心业务模块负责逻辑处理和功能实现，根据需要进一步拆分为多个模块。这样就有比较强的可移植性和可维护性，当后端接口或浏览器发生变化时，直接修改对应模块就可以。</p><h4 id="5-下载Linux-0-11-OS源代码，用SourceInsight软件打开源代码，了解其源代码的构成，大致的模块结构-做简单的文字描述。"><a href="#5-下载Linux-0-11-OS源代码，用SourceInsight软件打开源代码，了解其源代码的构成，大致的模块结构-做简单的文字描述。" class="headerlink" title="5. 下载Linux 0.11 OS源代码，用SourceInsight软件打开源代码，了解其源代码的构成，大致的模块结构,做简单的文字描述。"></a>5. 下载Linux 0.11 OS源代码，用SourceInsight软件打开源代码，了解其源代码的构成，大致的模块结构,做简单的文字描述。</h4><p>​Linux 0.11分为下面几个文件夹：</p><p>boot：计算机启动代码</p><p>init：操作系统初始化</p><p>include：各种函数的声明以及各类宏定义</p><p>kernel：与进程有关</p><p>mm：内存管理</p><p>Lib：链接时用到的库</p><p>Fs：文件系统</p><h4 id="6-下载Minix-OS源代码，用SourceInsight软件打开源代码，了解其源代码的构成，大致的模块结构-做简单的文字描述。"><a href="#6-下载Minix-OS源代码，用SourceInsight软件打开源代码，了解其源代码的构成，大致的模块结构-做简单的文字描述。" class="headerlink" title="6. 下载Minix OS源代码，用SourceInsight软件打开源代码，了解其源代码的构成，大致的模块结构,做简单的文字描述。"></a>6. 下载Minix OS源代码，用SourceInsight软件打开源代码，了解其源代码的构成，大致的模块结构,做简单的文字描述。</h4><p>minix 2.0：</p><p>include/目录包含了操作系统所有的头文件（即.h文件）</p><p>其中：</p><p>include/目录下为POSIX标准头文件；</p><p>include/sys/目录下为额外的POSIX标准头文件；</p><p>include/minix/目录下为MINIX操作系统定义的头文件</p><p>src/目录下包含了操作系统所有的源文件（.c或.s文件）</p><p>其中：</p><p>src/kernel/目录存放着MINIX操作系统第一层（进程管理）和第二层（设备管理）的源代码；</p><p>src/mm/目录存放着MINIX操作系统第三层中内存管理子系统的源代码；</p><p>src/fs目录下存放着MINIX操作系统第三层中文件管理系统的源代码；</p><p>src/lib目录下存放着MINIX操作系统使用的库例程源代码（e.g. open，read）；</p><p>src/tools目录下存放着Init源程序，用于启动Minix；</p><p>src/boot目录下存放着启动和安装MINIX操作系统的源代码；</p><p>src/commands/ ：包含公用程序（e.g. cat, cp, date, ls, pwd）的源代码；</p><p>src/test/： 包含有一些被设计用来对新编译好的Minix系统进行完整测试的工具（由于Minix是一个用于教学的操作系统，这意味着对它常常要作修改）；</p><p>src/inet/： 包含了重新编译Minix以使之支持网路的源代码 </p><p>转载于：<a href="https://www.cnblogs.com/wuyudong/p/3637477.html" target="_blank" rel="noopener">https://www.cnblogs.com/wuyudong/p/3637477.html</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
