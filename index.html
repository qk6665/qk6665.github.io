<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.7.1',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="welcome to qk6665&#39;blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="welcome to qk6665&#39;blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="qk6665">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>welcome to qk6665'blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">welcome to qk6665'blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-fw fa-calendar"></i>日程表</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/16/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%94-%E8%87%AA%E4%B8%8A%E8%80%8C%E4%B8%8B%E7%9A%84%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qk6665">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="welcome to qk6665'blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/16/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%94-%E8%87%AA%E4%B8%8A%E8%80%8C%E4%B8%8B%E7%9A%84%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">编译原理学习笔记五-自上而下的语法分析</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-03-16 21:59:56 / 修改时间：23:45:35" itemprop="dateCreated datePublished" datetime="2020-03-16T21:59:56+08:00">2020-03-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第五章-自上而下的语法分析"><a href="#第五章-自上而下的语法分析" class="headerlink" title="第五章 自上而下的语法分析"></a>第五章 自上而下的语法分析</h1><h4 id="自上而下"><a href="#自上而下" class="headerlink" title="自上而下"></a>自上而下</h4><p>从文法的开始符号出发，反复使用各种产生式，寻找”匹配”的推导；<br>推导：根据文法的产生式规则，把串中出现的产生式的左部符号替换成右部；<br>针对输入串，试图用一切可能的办法，从文法开始符号(根结点)出发，自上而下地为输入串建立一棵语法树；<br>递归下降分析法、预测分析程序。</p>
<h3 id="第一部分：LL-1-文法"><a href="#第一部分：LL-1-文法" class="headerlink" title="第一部分：LL(1)文法"></a>第一部分：LL(1)文法</h3><h4 id="1-多个产生式候选带来的问题"><a href="#1-多个产生式候选带来的问题" class="headerlink" title="1 多个产生式候选带来的问题"></a>1 多个产生式候选带来的问题</h4><p>回溯问题：分析过程中，当一个非终结符用某一个候选匹配成功时，这种匹配可能是暂时的，出错时，不得不“回溯”；<br>文法左递归问题：左递归的文法可能由于语法错误导致陷入死循环。</p>
<h4 id="2-直接左递归的消除"><a href="#2-直接左递归的消除" class="headerlink" title="2 直接左递归的消除"></a>2 直接左递归的消除</h4><p><img src="/2020/03/16/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%94-%E8%87%AA%E4%B8%8A%E8%80%8C%E4%B8%8B%E7%9A%84%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/1.png" alt="直接左递归的消除"></p>
<p><strong>公式</strong>：<br>P→Pα1 | Pα2 |……| Pαm |β1 |β2 |……|βn<br>推导为：<br>P→β1P’|β2P’|…|βnP’<br>P’→α1P’|α2P’|…|αmP’|ε  </p>
<p><strong>例子</strong>：<br>给定文法G(E):<br>E→E＋T | T<br>T→T<em>F | F<br>F→(E) | i<br>推导为：<br>G(E):<br>E→TE’<br>E’→+TE’ | ε<br>T→FT’<br>T’→</em>FT’ | ε<br>F→(E) | i    </p>
<h4 id="3-间接左递归的消除"><a href="#3-间接左递归的消除" class="headerlink" title="3 间接左递归的消除"></a>3 间接左递归的消除</h4><p><img src="/2020/03/16/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%94-%E8%87%AA%E4%B8%8A%E8%80%8C%E4%B8%8B%E7%9A%84%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/2.png" alt="间接左递归的消除"></p>
<h4 id="4-消除回溯"><a href="#4-消除回溯" class="headerlink" title="4 消除回溯"></a>4 消除回溯</h4><p>为了消除回溯必须保证对文法的任何非终结符，当要它去匹配输入串时，能够根据它所面临的输入符号准确地指派它的一个候选去执行任务，并且此候选的工作结果应是确信无疑的。</p>
<h4 id="5-𝐹𝐼𝑅𝑆𝑇集合"><a href="#5-𝐹𝐼𝑅𝑆𝑇集合" class="headerlink" title="5 𝐹𝐼𝑅𝑆𝑇集合"></a>5 𝐹𝐼𝑅𝑆𝑇集合</h4><p>令G是一个不含左递归的文法，对G的所有非终结符的每个候选𝛼定义它的终结首符集FIRST(𝛼)为：<br>𝐹𝐼𝑅𝑆𝑇(𝛼)={𝑎│𝛼∗⇒ 𝑎…, 𝑎∈𝑉𝑇}<br>特别是，若𝛼∗⇒ 𝜀，则规定𝜀∈𝐹𝐼𝑅𝑆𝑇(𝛼)。</p>
<h4 id="6-𝐹𝑂𝐿𝐿𝑂𝑊集合"><a href="#6-𝐹𝑂𝐿𝐿𝑂𝑊集合" class="headerlink" title="6 𝐹𝑂𝐿𝐿𝑂𝑊集合"></a>6 𝐹𝑂𝐿𝐿𝑂𝑊集合</h4><p>假定S是文法G的开始符号，对于G的任何非终结符A，我们定义A的FOLLOW集合：<br>𝐹𝑂𝐿𝐿𝑂𝑊(𝐴)={𝑎│𝑆∗⇒…𝐴𝑎…, 𝑎∈𝑉𝑇 }<br>特别是，若𝑆∗⇒…𝐴，则规定#∈𝐹𝑂𝐿𝐿𝑂𝑊(𝐴)</p>
<h4 id="7-LL-1-文法"><a href="#7-LL-1-文法" class="headerlink" title="7 LL(1)文法"></a>7 LL(1)文法</h4><p>特点：</p>
<ol>
<li>文法不含左递归  </li>
<li>对于文法中每一个非终结符A的各个产生式的候选首符集两两不相交。  </li>
<li>对文法中的每个非终结符A，若它存在某个候选首符集包含𝜀，则<br>FIRST(𝛼i)∩FOLLOW(A)=#，i=1,2,…,n</li>
</ol>
<p>对于LL(1)文法，可以对其输入串进行有效的无回溯的自上而下分析。<br>假设要用非终结符A进行匹配，面临的输入符号为a：  </p>
<ol>
<li>若a∈FIRST(𝛼i)，则指派𝛼i执行匹配任务；  </li>
<li>若a不属于任何一个候选首符集，则：<br>(1) 若𝛼属于某个FIRST(𝛼i)且 a∈FOLLOW(A)，则让A与𝛼自动匹配。<br>(2) 否则，a的出现是一种语法错误。</li>
</ol>
<h3 id="第二部分：递归下降分析程序"><a href="#第二部分：递归下降分析程序" class="headerlink" title="第二部分：递归下降分析程序"></a>第二部分：递归下降分析程序</h3><h4 id="8-递归下降分析器"><a href="#8-递归下降分析器" class="headerlink" title="8 递归下降分析器"></a>8 递归下降分析器</h4><p>分析程序由一组子程序组成， 对每一语法单位(非终结符)构造一个相应的子程序，识别对应的语法单位；<br>通过子程序间的相互调用实现对输入串的识别；<br>例如，A → B c D；<br>文法的定义通常是递归的，通常具有递归结构。</p>
<p>每个非终结符有对应的子程序的定义，在分析过程中，当需要从某个非终结符出发进行展开(推导)时，就调用这个非终结符对应的子程序。</p>
<p>例子：<br>定义全局过程和变量：<br>ADVANCE，把输入串指示器IP指向下一个输入符号，即读入一个单词符号；<br>SYM，IP当前所指的输入符号；<br>ERROR，出错处理子程序。<br>A→TE’ | BC | 𝜀    对应的递归下降子程序为：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PROCEDURE  A；</span><br><span class="line">BEGIN</span><br><span class="line">  IF  SYM ∈FIRST(TE&#39;) THEN</span><br><span class="line">    BEGIN  T；E&#39; END</span><br><span class="line">  ELSE IF  SYM ∈FIRST(BC) THEN</span><br><span class="line">    BEGIN  B; C  END</span><br><span class="line">  ELSE IF  SYM ∈FOLLOW(A) THEN</span><br><span class="line">    ERROR</span><br><span class="line">END；</span><br></pre></td></tr></table></figure>


<h4 id="9-扩充的巴科斯范式"><a href="#9-扩充的巴科斯范式" class="headerlink" title="9 扩充的巴科斯范式"></a>9 扩充的巴科斯范式</h4><p>在元符号“→”或“::=”和“|”的基础上，扩充几个元语言符号：<br>用花括号{α}表示闭包运算α*。<br>用表示{α}<sub>0</sub><sup>n</sup>可任意重复0次至n次。<br>用方括号[α]表示{α}<sub>0</sub><sup>1</sup>，即表示α的出现可有可无(等价于α|𝜀)。  </p>
<p>例如实数可定义为：<br>   Decimal→[Sign]Integer.{digit}[Exponent]<br>   Exponent→E[Sign]Integer<br>   Integer→digit{digit}<br>   Sign→ + | -</p>
<p>用扩充的巴科斯范式来描述语法，直观易懂，便于表示左递归消去和因子提取。</p>
<h3 id="第二部分：预测分析程序"><a href="#第二部分：预测分析程序" class="headerlink" title="第二部分：预测分析程序"></a>第二部分：预测分析程序</h3><h4 id="10-预测分析程序构成"><a href="#10-预测分析程序构成" class="headerlink" title="10 预测分析程序构成"></a>10 预测分析程序构成</h4><p>总控程序，根据现行栈顶符号和当前输入符号，执行动作；<br>分析表 M[A，a]矩阵，A ∈ V<sub>N</sub> ，a ∈ V<sub>T</sub> 是终结符或‘＃’；<br>分析栈 STACK  用于存放文法符号。</p>
<p><img src="/2020/03/16/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%94-%E8%87%AA%E4%B8%8A%E8%80%8C%E4%B8%8B%E7%9A%84%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/3.png" alt="预测分析程序构成"></p>
<h4 id="11-预测分析过程"><a href="#11-预测分析过程" class="headerlink" title="11 预测分析过程"></a>11 预测分析过程</h4><p>总控程序根据当前栈顶符号X和输入符号a，执行下列三动作之一：  </p>
<ol>
<li>若X＝a＝‘＃’，则宣布分析成功，停止分析。  </li>
<li>若X＝a ≠‘＃’，则把X从STACK栈顶逐出，让a指向下一个输入符号。  </li>
<li>若X是一个非终结符，则查看分析表M。<br>若M[X，a]中存放着关于X的一个产生式，把X逐出STACK栈顶，把产生式的右部符号串按反序一一推进STACK栈(若右部符号为𝜀，则意味不推什么东西进栈)。<br>若M[X，a]中存放着“出错标志”，则调用出错诊察程序ERROR。</li>
</ol>
<h4 id="12-总控程序实现"><a href="#12-总控程序实现" class="headerlink" title="12 总控程序实现"></a>12 总控程序实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">BEGIN</span><br><span class="line">  首先把‘＃’然后把文法开始符号推进STACK栈；</span><br><span class="line">  把第一个输入符号读进a；</span><br><span class="line">  FLAG:&#x3D;TRUE;</span><br><span class="line">  WHILE  FLAG  DO</span><br><span class="line">  BEGIN</span><br><span class="line">    把STACK栈顶符号上托出去并放在X中；</span><br><span class="line">    IF X属于VT THEN</span><br><span class="line">      IF X&#x3D; a  THEN 把下一输入符号读进a</span><br><span class="line">        ELSE   ERROR</span><br><span class="line">      ELSE IF X&#x3D;‘#’ THEN</span><br><span class="line">        IF X&#x3D;a THEN FLAG:&#x3D;FALSE </span><br><span class="line">          ELSE ERROR</span><br><span class="line">      ELSE IF M[X,a]&#x3D;&#123;X→X1X2…Xk&#125;THEN</span><br><span class="line">      把Xk,Xk-1,…,X1一一推进STACK栈</span><br><span class="line">      &#x2F;* 若X1X2…Xk&#x3D;𝜀，不推什么进栈 *&#x2F;</span><br><span class="line">      ELSE ERROR</span><br><span class="line">    END OF WHILE;</span><br><span class="line">  STOP &#x2F;*分析成功，过程完毕*&#x2F;</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<h4 id="13-预测分析示例"><a href="#13-预测分析示例" class="headerlink" title="13 预测分析示例"></a>13 预测分析示例</h4><p><img src="/2020/03/16/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%94-%E8%87%AA%E4%B8%8A%E8%80%8C%E4%B8%8B%E7%9A%84%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/4.png" alt="预测分析示例"></p>
<h4 id="13-分析表M-A，a-的构造算法"><a href="#13-分析表M-A，a-的构造算法" class="headerlink" title="13 分析表M[A，a]的构造算法"></a>13 分析表M[A，a]的构造算法</h4><p>构造G的分析表M[A，a]， 确定每个产生式A→α在表中的位置  </p>
<ol>
<li>对文法G的每个产生式A→α执行第2步和第3步；  </li>
<li>对每个终结符a ∈ FIRST(α)，把A→α加至M[A，a]中；  </li>
<li>若𝜀 ∈ FIRST(α)，则对任何b ∈ FOLLOW(A)把A→α加至M[A，b]中；  </li>
<li>把所有无定义的M[A，a]标上“出错标志”。  </li>
</ol>
<h4 id="14-LL-1-文法与二义性"><a href="#14-LL-1-文法与二义性" class="headerlink" title="14 LL(1)文法与二义性"></a>14 LL(1)文法与二义性</h4><p>如果G是左递归或二义的，那么，M至少含有一个多重定义入口。因此，消除左递归和提取左因子将有助于获得无多重定义的分析表M。<br>可以证明，一个文法G的预测分析表M不含多重定义入口，当且仅当该文法为LL(1)的。<br>LL(1)文法不是二义的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%9B%BE%E8%AE%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qk6665">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="welcome to qk6665'blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%9B%BE%E8%AE%BA/" class="post-title-link" itemprop="url">算法课程笔记-图论</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-13 23:46:07" itemprop="dateCreated datePublished" datetime="2020-03-13T23:46:07+08:00">2020-03-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-14 13:18:32" itemprop="dateModified" datetime="2020-03-14T13:18:32+08:00">2020-03-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><p>分为无向图和有向图<br>分为有权图和无权图（边的值）<br>图的连通性<br><img src="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%9B%BE%E8%AE%BA/1.png" alt="自环边和平行边">  </p>
<h4 id="1-图的表示"><a href="#1-图的表示" class="headerlink" title="1 图的表示"></a>1 图的表示</h4><p><img src="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%9B%BE%E8%AE%BA/2.png" alt="邻接矩阵">  </p>
<p><img src="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%9B%BE%E8%AE%BA/3.png" alt="邻接表1"><br><img src="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%9B%BE%E8%AE%BA/4.png" alt="邻接表2">  </p>
<p>邻接矩阵适合表示稠密图，邻接表适合表示稀疏图。稠密与稀疏取决于边（edge）的数量。</p>
<h4 id="2-深度优先遍历（dfs）与连通分量（Components）"><a href="#2-深度优先遍历（dfs）与连通分量（Components）" class="headerlink" title="2 深度优先遍历（dfs）与连通分量（Components）"></a>2 深度优先遍历（dfs）与连通分量（Components）</h4><p>深度优先遍历与树的遍历类似，但需要记录该节点是否遍历过<br><img src="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%9B%BE%E8%AE%BA/5.png" alt="连通分量"> </p>
<h4 id="3-寻路"><a href="#3-寻路" class="headerlink" title="3 寻路"></a>3 寻路</h4><p>与dfs相似</p>
<h4 id="4-广度优先遍历（bfs）与最短路径"><a href="#4-广度优先遍历（bfs）与最短路径" class="headerlink" title="4 广度优先遍历（bfs）与最短路径"></a>4 广度优先遍历（bfs）与最短路径</h4><p>广度优先遍历与树的层序遍历类似，利用队列，一个节点出队，将所有相连节点加入队列，需要记录该节点是否遍历过。<br>广度优先遍历的特点在于先遍历的元素距离起点近（无权图）。</p>
<h4 id="5-有权图（weighted-graph）"><a href="#5-有权图（weighted-graph）" class="headerlink" title="5 有权图（weighted graph）"></a>5 有权图（weighted graph）</h4><p><img src="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%9B%BE%E8%AE%BA/6.png" alt="有权图"><br><img src="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%9B%BE%E8%AE%BA/7.png" alt="有权图邻接矩阵"><br><img src="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%9B%BE%E8%AE%BA/8.png" alt="有权图邻接表">  </p>
<h4 id="6-最小生成树和切分定理（cut-property）"><a href="#6-最小生成树和切分定理（cut-property）" class="headerlink" title="6 最小生成树和切分定理（cut property）"></a>6 最小生成树和切分定理（cut property）</h4><p>n-1条边连接了n个节点，称为生成树。若总权值最小，称为最小生成树。<br>将图进行切分，边的两个节点分属两半称为横切边。<br>切分定理：对于任意切分，横切边中权值最小的边属于最小生成树。  </p>
<h4 id="7-prim算法"><a href="#7-prim算法" class="headerlink" title="7 prim算法"></a>7 prim算法</h4><p><img src="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%9B%BE%E8%AE%BA/9.png" alt="有权图邻接表">  </p>
<h4 id="8-kruskal算法"><a href="#8-kruskal算法" class="headerlink" title="8 kruskal算法"></a>8 kruskal算法</h4><h4 id="9-最短路径问题与松弛操作（relaxation）"><a href="#9-最短路径问题与松弛操作（relaxation）" class="headerlink" title="9 最短路径问题与松弛操作（relaxation）"></a>9 最短路径问题与松弛操作（relaxation）</h4><p>松弛操作是最短路径问题的核心。</p>
<h4 id="10-dijkstra算法"><a href="#10-dijkstra算法" class="headerlink" title="10 dijkstra算法"></a>10 dijkstra算法</h4><p>前提：没有负权边。<br><img src="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%9B%BE%E8%AE%BA/10.png" alt="dijkstra算法"><br>如图所示，0到2的路径最短，因此0到2的最短路径可以确定为2。  </p>
<p><img src="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%9B%BE%E8%AE%BA/11.png" alt="dijkstra算法"><br>如图所示，2到1的距离是1，则0到1的最短距离更新为3，距离为5的边被废弃，这一操作为松弛操作。  </p>
<p>通过上述两种操作，可得到如下结果。<br><img src="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%9B%BE%E8%AE%BA/12.png" alt="dijkstra算法">   </p>
<h4 id="11-负权边与bellman-ford算法"><a href="#11-负权边与bellman-ford算法" class="headerlink" title="11 负权边与bellman-ford算法"></a>11 负权边与bellman-ford算法</h4><p>如果有负权环，则没有最短路径。<br>bellman-ford算法可解决负权边最短路径问题。<br>最短路径最多经过n个节点，否则就有负权环。<br>一个点的一次松弛操作就是找到经过这个点的另外一条路径，多一条边，权值更小。从一点到另外一点最多有n-1条边。对所有的点进行n-1次松弛操作，找到最短路径。如果n-1次松弛操作后还可以继续松弛，则有负权环。  </p>
<h4 id="12-拓扑排序"><a href="#12-拓扑排序" class="headerlink" title="12 拓扑排序"></a>12 拓扑排序</h4><p>用于有向无环图</p>
<h4 id="13-课程用到的算法思想"><a href="#13-课程用到的算法思想" class="headerlink" title="13 课程用到的算法思想"></a>13 课程用到的算法思想</h4><p><img src="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%9B%BE%E8%AE%BA/13.png" alt="总结">  </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%B9%B6%E6%9F%A5%E9%9B%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qk6665">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="welcome to qk6665'blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%B9%B6%E6%9F%A5%E9%9B%86/" class="post-title-link" itemprop="url">算法课程笔记-并查集</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-03-13 22:51:01 / 修改时间：23:41:17" itemprop="dateCreated datePublished" datetime="2020-03-13T22:51:01+08:00">2020-03-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p>用于解决连接问题<br><img src="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%B9%B6%E6%9F%A5%E9%9B%86/1.png" alt="并查集">  </p>
<h4 id="1-树结构并查集"><a href="#1-树结构并查集" class="headerlink" title="1 树结构并查集"></a>1 树结构并查集</h4><p>初始条件下所有结点都为根节点，根节点指向自己。连接时，将一节点的根节点指向另一节点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> UF2&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span>&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">// 使用一个数组构建一棵指向父节点的树</span></span><br><span class="line">        <span class="comment">// parent[i]表示第一个元素所指向的父节点</span></span><br><span class="line">        <span class="keyword">int</span>* parent;</span><br><span class="line">        <span class="keyword">int</span> count;  <span class="comment">// 数据个数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 构造函数</span></span><br><span class="line">        UnionFind(<span class="keyword">int</span> count)&#123;</span><br><span class="line">            parent = <span class="keyword">new</span> <span class="keyword">int</span>[count];</span><br><span class="line">            <span class="keyword">this</span>-&gt;count = count;</span><br><span class="line">            <span class="comment">// 初始化, 每一个parent[i]指向自己, 表示每一个元素自己自成一个集合</span></span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; count ; i ++ )</span><br><span class="line">                parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 析构函数</span></span><br><span class="line">        ~UnionFind()&#123;</span><br><span class="line">            <span class="keyword">delete</span>[] parent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找过程, 查找元素p所对应的集合编号</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">            assert( p &gt;= <span class="number">0</span> &amp;&amp; p &lt; count );</span><br><span class="line">            <span class="comment">// 不断去查询自己的父亲节点, 直到到达根节点</span></span><br><span class="line">            <span class="comment">// 根节点的特点: parent[p] == p</span></span><br><span class="line">            <span class="keyword">while</span>( p != parent[p] )</span><br><span class="line">                p = parent[p];</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查看元素p和元素q是否所属一个集合</span></span><br><span class="line">        <span class="comment">// O(h)复杂度, h为树的高度</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">isConnected</span><span class="params">( <span class="keyword">int</span> p , <span class="keyword">int</span> q )</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">find</span>(p) == <span class="built_in">find</span>(q);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并元素p和元素q所属的集合</span></span><br><span class="line">        <span class="comment">// O(h)复杂度, h为树的高度</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">unionElements</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> pRoot = <span class="built_in">find</span>(p);</span><br><span class="line">            <span class="keyword">int</span> qRoot = <span class="built_in">find</span>(q);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( pRoot == qRoot )</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-树结构层数优化并查集"><a href="#2-树结构层数优化并查集" class="headerlink" title="2 树结构层数优化并查集"></a>2 树结构层数优化并查集</h4><p>合并时将层数较少的集合指向层数较多的集合，减少树的总层数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> UF4&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span>&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span>* rank;   <span class="comment">// rank[i]表示以i为根的集合所表示的树的层数</span></span><br><span class="line">        <span class="keyword">int</span>* parent; <span class="comment">// parent[i]表示第i个元素所指向的父节点</span></span><br><span class="line">        <span class="keyword">int</span> count;   <span class="comment">// 数据个数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 构造函数</span></span><br><span class="line">        UnionFind(<span class="keyword">int</span> count)&#123;</span><br><span class="line">            parent = <span class="keyword">new</span> <span class="keyword">int</span>[count];</span><br><span class="line">            rank = <span class="keyword">new</span> <span class="keyword">int</span>[count];</span><br><span class="line">            <span class="keyword">this</span>-&gt;count = count;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; count ; i ++ )&#123;</span><br><span class="line">                parent[i] = i;</span><br><span class="line">                rank[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 析构函数</span></span><br><span class="line">        ~UnionFind()&#123;</span><br><span class="line">            <span class="keyword">delete</span>[] parent;</span><br><span class="line">            <span class="keyword">delete</span>[] rank;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找过程, 查找元素p所对应的集合编号</span></span><br><span class="line">        <span class="comment">// O(h)复杂度, h为树的高度</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">            assert( p &gt;= <span class="number">0</span> &amp;&amp; p &lt; count );</span><br><span class="line">            <span class="comment">// 不断去查询自己的父亲节点, 直到到达根节点</span></span><br><span class="line">            <span class="comment">// 根节点的特点: parent[p] == p</span></span><br><span class="line">            <span class="keyword">while</span>( p != parent[p] )</span><br><span class="line">                p = parent[p];</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查看元素p和元素q是否所属一个集合</span></span><br><span class="line">        <span class="comment">// O(h)复杂度, h为树的高度</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">isConnected</span><span class="params">( <span class="keyword">int</span> p , <span class="keyword">int</span> q )</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">find</span>(p) == <span class="built_in">find</span>(q);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并元素p和元素q所属的集合</span></span><br><span class="line">        <span class="comment">// O(h)复杂度, h为树的高度</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">unionElements</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> pRoot = <span class="built_in">find</span>(p);</span><br><span class="line">            <span class="keyword">int</span> qRoot = <span class="built_in">find</span>(q);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( pRoot == qRoot )</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根据两个元素所在树的元素个数不同判断合并方向</span></span><br><span class="line">            <span class="comment">// 将元素个数少的集合合并到元素个数多的集合上</span></span><br><span class="line">            <span class="keyword">if</span>( rank[pRoot] &lt; rank[qRoot] )&#123;</span><br><span class="line">                parent[pRoot] = qRoot;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>( rank[qRoot] &lt; rank[pRoot])&#123;</span><br><span class="line">                parent[qRoot] = pRoot;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123; <span class="comment">// rank[pRoot] == rank[qRoot]</span></span><br><span class="line">                parent[pRoot] = qRoot;</span><br><span class="line">                rank[qRoot] += <span class="number">1</span>;   <span class="comment">// 此时, 我维护rank的值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-路径压缩并查集"><a href="#3-路径压缩并查集" class="headerlink" title="3 路径压缩并查集"></a>3 路径压缩并查集</h4><p>查找根节点时将父节点指向父节点的父节点。<br><img src="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%B9%B6%E6%9F%A5%E9%9B%86/2.png" alt="路径压缩"> </p>
<pre><code class="c++"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span>

<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;

<span class="comment">// 我们的第五版Union-Find</span>
<span class="keyword">namespace</span> UF5{

    <span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span>{</span>

    <span class="keyword">private</span>:
        <span class="comment">// rank[i]表示以i为根的集合所表示的树的层数</span>
        <span class="comment">// 在后续的代码中, 我们并不会维护rank的语意, 也就是rank的值在路径压缩的过程中, 有可能不在是树的层数值</span>
        <span class="comment">// 这也是我们的rank不叫height或者depth的原因, 他只是作为比较的一个标准</span>
        <span class="comment">// 关于这个问题，可以参考问答区：http://coding.imooc.com/learn/questiondetail/7287.html</span>
        <span class="keyword">int</span>* rank;
        <span class="keyword">int</span>* parent; <span class="comment">// parent[i]表示第i个元素所指向的父节点</span>
        <span class="keyword">int</span> count;   <span class="comment">// 数据个数</span>

    <span class="keyword">public</span>:
        <span class="comment">// 构造函数</span>
        UnionFind(<span class="keyword">int</span> count){
            parent = <span class="keyword">new</span> <span class="keyword">int</span>[count];
            rank = <span class="keyword">new</span> <span class="keyword">int</span>[count];
            <span class="keyword">this</span>-&gt;count = count;
            <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; count ; i ++ ){
                parent[i] = i;
                rank[i] = <span class="number">1</span>;
            }
        }

        <span class="comment">// 析构函数</span>
        ~UnionFind(){
            <span class="keyword">delete</span>[] parent;
            <span class="keyword">delete</span>[] rank;
        }

        <span class="comment">// 查找过程, 查找元素p所对应的集合编号</span>
        <span class="comment">// O(h)复杂度, h为树的高度</span>
        <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>{
            assert( p &gt;= <span class="number">0</span> &amp;&amp; p &lt; count );

            <span class="comment">// path compression 1</span>
            <span class="keyword">while</span>( p != parent[p] ){
                parent[p] = parent[parent[p]];
                p = parent[p];
            }
            <span class="keyword">return</span> p;

            <span class="comment">// path compression 2, 递归算法</span>
<span class="comment">//            if( p != parent[p] )</span>
<span class="comment">//                parent[p] = find( parent[p] );</span>
<span class="comment">//            return parent[p];</span>
        }

        <span class="comment">// 查看元素p和元素q是否所属一个集合</span>
        <span class="comment">// O(h)复杂度, h为树的高度</span>
        <span class="function"><span class="keyword">bool</span> <span class="title">isConnected</span><span class="params">( <span class="keyword">int</span> p , <span class="keyword">int</span> q )</span></span>{
            <span class="keyword">return</span> find(p) == find(q);
        }

        <span class="comment">// 合并元素p和元素q所属的集合</span>
        <span class="comment">// O(h)复杂度, h为树的高度</span>
        <span class="function"><span class="keyword">void</span> <span class="title">unionElements</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>{

            <span class="keyword">int</span> pRoot = find(p);
            <span class="keyword">int</span> qRoot = find(q);

            <span class="keyword">if</span>( pRoot == qRoot )
                <span class="keyword">return</span>;

            <span class="comment">// 根据两个元素所在树的元素个数不同判断合并方向</span>
            <span class="comment">// 将元素个数少的集合合并到元素个数多的集合上</span>
            <span class="keyword">if</span>( rank[pRoot] &lt; rank[qRoot] ){
                parent[pRoot] = qRoot;
            }
            <span class="keyword">else</span> <span class="keyword">if</span>( rank[qRoot] &lt; rank[pRoot]){
                parent[qRoot] = pRoot;
            }
            <span class="keyword">else</span>{ <span class="comment">// rank[pRoot] == rank[qRoot]</span>
                parent[pRoot] = qRoot;
                rank[qRoot] += <span class="number">1</span>;   <span class="comment">// 此时, 我维护rank的值</span>
            }
        }
    };
}</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qk6665">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="welcome to qk6665'blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91/" class="post-title-link" itemprop="url">算法课程笔记-二分搜索树</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-03-13 18:30:27 / 修改时间：23:29:36" itemprop="dateCreated datePublished" datetime="2020-03-13T18:30:27+08:00">2020-03-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="二分搜索算法"><a href="#二分搜索算法" class="headerlink" title="二分搜索算法"></a>二分搜索算法</h1><p>用于解决查找问题</p>
<h4 id="1-二分查找法"><a href="#1-二分查找法" class="headerlink" title="1 二分查找法"></a>1 二分查找法</h4><p>只能在有序数组中查找</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分查找法,在有序数组arr中,查找target</span></span><br><span class="line"><span class="comment">// 如果找到target,返回相应的索引index</span></span><br><span class="line"><span class="comment">// 如果没有找到target,返回-1</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(T arr[], <span class="keyword">int</span> n, T target)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在arr[l...r]之中查找target</span></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>( l &lt;= r )&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//int mid = (l + r)/2;</span></span><br><span class="line">        <span class="comment">// 防止极端情况下的整形溢出，使用下面的逻辑求出mid</span></span><br><span class="line">        <span class="keyword">int</span> mid = l + (r-l)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( arr[mid] == target )</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( arr[mid] &gt; target )</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用递归的方式写二分查找法</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> __binarySearch2(T arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r, T target)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( l &gt; r )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//int mid = (l+r)/2;</span></span><br><span class="line">    <span class="comment">// 防止极端情况下的整形溢出，使用下面的逻辑求出mid</span></span><br><span class="line">    <span class="keyword">int</span> mid = l + (r-l)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( arr[mid] == target )</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( arr[mid] &gt; target )</span><br><span class="line">        <span class="keyword">return</span> __binarySearch2(arr, l, mid<span class="number">-1</span>, target);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> __binarySearch2(arr, mid+<span class="number">1</span>, r, target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch2</span><span class="params">(T arr[], <span class="keyword">int</span> n, T target)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> __binarySearch2( arr , <span class="number">0</span> , n<span class="number">-1</span>, target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较非递归和递归写法的二分查找的效率</span></span><br><span class="line"><span class="comment">// 非递归算法在性能上有微弱优势</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">1000000</span>;</span><br><span class="line">    <span class="keyword">int</span>* a = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++ )</span><br><span class="line">        a[i] = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试非递归二分查找法</span></span><br><span class="line">    <span class="keyword">clock_t</span> startTime = clock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于我们的待查找数组[0...N)</span></span><br><span class="line">    <span class="comment">// 对[0...N)区间的数值使用二分查找，最终结果应该就是数字本身</span></span><br><span class="line">    <span class="comment">// 对[N...2*N)区间的数值使用二分查找，因为这些数字不在arr中，结果为-1</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">2</span>*n ; i ++ )&#123;</span><br><span class="line">        <span class="keyword">int</span> v = binarySearch(a, n, i);</span><br><span class="line">        <span class="keyword">if</span>( i &lt; n )</span><br><span class="line">            assert( v == i );</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            assert( v == <span class="number">-1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">clock_t</span> endTime = clock();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Binary Search (Without Recursion): "</span> &lt;&lt; <span class="keyword">double</span>(endTime - startTime) / CLOCKS_PER_SEC &lt;&lt; <span class="string">" s"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试递归的二分查找法</span></span><br><span class="line">    startTime = clock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于我们的待查找数组[0...N)</span></span><br><span class="line">    <span class="comment">// 对[0...N)区间的数值使用二分查找，最终结果应该就是数字本身</span></span><br><span class="line">    <span class="comment">// 对[N...2*N)区间的数值使用二分查找，因为这些数字不在arr中，结果为-1</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">2</span>*n ; i ++ )&#123;</span><br><span class="line">        <span class="keyword">int</span> v = binarySearch2(a, n, i);</span><br><span class="line">        <span class="keyword">if</span>( i &lt; n )</span><br><span class="line">            assert( v == i );</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            assert( v == <span class="number">-1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    endTime = clock();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Binary Search (Recursion): "</span> &lt;&lt; <span class="keyword">double</span>(endTime - startTime) / CLOCKS_PER_SEC &lt;&lt; <span class="string">" s"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-O-n-2"><a href="#1-O-n-2" class="headerlink" title="1 O(n)2"></a>1 O(n)2</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++)&#123;</span><br><span class="line">    <span class="comment">// 寻找[i, n)区间里的最小值</span></span><br><span class="line">    <span class="keyword">int</span> minIndex = i;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> j = i + <span class="number">1</span> ; j &lt; n ; j ++ )</span><br><span class="line">        <span class="keyword">if</span>( arr[j] &lt; arr[minIndex] )</span><br><span class="line">            minIndex = j;</span><br><span class="line"></span><br><span class="line">    swap( arr[i] , arr[minIndex] );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-二分搜索树"><a href="#2-二分搜索树" class="headerlink" title="2 二分搜索树"></a>2 二分搜索树</h4><p>树适用于解决递归问题。<br><img src="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91/1.png" alt="二分搜索树1"><br><img src="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91/2.png" alt="二分搜索树2"><br>二分搜索树不一定是完全二叉树。<br>包括插入、查找、遍历、删除<br>前序遍历、中序遍历、后序遍历、层序遍历（使用队列）。<br><img src="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91/3.png" alt="删除节点"><br>删除节点的两边都有节点时，使用右节点二叉树的最小值代替该节点。</p>
<p>二分搜索树的局限性：同样的数据可能对应不同的树，树可能层数很高，退化为链表，但不如链表效率高。可以通过平衡二叉树解决。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分搜索树</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BST</span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 树中的节点为私有的结构体, 外界不需要了解二分搜索树节点的具体实现</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">        Key key;</span><br><span class="line">        Value value;</span><br><span class="line">        Node *left;</span><br><span class="line">        Node *right;</span><br><span class="line"></span><br><span class="line">        Node(Key key, Value value)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;key = key;</span><br><span class="line">            <span class="keyword">this</span>-&gt;value = value;</span><br><span class="line">            <span class="keyword">this</span>-&gt;left = <span class="keyword">this</span>-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node(Node *node)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;key = node-&gt;key;</span><br><span class="line">            <span class="keyword">this</span>-&gt;value = node-&gt;value;</span><br><span class="line">            <span class="keyword">this</span>-&gt;left = node-&gt;left;</span><br><span class="line">            <span class="keyword">this</span>-&gt;right = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Node *root; <span class="comment">// 根节点</span></span><br><span class="line">    <span class="keyword">int</span> count;  <span class="comment">// 树中的节点个数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数, 默认构造一棵空二分搜索树</span></span><br><span class="line">    BST()&#123;</span><br><span class="line">        root = <span class="literal">NULL</span>;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数, 释放二分搜索树的所有空间</span></span><br><span class="line">    ~BST()&#123;</span><br><span class="line">        destroy( root );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回二分搜索树的节点个数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回二分搜索树是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向二分搜索树中插入一个新的(key, value)数据对</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Key key, Value value)</span></span>&#123;</span><br><span class="line">        root = insert(root, key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看二分搜索树中是否存在键key</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">contain</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> contain(root, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在二分搜索树中搜索键key所对应的值。如果这个值不存在, 则返回NULL</span></span><br><span class="line">    <span class="function">Value* <span class="title">search</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> search( root , key );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二分搜索树的前序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        preOrder(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二分搜索树的中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        inOrder(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二分搜索树的后序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        postOrder(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二分搜索树的层序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span>&lt;Node*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>( !q.empty() )&#123;</span><br><span class="line"></span><br><span class="line">            Node *node = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line"></span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;node-&gt;key&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( node-&gt;left )</span><br><span class="line">                q.push( node-&gt;left );</span><br><span class="line">            <span class="keyword">if</span>( node-&gt;right )</span><br><span class="line">                q.push( node-&gt;right );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找二分搜索树的最小的键值</span></span><br><span class="line">    <span class="function">Key <span class="title">minimum</span><span class="params">()</span></span>&#123;</span><br><span class="line">        assert( count != <span class="number">0</span> );</span><br><span class="line">        Node* minNode = minimum( root );</span><br><span class="line">        <span class="keyword">return</span> minNode-&gt;key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找二分搜索树的最大的键值</span></span><br><span class="line">    <span class="function">Key <span class="title">maximum</span><span class="params">()</span></span>&#123;</span><br><span class="line">        assert( count != <span class="number">0</span> );</span><br><span class="line">        Node* maxNode = maximum(root);</span><br><span class="line">        <span class="keyword">return</span> maxNode-&gt;key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从二分搜索树中删除最小值所在节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeMin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( root )</span><br><span class="line">            root = removeMin( root );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从二分搜索树中删除最大值所在节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( root )</span><br><span class="line">            root = removeMax( root );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从二分搜索树中删除键值为key的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        root = <span class="built_in">remove</span>(root, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 向以node为根的二分搜索树中, 插入节点(key, value), 使用递归算法</span></span><br><span class="line">    <span class="comment">// 返回插入新节点后的二分搜索树的根</span></span><br><span class="line">    <span class="function">Node* <span class="title">insert</span><span class="params">(Node *node, Key key, Value value)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( node == <span class="literal">NULL</span> )&#123;</span><br><span class="line">            count ++;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Node(key, value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( key == node-&gt;key )</span><br><span class="line">            node-&gt;value = value;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( key &lt; node-&gt;key )</span><br><span class="line">            node-&gt;left = insert( node-&gt;left , key, value);</span><br><span class="line">        <span class="keyword">else</span>    <span class="comment">// key &gt; node-&gt;key</span></span><br><span class="line">            node-&gt;right = insert( node-&gt;right, key, value);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看以node为根的二分搜索树中是否包含键值为key的节点, 使用递归算法</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">contain</span><span class="params">(Node* node, Key key)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( node == <span class="literal">NULL</span> )</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( key == node-&gt;key )</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( key &lt; node-&gt;key )</span><br><span class="line">            <span class="keyword">return</span> contain( node-&gt;left , key );</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// key &gt; node-&gt;key</span></span><br><span class="line">            <span class="keyword">return</span> contain( node-&gt;right , key );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在以node为根的二分搜索树中查找key所对应的value, 递归算法</span></span><br><span class="line">    <span class="comment">// 若value不存在, 则返回NULL</span></span><br><span class="line">    <span class="function">Value* <span class="title">search</span><span class="params">(Node* node, Key key)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( node == <span class="literal">NULL</span> )</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( key == node-&gt;key )</span><br><span class="line">            <span class="keyword">return</span> &amp;(node-&gt;value);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( key &lt; node-&gt;key )</span><br><span class="line">            <span class="keyword">return</span> search( node-&gt;left , key );</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// key &gt; node-&gt;key</span></span><br><span class="line">            <span class="keyword">return</span> search( node-&gt;right, key );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对以node为根的二分搜索树进行前序遍历, 递归算法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node* node)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( node != <span class="literal">NULL</span> )&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;node-&gt;key&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            preOrder(node-&gt;left);</span><br><span class="line">            preOrder(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对以node为根的二分搜索树进行中序遍历, 递归算法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node* node)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( node != <span class="literal">NULL</span> )&#123;</span><br><span class="line">            inOrder(node-&gt;left);</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;node-&gt;key&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            inOrder(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对以node为根的二分搜索树进行后序遍历, 递归算法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Node* node)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( node != <span class="literal">NULL</span> )&#123;</span><br><span class="line">            postOrder(node-&gt;left);</span><br><span class="line">            postOrder(node-&gt;right);</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;node-&gt;key&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放以node为根的二分搜索树的所有节点</span></span><br><span class="line">    <span class="comment">// 采用后续遍历的递归算法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(Node* node)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( node != <span class="literal">NULL</span> )&#123;</span><br><span class="line">            destroy( node-&gt;left );</span><br><span class="line">            destroy( node-&gt;right );</span><br><span class="line"></span><br><span class="line">            <span class="keyword">delete</span> node;</span><br><span class="line">            count --;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回以node为根的二分搜索树的最小键值所在的节点, 递归算法</span></span><br><span class="line">    <span class="function">Node* <span class="title">minimum</span><span class="params">(Node* node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( node-&gt;left == <span class="literal">NULL</span> )</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> minimum(node-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回以node为根的二分搜索树的最大键值所在的节点, 递归算法</span></span><br><span class="line">    <span class="function">Node* <span class="title">maximum</span><span class="params">(Node* node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( node-&gt;right == <span class="literal">NULL</span> )</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maximum(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除掉以node为根的二分搜索树中的最小节点, 递归算法</span></span><br><span class="line">    <span class="comment">// 返回删除节点后新的二分搜索树的根</span></span><br><span class="line">    <span class="function">Node* <span class="title">removeMin</span><span class="params">(Node* node)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( node-&gt;left == <span class="literal">NULL</span> )&#123;</span><br><span class="line"></span><br><span class="line">            Node* rightNode = node-&gt;right;</span><br><span class="line">            <span class="keyword">delete</span> node;</span><br><span class="line">            count --;</span><br><span class="line">            <span class="keyword">return</span> rightNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node-&gt;left = removeMin(node-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除掉以node为根的二分搜索树中的最大节点, 递归算法</span></span><br><span class="line">    <span class="comment">// 返回删除节点后新的二分搜索树的根</span></span><br><span class="line">    <span class="function">Node* <span class="title">removeMax</span><span class="params">(Node* node)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( node-&gt;right == <span class="literal">NULL</span> )&#123;</span><br><span class="line"></span><br><span class="line">            Node* leftNode = node-&gt;left;</span><br><span class="line">            <span class="keyword">delete</span> node;</span><br><span class="line">            count --;</span><br><span class="line">            <span class="keyword">return</span> leftNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node-&gt;right = removeMax(node-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除掉以node为根的二分搜索树中键值为key的节点, 递归算法</span></span><br><span class="line">    <span class="comment">// 返回删除节点后新的二分搜索树的根</span></span><br><span class="line">    <span class="function">Node* <span class="title">remove</span><span class="params">(Node* node, Key key)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( node == <span class="literal">NULL</span> )</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( key &lt; node-&gt;key )&#123;</span><br><span class="line">            node-&gt;left = <span class="built_in">remove</span>( node-&gt;left , key );</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( key &gt; node-&gt;key )&#123;</span><br><span class="line">            node-&gt;right = <span class="built_in">remove</span>( node-&gt;right, key );</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;   <span class="comment">// key == node-&gt;key</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 待删除节点左子树为空的情况</span></span><br><span class="line">            <span class="keyword">if</span>( node-&gt;left == <span class="literal">NULL</span> )&#123;</span><br><span class="line">                Node *rightNode = node-&gt;right;</span><br><span class="line">                <span class="keyword">delete</span> node;</span><br><span class="line">                count --;</span><br><span class="line">                <span class="keyword">return</span> rightNode;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 待删除节点右子树为空的情况</span></span><br><span class="line">            <span class="keyword">if</span>( node-&gt;right == <span class="literal">NULL</span> )&#123;</span><br><span class="line">                Node *leftNode = node-&gt;left;</span><br><span class="line">                <span class="keyword">delete</span> node;</span><br><span class="line">                count--;</span><br><span class="line">                <span class="keyword">return</span> leftNode;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 待删除节点左右子树均不为空的情况</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 找到比待删除节点大的最小节点, 即待删除节点右子树的最小节点</span></span><br><span class="line">            <span class="comment">// 用这个节点顶替待删除节点的位置</span></span><br><span class="line">            Node *successor = <span class="keyword">new</span> Node(minimum(node-&gt;right));</span><br><span class="line">            count ++;</span><br><span class="line"></span><br><span class="line">            successor-&gt;right = removeMin(node-&gt;right);</span><br><span class="line">            successor-&gt;left = node-&gt;left;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">delete</span> node;</span><br><span class="line">            count --;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> successor;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shuffle</span><span class="params">( <span class="keyword">int</span> arr[], <span class="keyword">int</span> n )</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    srand( time(<span class="literal">NULL</span>) );</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = n<span class="number">-1</span> ; i &gt;= <span class="number">0</span> ; i -- )&#123;</span><br><span class="line">        <span class="keyword">int</span> x = rand()%(i+<span class="number">1</span>);</span><br><span class="line">        swap( arr[i] , arr[x] );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试 remove</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    BST&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; bst = BST&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取n个取值范围在[0...n)的随机整数放进二分搜索树中</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++ )&#123;</span><br><span class="line">        <span class="keyword">int</span> key = rand()%n;</span><br><span class="line">        <span class="comment">// 为了后续测试方便,这里value值取和key值一样</span></span><br><span class="line">        <span class="keyword">int</span> value = key;</span><br><span class="line">        bst.insert(key,value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意, 由于随机生成的数据有重复, 所以bst中的数据数量大概率是小于n的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// order数组中存放[0...n)的所有元素</span></span><br><span class="line">    <span class="keyword">int</span> order[n];</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++ )</span><br><span class="line">        order[i] = i;</span><br><span class="line">    <span class="comment">// 打乱order数组的顺序</span></span><br><span class="line">    shuffle( order , n );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 乱序删除[0...n)范围里的所有元素</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++ )</span><br><span class="line">        <span class="keyword">if</span>( bst.contain( order[i] ))&#123;</span><br><span class="line">            bst.<span class="built_in">remove</span>( order[i] );</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"After remove "</span>&lt;&lt;order[i]&lt;&lt;<span class="string">" size = "</span>&lt;&lt;bst.<span class="built_in">size</span>()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最终整个二分搜索树应该为空</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; bst.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qk6665">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="welcome to qk6665'blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">数据结构课程笔记</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-27 22:23:52" itemprop="dateCreated datePublished" datetime="2020-02-27T22:23:52+08:00">2020-02-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-02 23:37:42" itemprop="dateModified" datetime="2020-03-02T23:37:42+08:00">2020-03-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h3><h4 id="1-最大子列和问题"><a href="#1-最大子列和问题" class="headerlink" title="1 最大子列和问题"></a>1 最大子列和问题</h4><p>给定K个整数组成的序列{ N1, N2, …, NK }，“连续子列”被定义为{ Ni, Ni+1, …, Nj }，其中 1≤i≤j≤K。“最大子列和”则被定义为所有连续子列元素的和中最大者。例如给定序列{ -2, 11, -4, 13, -5, -2 }，其连续子列{ 11, -4, 13 }有最大的和20。现要求你编写程序，计算给定整数序列的最大子列和。</p>
<p>输入格式:<br>输入第1行给出正整数K (≤100000)；第2行给出K个整数，其间以空格分隔。<br>输入样例：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">-2</span> <span class="number">11</span> <span class="number">-4</span> <span class="number">13</span> <span class="number">-5</span> <span class="number">-2</span></span><br></pre></td></tr></table></figure>

<p>输出格式:<br>在一行中输出最大子列和。如果序列中所有整数皆为负数，则输出0。<br>输出样例：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result=<span class="number">0</span>,thissum=<span class="number">0</span>,N,digit;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;N);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;digit);</span><br><span class="line">        thissum+=digit;</span><br><span class="line">        <span class="keyword">if</span>(thissum&gt;result)</span><br><span class="line">            result=thissum;</span><br><span class="line">        <span class="keyword">if</span>(thissum&lt;<span class="number">0</span>)   thissum=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-最大子列和问题"><a href="#2-最大子列和问题" class="headerlink" title="2 最大子列和问题"></a>2 最大子列和问题</h4><p>给定K个整数组成的序列{ N1, N2, …, NK }，“连续子列”被定义为{ Ni, Ni+1, …, Nj }，其中 1≤i≤j≤K。“最大子列和”则被定义为所有连续子列元素的和中最大者。例如给定序列{ -2, 11, -4, 13, -5, -2 }，其连续子列{ 11, -4, 13 }有最大的和20。现要求你编写程序，计算给定整数序列的最大子列和，并输出整个序列的第一个和最后一个数。</p>
<p>输入格式:<br>输入第1行给出正整数K (≤100000)；第2行给出K个整数，其间以空格分隔。<br>输入样例：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">-10</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">-5</span> <span class="number">-23</span> <span class="number">3</span> <span class="number">7</span> <span class="number">-21</span></span><br></pre></td></tr></table></figure>

<p>输出格式:<br>对于每个测试用例，在一行中输出最大和，以及最大子序列的第一个和最后一个数字。数字必须用一个空格隔开，但行尾不能有多余的空格。如果最大子序列不唯一，则输出索引i和j最小的子序列（如示例所示）。如果所有K个数都是负数，那么它的最大和被定义为0，你应该输出整个序列的第一个和最后一个数。<br>输出样例：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> <span class="number">1</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>, thissum = <span class="number">0</span>, N, digit, startnew = <span class="number">0</span>, start = <span class="number">0</span>, <span class="built_in">end</span>, trigger = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N)) &#123;&#125;;</span><br><span class="line">    <span class="built_in">end</span> = N <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;digit)) &#123;&#125;;</span><br><span class="line">        thissum += digit;</span><br><span class="line">        <span class="keyword">if</span> (thissum &gt; result) &#123;</span><br><span class="line">            <span class="keyword">if</span> (trigger == <span class="number">1</span>) &#123;</span><br><span class="line">                trigger = <span class="number">0</span>;</span><br><span class="line">                start = digit;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">end</span> = digit;</span><br><span class="line">            result = thissum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (thissum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            trigger = <span class="number">1</span>;</span><br><span class="line">            thissum = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>, result, start, <span class="built_in">end</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第二章-线性结构"><a href="#第二章-线性结构" class="headerlink" title="第二章 线性结构"></a>第二章 线性结构</h3><h4 id="1-一元多项式的乘法与加法运算"><a href="#1-一元多项式的乘法与加法运算" class="headerlink" title="1 一元多项式的乘法与加法运算"></a>1 一元多项式的乘法与加法运算</h4><p>设计函数分别求两个一元多项式的乘积与和。</p>
<p>输入格式:<br>输入分2行，每行分别先给出多项式非零项的个数，再以指数递降方式输入一个多项式非零项系数和指数（绝对值均为不超过1000的整数）。数字间以空格分隔。<br>输入样例：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">3</span> <span class="number">4</span> <span class="number">-5</span> <span class="number">2</span>  <span class="number">6</span> <span class="number">1</span>  <span class="number">-2</span> <span class="number">0</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">20</span>  <span class="number">-7</span> <span class="number">4</span>  <span class="number">3</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>输出格式:<br>输出分2行，分别以指数递降方式输出乘积多项式以及和多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。零多项式应输出0 0。<br>输出样例：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">15</span> <span class="number">24</span> <span class="number">-25</span> <span class="number">22</span> <span class="number">30</span> <span class="number">21</span> <span class="number">-10</span> <span class="number">20</span> <span class="number">-21</span> <span class="number">8</span> <span class="number">35</span> <span class="number">6</span> <span class="number">-33</span> <span class="number">5</span> <span class="number">14</span> <span class="number">4</span> <span class="number">-15</span> <span class="number">3</span> <span class="number">18</span> <span class="number">2</span> <span class="number">-6</span> <span class="number">1</span></span><br><span class="line"><span class="number">5</span> <span class="number">20</span> <span class="number">-4</span> <span class="number">4</span> <span class="number">-5</span> <span class="number">2</span> <span class="number">9</span> <span class="number">1</span> <span class="number">-2</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PolyNode</span> *<span class="title">Polynomial</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PolyNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> coef;</span><br><span class="line">    <span class="keyword">int</span> expon;</span><br><span class="line">    Polynomial link;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Attach</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> e, Polynomial* pRear)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Polynomial P;</span><br><span class="line"></span><br><span class="line">    P = (Polynomial)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct PolyNode));</span><br><span class="line">    P-&gt;coef = c;</span><br><span class="line">    P-&gt;expon = e;</span><br><span class="line">    P-&gt;link = <span class="literal">NULL</span>;</span><br><span class="line">    (*pRear)-&gt;link = P;</span><br><span class="line">    *pRear = P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Polynomial <span class="title">ReadPoly</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Polynomial P, Rear, t;</span><br><span class="line">    <span class="keyword">int</span> c, e, N;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">    P = (Polynomial)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct PolyNode)); <span class="comment">//表头空结点</span></span><br><span class="line">    P-&gt;link = <span class="literal">NULL</span>;</span><br><span class="line">    Rear = P;</span><br><span class="line">    <span class="keyword">while</span> (N--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;c, &amp;e);</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="number">0</span>)       </span><br><span class="line">            Attach(c, e, &amp;Rear);    <span class="comment">//当前项插入尾部</span></span><br><span class="line">    &#125;</span><br><span class="line">    t = P; P = P-&gt;link; <span class="built_in">free</span>(t);  <span class="comment">//删除临时头结点</span></span><br><span class="line">    <span class="keyword">return</span> P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Compare</span><span class="params">(<span class="keyword">int</span> e1, <span class="keyword">int</span> e2)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/*比较两项指数e1和e2，根据大、小、等三种情况分别返回1，-1，0 */</span></span><br><span class="line">    <span class="keyword">if</span> (e1 &gt; e2) <span class="keyword">return</span> <span class="number">1</span>;       <span class="comment">/* e1大，返回1       */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (e1 &lt; e2) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">/* e2大，返回-1      */</span></span><br><span class="line">    <span class="keyword">else</span>  <span class="keyword">return</span> <span class="number">0</span>;                <span class="comment">/* e1和e2相等，返回0 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Polynomial <span class="title">Add</span><span class="params">(Polynomial P1, Polynomial P2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Polynomial front, rear, temp;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    rear = (Polynomial)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct PolyNode));</span><br><span class="line">    front = rear;</span><br><span class="line">    <span class="keyword">while</span> (P1 &amp;&amp; P2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (Compare(P1-&gt;expon, P2-&gt;expon))</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            Attach(P1-&gt;coef, P1-&gt;expon, &amp;rear);</span><br><span class="line">            P1 = P1-&gt;link;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">            Attach(P2-&gt;coef, P2-&gt;expon, &amp;rear);</span><br><span class="line">            P2 = P2-&gt;link;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            sum = P1-&gt;coef + P2-&gt;coef;</span><br><span class="line">            <span class="keyword">if</span> (sum) Attach(sum, P1-&gt;expon, &amp;rear);</span><br><span class="line">            P1 = P1-&gt;link;</span><br><span class="line">            P2 = P2-&gt;link;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; P1; P1 = P1-&gt;link) Attach(P1-&gt;coef, P1-&gt;expon, &amp;rear);</span><br><span class="line">    <span class="keyword">for</span> (; P2; P2 = P2-&gt;link) Attach(P2-&gt;coef, P2-&gt;expon, &amp;rear);</span><br><span class="line">    rear-&gt;link = <span class="literal">NULL</span>;</span><br><span class="line">    temp = front;</span><br><span class="line">    front = front-&gt;link;</span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">    <span class="keyword">return</span> front;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Polynomial <span class="title">Mult</span><span class="params">(Polynomial P1, Polynomial P2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Polynomial P, Rear, t1, t2, t;</span><br><span class="line">    <span class="keyword">int</span> c, e;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!P1 || !P2) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    t1 = P1; t2 = P2;</span><br><span class="line">    P = (Polynomial)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct PolyNode)); P-&gt;link = <span class="literal">NULL</span>;</span><br><span class="line">    Rear = P;</span><br><span class="line">    <span class="keyword">while</span> (t2)   <span class="comment">//先使用P1第一项乘P2得到初始链表</span></span><br><span class="line">    &#123;</span><br><span class="line">        Attach(t1-&gt;coef * t2-&gt;coef, t1-&gt;expon + t2-&gt;expon, &amp;Rear);</span><br><span class="line">        t2 = t2-&gt;link;</span><br><span class="line">    &#125;</span><br><span class="line">    t1 = t1-&gt;link;</span><br><span class="line">    <span class="keyword">while</span> (t1)</span><br><span class="line">    &#123;</span><br><span class="line">        t2 = P2; Rear = P;</span><br><span class="line">        <span class="keyword">while</span> (t2)</span><br><span class="line">        &#123;</span><br><span class="line">            e = t1-&gt;expon + t2-&gt;expon;</span><br><span class="line">            c = t1-&gt;coef * t2-&gt;coef;</span><br><span class="line">            <span class="keyword">while</span> (Rear-&gt;link &amp;&amp; Rear-&gt;link-&gt;expon &gt; e)</span><br><span class="line">                Rear = Rear-&gt;link;</span><br><span class="line">            <span class="keyword">if</span> (Rear-&gt;link &amp;&amp; Rear-&gt;link-&gt;expon == e)  <span class="comment">//与下一个相等</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (Rear-&gt;link-&gt;coef + c)</span><br><span class="line">                    Rear-&gt;link-&gt;coef += c;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    t = Rear-&gt;link;</span><br><span class="line">                    Rear-&gt;link = t-&gt;link;</span><br><span class="line">                    <span class="built_in">free</span>(t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>                                <span class="comment">//比下一个大</span></span><br><span class="line">            &#123;</span><br><span class="line">                t = (Polynomial)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct PolyNode));</span><br><span class="line">                t-&gt;coef = c; t-&gt;expon = e; t-&gt;link = Rear-&gt;link;</span><br><span class="line">                Rear-&gt;link = t; Rear = Rear-&gt;link;</span><br><span class="line">            &#125;</span><br><span class="line">            t2 = t2-&gt;link;</span><br><span class="line">        &#125;</span><br><span class="line">        t1 = t1-&gt;link;</span><br><span class="line">    &#125;</span><br><span class="line">    t2 = P; P = P-&gt;link; <span class="built_in">free</span>(t2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintPoly</span><span class="params">(Polynomial P)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c, e, flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!P) &#123; <span class="built_in">printf</span>(<span class="string">"0 0"</span>); <span class="keyword">return</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (P)</span><br><span class="line">    &#123;</span><br><span class="line">        c = P-&gt;coef; e = P-&gt;expon;</span><br><span class="line">        <span class="keyword">if</span> (!flag)</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d"</span>, c, e);</span><br><span class="line">        P = P-&gt;link;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Polynomial P1, P2, PP, PS;</span><br><span class="line"></span><br><span class="line">    P1 = ReadPoly();</span><br><span class="line">    P2 = ReadPoly();</span><br><span class="line">    PP = Mult(P1, P2);</span><br><span class="line">    PrintPoly(PP);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    PS = Add(P1, P2);</span><br><span class="line">    PrintPoly(PS);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-两个有序链表序列的合并"><a href="#2-两个有序链表序列的合并" class="headerlink" title="2 两个有序链表序列的合并"></a>2 两个有序链表序列的合并</h4><p>本题要求实现一个函数，将两个链表表示的递增整数序列合并为一个非递减的整数序列。<br>L1和L2是给定的带头结点的单链表，其结点存储的数据是递增有序的；函数Merge要将L1和L2合并为一个非递减的整数序列。应直接使用原序列中的结点，返回归并后的带头结点的链表头指针。</p>
<p>输入样例：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">6</span> <span class="number">8</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>输出样例：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">8</span> <span class="number">10</span> </span><br><span class="line"><span class="literal">NULL</span></span><br><span class="line"><span class="literal">NULL</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">PtrToNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    PtrToNode   Next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToNode List;</span><br><span class="line"></span><br><span class="line"><span class="function">List <span class="title">Read</span><span class="params">()</span></span>; <span class="comment">/* 细节在此不表 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(List L)</span></span>; <span class="comment">/* 细节在此不表；空链表将输出NULL */</span></span><br><span class="line"></span><br><span class="line"><span class="function">List <span class="title">Merge</span><span class="params">(List L1, List L2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List L1, L2, L;</span><br><span class="line">    L1 = Read();</span><br><span class="line">    L2 = Read();</span><br><span class="line">    L = Merge(L1, L2);</span><br><span class="line">    Print(L);</span><br><span class="line">    Print(L1);</span><br><span class="line">    Print(L2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Attach</span><span class="params">(<span class="keyword">int</span> d, List* pRear)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List P;</span><br><span class="line"></span><br><span class="line">    P = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Node));</span><br><span class="line">    P-&gt;Data = d;</span><br><span class="line">    P-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    (*pRear)-&gt;Next = P;</span><br><span class="line">    *pRear = P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">List <span class="title">Merge</span><span class="params">(List L1, List L2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List temp1 = L1-&gt;Next;</span><br><span class="line">    List temp2 = L2-&gt;Next;</span><br><span class="line">    List p;</span><br><span class="line">    p = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Node));</span><br><span class="line">    p-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    List temp = p;</span><br><span class="line">    <span class="keyword">while</span> (temp1 &amp;&amp; temp2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (temp1-&gt;Data &lt; temp2-&gt;Data) &#123;</span><br><span class="line">            temp-&gt;Next = temp1;</span><br><span class="line">            temp1 = temp1-&gt;Next;</span><br><span class="line">            temp = temp-&gt;Next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            temp-&gt;Next = temp2;</span><br><span class="line">            temp2 = temp2-&gt;Next;</span><br><span class="line">            temp = temp-&gt;Next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (temp1 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        temp-&gt;Next = temp1;</span><br><span class="line">        temp1 = temp1-&gt;Next;</span><br><span class="line">        temp = temp-&gt;Next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (temp2 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        temp-&gt;Next = temp2;</span><br><span class="line">        temp2 = temp2-&gt;Next;</span><br><span class="line">        temp = temp-&gt;Next;</span><br><span class="line">    &#125;</span><br><span class="line">    L1-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    L2-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    temp-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">List <span class="title">Read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List P, Rear, t;</span><br><span class="line">    <span class="keyword">int</span> d, N;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">    P = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Node)); <span class="comment">//表头空结点</span></span><br><span class="line">    P-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    Rear = P;</span><br><span class="line">    <span class="keyword">while</span> (N--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;d);</span><br><span class="line">        Attach(d, &amp;Rear);    <span class="comment">//当前项插入尾部</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(List L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L-&gt;Next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"NULL\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    List temp = L-&gt;Next;</span><br><span class="line">    <span class="keyword">while</span> (temp) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, temp-&gt;Data);</span><br><span class="line">        temp = temp-&gt;Next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-Pop-Sequence"><a href="#3-Pop-Sequence" class="headerlink" title="3 Pop Sequence"></a>3 Pop Sequence</h4><p>给定一个最多能保存M个数的堆栈。按1，2，3，…，N的顺序推N个数字，然后随机弹出。您应该知道给定的数字序列是否可能是堆栈的弹出序列。例如，如果M是5，N是7，我们可以从堆栈中获得1，2，3，4，5，6，7，但不能从3，2，1，7，5，6，4。</p>
<p>输入格式:<br>每个输入文件包含一个测试用例。对于每种情况，第一行包含3个数字（都不超过1000）：M（堆栈的最大容量）、N（推送序列的长度）和K（要检查的pop序列的数量）。接下来是K行，每行包含N个数字的pop序列。一行中的所有数字都用空格隔开。<br>输入样例：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">7</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">7</span> <span class="number">5</span> <span class="number">6</span> <span class="number">4</span></span><br><span class="line"><span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">5</span> <span class="number">6</span> <span class="number">4</span> <span class="number">3</span> <span class="number">7</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>输出格式:<br>对于每个弹出序列，如果确实是堆栈的可能弹出序列，则在一行中打印“YES”，如果不是，则打印“NO”。<br>输出样例：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">YES</span><br><span class="line">NO</span><br><span class="line">NO</span><br><span class="line">YES</span><br><span class="line">NO</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, m, n, k, a[<span class="number">1000</span>][<span class="number">1000</span>], b[<span class="number">1000</span>], <span class="built_in">stack</span>[<span class="number">1000</span>], stack_index, top;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;m, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)    <span class="comment">//读取每一行</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i][j]);                   </span><br><span class="line">        &#125;</span><br><span class="line">        stack_index = <span class="number">1</span>;      <span class="comment">//模拟栈</span></span><br><span class="line">        top = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">stack</span>[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (a[i][j] &gt; top)</span><br><span class="line">            &#123;</span><br><span class="line">                stack_index++;</span><br><span class="line">                top++;</span><br><span class="line">                <span class="built_in">stack</span>[stack_index] = top;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (stack_index &gt; m || a[i][j] &lt; <span class="built_in">stack</span>[stack_index])</span><br><span class="line">            &#123;</span><br><span class="line">                b[i] = <span class="number">0</span>;       <span class="comment">//无法实现栈则结果为0，退出</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a[i][j] == <span class="built_in">stack</span>[stack_index])</span><br><span class="line">            &#123;</span><br><span class="line">                stack_index--;</span><br><span class="line">                <span class="comment">//top = stack[stack_index];</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stack_index == <span class="number">0</span>)   <span class="comment">//成功实现栈则结果为1</span></span><br><span class="line">            b[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b[i] == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"NO"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (b[i] == <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"YES"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第三章-树结构（上）"><a href="#第三章-树结构（上）" class="headerlink" title="第三章 树结构（上）"></a>第三章 树结构（上）</h3><h4 id="1-树的同构"><a href="#1-树的同构" class="headerlink" title="1 树的同构"></a>1 树的同构</h4><p>给定两棵树T1和T2。如果T1可以通过若干次左右孩子互换就变成T2，则我们称两棵树是“同构”的。例如图1给出的两棵树就是同构的，因为我们把其中一棵树的结点A、B、G的左右孩子互换后，就得到另外一棵树。而图2就不是同构的。</p>
<p><img src="/2020/02/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/1.png" alt="1"><br>图1<br><img src="/2020/02/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/2.png" alt="2"><br>图2<br>输入格式:<br>输入给出2棵二叉树树的信息。对于每棵树，首先在一行中给出一个非负整数N (≤10)，即该树的结点数（此时假设结点从0到N−1编号）；随后N行，第i行对应编号第i个结点，给出该结点中存储的1个英文大写字母、其左孩子结点的编号、右孩子结点的编号。如果孩子结点为空，则在相应位置上给出“-”。给出的数据间用一个空格分隔。注意：题目保证每个结点中存储的字母是不同的。  </p>
<p>输出格式:<br>如果两棵树是同构的，输出“Yes”，否则输出“No”。</p>
<p>输入样例1（对应图1）：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span></span><br><span class="line">A <span class="number">1</span> <span class="number">2</span></span><br><span class="line">B <span class="number">3</span> <span class="number">4</span></span><br><span class="line">C <span class="number">5</span> -</span><br><span class="line">D - -</span><br><span class="line">E <span class="number">6</span> -</span><br><span class="line">G <span class="number">7</span> -</span><br><span class="line">F - -</span><br><span class="line">H - -</span><br><span class="line"><span class="number">8</span></span><br><span class="line">G - <span class="number">4</span></span><br><span class="line">B <span class="number">7</span> <span class="number">6</span></span><br><span class="line">F - -</span><br><span class="line">A <span class="number">5</span> <span class="number">1</span></span><br><span class="line">H - -</span><br><span class="line">C <span class="number">0</span> -</span><br><span class="line">D - -</span><br><span class="line">E <span class="number">2</span> -</span><br></pre></td></tr></table></figure>

<p>输出样例1（对应图1）：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br></pre></td></tr></table></figure>

<p>输入样例2（对应图2）：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span></span><br><span class="line">B <span class="number">5</span> <span class="number">7</span></span><br><span class="line">F - -</span><br><span class="line">A <span class="number">0</span> <span class="number">3</span></span><br><span class="line">C <span class="number">6</span> -</span><br><span class="line">H - -</span><br><span class="line">D - -</span><br><span class="line">G <span class="number">4</span> -</span><br><span class="line">E <span class="number">1</span> -</span><br><span class="line"><span class="number">8</span></span><br><span class="line">D <span class="number">6</span> -</span><br><span class="line">B <span class="number">5</span> -</span><br><span class="line">E - -</span><br><span class="line">H - -</span><br><span class="line">C <span class="number">0</span> <span class="number">2</span></span><br><span class="line">G - <span class="number">3</span></span><br><span class="line">F - -</span><br><span class="line">A <span class="number">1</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>输出样例2（对应图2）：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    String val;</span><br><span class="line">    <span class="keyword">int</span> left;</span><br><span class="line">    <span class="keyword">int</span> right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> TreeNode[] T1 = <span class="keyword">new</span> TreeNode[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> TreeNode[] T2 = <span class="keyword">new</span> TreeNode[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] check = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> T = scan.nextInt();</span><br><span class="line">        Arrays.fill(check, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T; i++) &#123;</span><br><span class="line">            T1[i] = <span class="keyword">new</span> TreeNode();</span><br><span class="line">            T1[i].val = scan.next();</span><br><span class="line">            String left = scan.next();</span><br><span class="line">            String right = scan.next();</span><br><span class="line">            <span class="keyword">if</span> (left.equals(<span class="string">"-"</span>)) &#123;</span><br><span class="line">                T1[i].left = -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                T1[i].left = Integer.parseInt(left);</span><br><span class="line">                check[Integer.parseInt(left)] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (right.equals(<span class="string">"-"</span>)) &#123;</span><br><span class="line">                T1[i].right = -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                T1[i].right = Integer.parseInt(right);</span><br><span class="line">                check[Integer.parseInt(right)] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> root = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (check[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                root = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        T = scan.nextInt();</span><br><span class="line">        Arrays.fill(check, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T; i++) &#123;</span><br><span class="line">            T2[i] = <span class="keyword">new</span> TreeNode();</span><br><span class="line">            T2[i].val = scan.next();</span><br><span class="line">            String left = scan.next();</span><br><span class="line">            String right = scan.next();</span><br><span class="line">            <span class="keyword">if</span> (left.equals(<span class="string">"-"</span>)) &#123;</span><br><span class="line">                T2[i].left = -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                T2[i].left = Integer.parseInt(left);</span><br><span class="line">                check[Integer.parseInt(left)] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (right.equals(<span class="string">"-"</span>)) &#123;</span><br><span class="line">                T2[i].right = -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                T2[i].right = Integer.parseInt(right);</span><br><span class="line">                check[Integer.parseInt(right)] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> root1 = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (check[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                root1 = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Isomorphic(root, root1) ? <span class="string">"Yes"</span> : <span class="string">"No"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//传递进来root的索引值可以避免数组越界</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">Isomorphic</span><span class="params">(<span class="keyword">int</span> node1, <span class="keyword">int</span> node2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node1 == -<span class="number">1</span> &amp;&amp; node2 == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((node1 == -<span class="number">1</span> &amp;&amp; node2 != -<span class="number">1</span>) || (node1 != -<span class="number">1</span> &amp;&amp; node2 == -<span class="number">1</span>) || (!T1[node1].val.equals(T2[node2].val))) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (T1[node1].left == -<span class="number">1</span> &amp;&amp; T2[node2].left == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Isomorphic(T1[node1].right, T2[node2].right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((T1[node1].left != -<span class="number">1</span> &amp;&amp; T2[node2].left != -<span class="number">1</span>) &amp;&amp; T1[T1[node1].left].val.equals(T2[T2[node2].left].val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> (Isomorphic(T1[node1].left, T2[node2].left) &amp;&amp; Isomorphic(T1[node1].right, T2[node2].right));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Isomorphic(T1[node1].left, T2[node2].right) &amp;&amp; Isomorphic(T1[node1].right, T2[node2].left));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-List-Leaves"><a href="#2-List-Leaves" class="headerlink" title="2 List Leaves"></a>2 List Leaves</h4><p>给定一棵树，您应该按照从上到下，从左到右的顺序列出所有叶子。</p>
<p>输入格式:<br>每个输入文件包含一个测试用例。对于每种情况，第一行给出一个正整数N（≤ 1 0），这是树中的节点的总数-并且因此节点编号从0到N − 1。然后N行跟随，每行对应一个节点，并给出该节点的左，右子级的索引。如果孩子不存在，将在该位置放置一个“-”。任何一对孩子都用空格隔开。</p>
<p>输出格式:<br>对于每个测试用例，按从上到下，从左到右的顺序在一行中打印所有叶子的索引。相邻数字之间必须恰好有一个空格，并且在行尾不能有多余的空格。</p>
<p>输入样例：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">1</span> -</span><br><span class="line">- -</span><br><span class="line"><span class="number">0</span> -</span><br><span class="line"><span class="number">2</span> <span class="number">7</span></span><br><span class="line">- -</span><br><span class="line">- -</span><br><span class="line"><span class="number">5</span> -</span><br><span class="line"><span class="number">4</span> <span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>输出样例：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">1</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left;</span><br><span class="line">    <span class="keyword">int</span> right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> TreeNode[] tree = <span class="keyword">new</span> TreeNode[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] check = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> T = scan.nextInt();</span><br><span class="line">        Arrays.fill(check, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T; i++) &#123;</span><br><span class="line">            tree[i] = <span class="keyword">new</span> TreeNode();</span><br><span class="line">            String left = scan.next();</span><br><span class="line">            String right = scan.next();</span><br><span class="line">            <span class="keyword">if</span> (left.equals(<span class="string">"-"</span>)) &#123;</span><br><span class="line">                tree[i].left = -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tree[i].left = Integer.parseInt(left);</span><br><span class="line">                check[Integer.parseInt(left)] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (right.equals(<span class="string">"-"</span>)) &#123;</span><br><span class="line">                tree[i].right = -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tree[i].right = Integer.parseInt(right);</span><br><span class="line">                check[Integer.parseInt(right)] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> root = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (check[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                root = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printLeaves(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printLeaves</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tree[node].left != -<span class="number">1</span>) &#123;</span><br><span class="line">            queue.offer(tree[node].left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tree[node].right != -<span class="number">1</span>) &#123;</span><br><span class="line">            queue.offer(tree[node].right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tree[node].left == -<span class="number">1</span> &amp;&amp; tree[node].right == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                System.out.print(<span class="string">" "</span> + node);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                System.out.print(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Object n = queue.poll();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            printLeaves((<span class="keyword">int</span>)n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qk6665">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="welcome to qk6665'blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">编译原理学习笔记四-词法分析</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-27 13:30:37" itemprop="dateCreated datePublished" datetime="2020-02-27T13:30:37+08:00">2020-02-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-16 22:10:58" itemprop="dateModified" datetime="2020-03-16T22:10:58+08:00">2020-03-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第四章-词法分析"><a href="#第四章-词法分析" class="headerlink" title="第四章 词法分析"></a>第四章 词法分析</h1><h3 id="第一部分：词法分析器的设计"><a href="#第一部分：词法分析器的设计" class="headerlink" title="第一部分：词法分析器的设计"></a>第一部分：词法分析器的设计</h3><h4 id="1-词法分析的任务"><a href="#1-词法分析的任务" class="headerlink" title="1 词法分析的任务"></a>1 词法分析的任务</h4><p>词法分析的任务：从左至右逐个字符地对源程序进行扫描，产生一个个单词符号  </p>
<p>词法分析器(Lexical Analyzer)：扫描器(Scanner)、执行词法分析的程序</p>
<h4 id="2-词法分析器的功能"><a href="#2-词法分析器的功能" class="headerlink" title="2 词法分析器的功能"></a>2 词法分析器的功能</h4><p>功能：输入源程序、输出单词符号</p>
<p>单词符号的种类：<br>基本字：如 begin，repeat，for，…<br>标识符：用来表示各种名字，如变量名、数组名和过程名<br>常数：各种类型的常数<br>运算符：+，-，*，/，…<br>界符：逗号、分号、括号和空白</p>
<h4 id="3-词法分析器的输出"><a href="#3-词法分析器的输出" class="headerlink" title="3 词法分析器的输出"></a>3 词法分析器的输出</h4><p>输出：输出的单词符号的表示形式(单词种别，单词自身的值)</p>
<p>单词种别通常用整数编码表示：<br>若一个种别只有一个单词符号，则种别编码就代表该单词符号。假定基本字、运算符和界符都是一符一种。<br>若一个种别有多个单词符号，则对于每个单词符号，给出种别编码和自身的值。</p>
<h4 id="4-词法分析器在编译器中的地位"><a href="#4-词法分析器在编译器中的地位" class="headerlink" title="4 词法分析器在编译器中的地位"></a>4 词法分析器在编译器中的地位</h4><p><img src="/2020/02/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/2.png" alt="词法分析器在编译器中的地位"></p>
<h4 id="5-词法分析器的结构"><a href="#5-词法分析器的结构" class="headerlink" title="5 词法分析器的结构"></a>5 词法分析器的结构</h4><p><img src="/2020/02/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/1.png" alt="词法分析器的结构"></p>
<h4 id="6-避免超前搜索"><a href="#6-避免超前搜索" class="headerlink" title="6 避免超前搜索"></a>6 避免超前搜索</h4><p>所有基本字都是保留字;用户不能用它们作自己的标识符；<br>基本字作为特殊的标识符来处理，使用保留字表；<br>如果基本字、标识符和常数(或标号)之间没有确定的运算符或界符作间隔，则必须使用一个空白符作间隔。</p>
<h4 id="7-状态转换图"><a href="#7-状态转换图" class="headerlink" title="7 状态转换图"></a>7 状态转换图</h4><p>状态转换图是一张有限方向图。<br>结点代表状态，用圆圈表示；<br>状态之间用箭弧连结，箭弧上的标记(字符)代表射出结状态下可能出现的输入字符或字符类；<br>一张转换图只包含有限个状态，其中有一个为初态，至少要有一个终态。</p>
<p>状态转换图可用于识别(或接受)一定的字符串。<br>若存在一条从初态到某一终态的道路，且这条路上所有弧上的标记符连接成的字等于α，则称α被该状态转换图所识别(接受)</p>
<h4 id="8-词法分析器的设计示例"><a href="#8-词法分析器的设计示例" class="headerlink" title="8 词法分析器的设计示例"></a>8 词法分析器的设计示例</h4><p><img src="/2020/02/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/3.png" alt="词法分析器的设计示例"></p>
<h4 id="9-状态转换图的程序实现"><a href="#9-状态转换图的程序实现" class="headerlink" title="9 状态转换图的程序实现"></a>9 状态转换图的程序实现</h4><p>不含回路的分叉结点：可用一个CASE语句或一组IF-THEN-ELSE语句实现；<br>含回路的状态结点：对应一段由WHILE结构和IF语句构成的程序；<br>终态结点：表示识别出某种单词符号，对应返回语句。</p>
<h3 id="第二部分：词法规则的形式化"><a href="#第二部分：词法规则的形式化" class="headerlink" title="第二部分：词法规则的形式化"></a>第二部分：词法规则的形式化</h3><h4 id="10-正规式和正规集"><a href="#10-正规式和正规集" class="headerlink" title="10 正规式和正规集"></a>10 正规式和正规集</h4><p>正规集可以用正规式表示，正规式是表示正规集一种方法。<br>一个字集合是正规集当且仅当它能用正规式表示。<br>递归定义：<br>&nbsp;&nbsp;&nbsp;&nbsp;ε和Ø都是Σ上的正规式，它们所表示的正规集为{ε}和Ø;<br>&nbsp;&nbsp;&nbsp;&nbsp;任何a∈Σ，a是Σ上的正规式，它所表示的正规集为{a};<br>&nbsp;&nbsp;&nbsp;&nbsp;假定e1和e2都是上的正规式，它们所表示的正规集为L(e1)和L(e2)，则：(e1|e2)为正规式，它所表示的正规集为L(e1)∪L(e2)，(e1.e2)为正规式，它所表示的正规集为L(e1)L(e2)，(e1)*为正规式，它所表示的正规集为(L(e1))*。</p>
<p>若两个正规式所表示的正规集相同，则称这两个正规式等价。</p>
<p>正规式满足交换律、结合律、分配律。但e1e2 &lt;&gt; e2e1。</p>
<h4 id="11-确定有限自动机-DFA"><a href="#11-确定有限自动机-DFA" class="headerlink" title="11 确定有限自动机(DFA)"></a>11 确定有限自动机(DFA)</h4><p>确定有限自动机(Deterministic Finite Automata，DFA) M是一个五元式，M=(S, Σ, f, S0, F)，其中：<br>S：有穷状态集；<br>Σ：输入字母表(有穷)；<br>f：状态转换函数，为S×Σ→S的单值部分映射，f(s，a)=s’表示：当现行状态为s，输入字符为a时，将状态转换到下一状态s’，s’称为s的一个后继状态；<br>S0∈S是唯一的一个初态；<br>F⊆S：终态集(可空)。</p>
<p>例如：<br><img src="/2020/02/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/4.png" alt="确定有限自动机(DFA)"></p>
<p>对于Σ*中的任何字α，若存在一条从初态到某一终态的道路，且这条路上所有弧上的标记符连接成的字等于α，则称α为DFA M所识别(接收)。<br>DFA M所识别的字的全体记为L(M)。</p>
<h4 id="12-非确定有限自动机-NFA"><a href="#12-非确定有限自动机-NFA" class="headerlink" title="12 非确定有限自动机(NFA)"></a>12 非确定有限自动机(NFA)</h4><p>非确定有限自动机(Nondeterministic Finite Automata，NFA) M是一个五元式M=(S, Σ, f, S0, F)，其中：<br>S：有穷状态集<br>Σ：输入字母表(有穷)<br>f：状态转换函数，为S×Σ*→2S的部分映射<br>S0⊆S是非空的初态集<br>F⊆S：终态集(可空)</p>
<p>NFA 和DFA的区别：<br>NFA可以有多个初态；<br>弧上的标记可以是Σ*中的一个字(甚至可以是一个正规式)，而不一定是单个字符；<br>同一个字可能出现在同状态射出的多条弧上。</p>
<h4 id="13-DFA和NFA"><a href="#13-DFA和NFA" class="headerlink" title="13 DFA和NFA"></a>13 DFA和NFA</h4><p>对于任何两个有限自动机M和M’，如果L(M)=L(M’)，则称M与M’等价。<br>自动机理论中一个重要的结论：判定两个自动机等价性的算法是存在的。<br>对于每个NFA M存在一个DFA M’，使得 L(M)=L(M’)。<br>DFA与NFA识别能力相同。</p>
<h3 id="第三部分：有限自动机的等价性"><a href="#第三部分：有限自动机的等价性" class="headerlink" title="第三部分：有限自动机的等价性"></a>第三部分：有限自动机的等价性</h3><h4 id="14-DFA的化简"><a href="#14-DFA的化简" class="headerlink" title="14 DFA的化简"></a>14 DFA的化简</h4><p>对于给定的DFA M，寻找一个状态数比M少的DFA M’，使得L(M)=L(M’)。  </p>
<p>状态的等价性：<br>假设s和t为M的两个状态，如果从状态s出发能读出某个字α而停止于终态，那么同样，从t出发也能读出α而停止于终态；反之亦然，称s和t等价；<br>两个状态不等价，则称它们是可区别的。</p>
<p>基本思想：<br>把M的状态集划分为一些不相交的子集，使得任何两个不同子集的状态是可区别的，而同一子集的任何两个状态是等价的。<br>最后，让每个子集选出一个代表，同时消去其他状态。</p>
<p>子集划分：<br>首先，把S划分为终态和非终态两个子集，形成基本划分Π；<br>假定到某个时候，Π已含m个子集，记为Π={I(1)，I(2)，…，I(m)}，检查Π中的每个子集看是否能进一步划分；<br>一般地，对某个a和I(i)，若Ia(i) 落入现行Π中N个不同子集，则应把I(i)划分成N个不相交的组，使得每个组J的Ja都落入的Π同一子集；<br>重复上述过程，直到Π所含子集数不再增长；<br>对于上述最后划分Π中的每个子集，我们选取每个子集I中的一个状态代表其他状态，则可得到化简后的DFA M’；<br>若I含有原来的初态，则其代表为新的初态，若I含有原来的终态，则其代表为新的终态。</p>
<h4 id="15-NFA与正规式的转换"><a href="#15-NFA与正规式的转换" class="headerlink" title="15 NFA与正规式的转换"></a>15 NFA与正规式的转换</h4><p>对转换图概念拓广，令每条弧可用一个正规式作标记。</p>
<ol>
<li>对任何FA M，都存在一个正规式r，使得L(r)=L(M)。</li>
<li>对任何正规式r，都存在一个FA M，使得L(M)=L(r)。</li>
</ol>
<p>状态转换图消去结点的方法：<br><img src="/2020/02/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/5.png" alt="状态转换图消去结点的方法"></p>
<h4 id="16-词法分析程序自动生成–LEX"><a href="#16-词法分析程序自动生成–LEX" class="headerlink" title="16 词法分析程序自动生成–LEX"></a>16 词法分析程序自动生成–LEX</h4><p><img src="/2020/02/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/6.png" alt="词法分析程序自动生成--LEX">  </p>
<p>工作过程：<br>对每条识别规则Pi构造一个相应的非确定有限自动机Mi；<br>引进一个新初态X，通过弧，将这些自动机连接成一个新的NFA；<br>把M确定化、最小化，生成该DFA的状态转换表和控制执行程序。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E7%9A%84%E8%AF%AD%E6%B3%95%E6%8F%8F%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qk6665">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="welcome to qk6665'blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E7%9A%84%E8%AF%AD%E6%B3%95%E6%8F%8F%E8%BF%B0/" class="post-title-link" itemprop="url">编译原理学习笔记三-高级程序设计语言的语法描述</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-02-27 12:08:55 / 修改时间：14:07:31" itemprop="dateCreated datePublished" datetime="2020-02-27T12:08:55+08:00">2020-02-27</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第三章-高级程序设计语言的语法描述"><a href="#第三章-高级程序设计语言的语法描述" class="headerlink" title="第三章 高级程序设计语言的语法描述"></a>第三章 高级程序设计语言的语法描述</h1><h4 id="1-文法"><a href="#1-文法" class="headerlink" title="1 文法"></a>1 文法</h4><p>文法： 描述语言的语法结构的形式规则。</p>
<p>例：He gave me a book.<br>&lt;句子&gt; → &lt;主语&gt;&lt;谓语&gt;&lt;间接宾语&gt;&lt;直接宾语&gt;<br>&lt;主语&gt; → &lt;代词&gt;<br>&lt;谓语&gt; → &lt;动词&gt;<br>&lt;间接宾语&gt; → &lt;代词&gt;<br>&lt;直接宾语&gt; → &lt;冠词&gt; &lt;名词&gt;<br>&lt;代词&gt; → He<br>&lt;代词&gt; → me<br>&lt;名词&gt; → book<br>&lt;冠词&gt; → a<br>&lt;动词&gt; → gave  </p>
<h4 id="2-语法描述的几个基本概念"><a href="#2-语法描述的几个基本概念" class="headerlink" title="2 语法描述的几个基本概念"></a>2 语法描述的几个基本概念</h4><p>字母表：一个有穷字符集，记为∑<br>字母表中每个元素称为字符<br>∑上的字(也叫字符串)  是指由∑中的字符所构成的一个有穷序列<br>不包含任何字符的序列称为空字，记为ε<br>用∑*表示∑上的所有字的全体，包含空字ε<br>∑*的子集U和V的连接（积）定义为UV＝{ αβ | α∈U &amp; β∈V }<br>V自身的n次积记为Vn=V V … V<br>V0={ε}<br>V*是V的闭包： V<em>=V0∪V1∪V2∪V3∪…<br>V+是V的正规闭包：V＋＝V V</em></p>
<h4 id="3-上下文无关文法"><a href="#3-上下文无关文法" class="headerlink" title="3 上下文无关文法"></a>3 上下文无关文法</h4><p>上下文无关文法G是一个四元组G=(VT，VN，S，P)，其中<br>VT：终结符(Terminal)集合(非空)<br>VN：非终结符(Noterminal)集合(非空)，且VT ∩ VN=Ø<br>S：文法的开始符号，S∈VN<br>P：产生式集合(有限)，每个产生式形式为<br>P→α， P∈VN， α ∈ (VT ∪ VN)*<br>开始符S至少必须在某个产生式的左部出现一次</p>
<p>例，定义只含+，*的算术表达式的文法<br>  G=&lt; {i，+，*，(，)}，{E}，E， P &gt;， 其中，P由下列产生式组成：<br>E → i<br>E → E+E<br>E → E*E<br>E → (E)  </p>
<h4 id="4-最左推导、最右推导、语法树"><a href="#4-最左推导、最右推导、语法树" class="headerlink" title="4 最左推导、最右推导、语法树"></a>4 最左推导、最右推导、语法树</h4><p>最左推导：任何一步α⇒β都是对α中的最左非终结符进行替换<br>最右推导：任何一步α⇒β都是对α中的最右非终结符进行替换<br>用一张图表示一个句型的推导,称为语法树</p>
<h4 id="5-二义性-ambiguity"><a href="#5-二义性-ambiguity" class="headerlink" title="5 二义性(ambiguity)"></a>5 二义性(ambiguity)</h4><p>文法的二义性：如果一个文法存在某个句子对应两棵不同的语法树，则说这个文法是二义的<br>G(E)： E → i|E+E|E*E|(E) 是二义文法<br>语言的二义性：一个语言是二义的，如果对它不存在无二义的文法</p>
<h4 id="6-不论是程序设计语言还是自然语言，都可能有二义性，也称为歧义。请你针对某个程序语言或者自然语言，例举其中的二义性的例子。"><a href="#6-不论是程序设计语言还是自然语言，都可能有二义性，也称为歧义。请你针对某个程序语言或者自然语言，例举其中的二义性的例子。" class="headerlink" title="6 不论是程序设计语言还是自然语言，都可能有二义性，也称为歧义。请你针对某个程序语言或者自然语言，例举其中的二义性的例子。"></a>6 不论是程序设计语言还是自然语言，都可能有二义性，也称为歧义。请你针对某个程序语言或者自然语言，例举其中的二义性的例子。</h4><p>英语是一种二义性的语言，介词短语较易引起歧义。如“Tom saw Sam at the boat.”既可理解为Sam在船上，也可理解为Tom在船上。</p>
<p>但中文却不存在这样的歧义，“Tom看到Sam在船上”就是指Sam在船上。如果是Tom在船上就会表示为“Tom在船上看到Sam”。原因是中文附加了一些语法规则，会将介词短语的指代方指向前面的语法成分。因此可以通过增加规则消除二义性。因此在常见的高级程序语言中，较少见到二义性的例子。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qk6665">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="welcome to qk6665'blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">操作系统课程学习笔记四-进程管理</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-02-21 10:25:26 / 修改时间：15:47:52" itemprop="dateCreated datePublished" datetime="2020-02-21T10:25:26+08:00">2020-02-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第四章-进程管理"><a href="#第四章-进程管理" class="headerlink" title="第四章 进程管理"></a>第四章 进程管理</h1><h4 id="4-1-进程具有异步性，是进程的优点还是缺点呢？"><a href="#4-1-进程具有异步性，是进程的优点还是缺点呢？" class="headerlink" title="4.1 进程具有异步性，是进程的优点还是缺点呢？"></a>4.1 进程具有异步性，是进程的优点还是缺点呢？</h4><p>是优点。异步可以提高系统运行效率，例如当某进程在加载资源时，可以异步执行，将系统资源让给其他进程。同时，异步运行也不影响进程的同步性，当需要同步执行某些进程时，可以使用进程的消息管理机制控制进程的运行。</p>
<h4 id="4-2-为何没有“阻塞到运行”或“就绪到阻塞”这样的状态迁移？"><a href="#4-2-为何没有“阻塞到运行”或“就绪到阻塞”这样的状态迁移？" class="headerlink" title="4.2 为何没有“阻塞到运行”或“就绪到阻塞”这样的状态迁移？"></a>4.2 为何没有“阻塞到运行”或“就绪到阻塞”这样的状态迁移？</h4><p>个人的理解是，就绪态的操作相当于一个队列等待。想要运行，在一定的优先级条件下首先要进入队列排队，而排队中的进程直到进入运行状态才能进行进入阻塞态等操作。</p>
<p>如果有“阻塞到运行”或“就绪到阻塞”的操作，实质上就打破了常规的流程，需要专门写一段代码处理这两种情况，降低系统稳定性。</p>
<h4 id="4-3-进程控制块中“内部进程通信信息”这一类成员变量的作用是什么？"><a href="#4-3-进程控制块中“内部进程通信信息”这一类成员变量的作用是什么？" class="headerlink" title="4.3 进程控制块中“内部进程通信信息”这一类成员变量的作用是什么？"></a>4.3 进程控制块中“内部进程通信信息”这一类成员变量的作用是什么？</h4><p>不同进程间的交互，数据通信，互斥与同步。</p>
<h4 id="4-4-列举你知道的WINDOWS中，在程序启动exe程序创建相应进程的方法？"><a href="#4-4-列举你知道的WINDOWS中，在程序启动exe程序创建相应进程的方法？" class="headerlink" title="4.4 列举你知道的WINDOWS中，在程序启动exe程序创建相应进程的方法？"></a>4.4 列举你知道的WINDOWS中，在程序启动exe程序创建相应进程的方法？</h4><p>1、system()</p>
<p>2、WinExec()</p>
<p>3、SheelExcute()</p>
<p>4、CreateProcess()</p>
<p>CreateProcess()是最底层的创建进程方法，创建进程内核对象，创建虚拟地址空间，装载exe、dll代码和数据到地址空间，创建主线程和线程内核对象，启动主线程并进入main函数。前三种函数是对CreateProcess()的封装简化，system()最简单，直接传入exe文件目录就可以直接开启进程。</p>
<h4 id="4-5-如何理解fork（）函数的返回值有2个取值？"><a href="#4-5-如何理解fork（）函数的返回值有2个取值？" class="headerlink" title="4.5 如何理解fork（）函数的返回值有2个取值？"></a>4.5 如何理解fork（）函数的返回值有2个取值？</h4><p>fork()会返回pid参数，用于判断是子进程还是父进程。pid=0，是子进程；pid&gt;0,是父进程，且值为子进程ID；pid=-1，出错。</p>
<h4 id="4-6-画圆和画方两个过程是完全同步的吗？"><a href="#4-6-画圆和画方两个过程是完全同步的吗？" class="headerlink" title="4.6 画圆和画方两个过程是完全同步的吗？"></a>4.6 画圆和画方两个过程是完全同步的吗？</h4><p>不会完全同步，因为首先创建的线程会先执行。要提高同步性，应首先创建好两个进程，然后采用时钟触发的方式同时执行。</p>
<h4 id="4-7-你有没有可用“线程编程技术”去改造和完善的编程项目？"><a href="#4-7-你有没有可用“线程编程技术”去改造和完善的编程项目？" class="headerlink" title="4.7 你有没有可用“线程编程技术”去改造和完善的编程项目？"></a>4.7 你有没有可用“线程编程技术”去改造和完善的编程项目？</h4><p>有。在前端页面开发中，获取网络资源应采用异步获取的方式，否则当网速较低时，页面会出现卡顿，影响体验效果。因此获取网络资源时应新建一线程获取，不影响页面其他内容的交互。</p>
<h4 id="4-8-临界区的设置大些好还是小些好？各有什么缺点？"><a href="#4-8-临界区的设置大些好还是小些好？各有什么缺点？" class="headerlink" title="4.8 临界区的设置大些好还是小些好？各有什么缺点？"></a>4.8 临界区的设置大些好还是小些好？各有什么缺点？</h4><p>应在满足访问控制的条件下尽可能小。太大会造成不必要的阻塞。</p>
<h4 id="4-9-Lock-S-，unLock-S-两个函数能否用于控制多线程之间的临界区访问"><a href="#4-9-Lock-S-，unLock-S-两个函数能否用于控制多线程之间的临界区访问" class="headerlink" title="4.9 Lock(S)，unLock(S)两个函数能否用于控制多线程之间的临界区访问?"></a>4.9 Lock(S)，unLock(S)两个函数能否用于控制多线程之间的临界区访问?</h4><p>可以是可以，但并不是一种好方法，线程间的临界区访问有其他更好的方式来实现。</p>
<h4 id="4-10-举出生活中类似“司机和售票员”的同步例子，并分析其中的关键操作。"><a href="#4-10-举出生活中类似“司机和售票员”的同步例子，并分析其中的关键操作。" class="headerlink" title="4.10 举出生活中类似“司机和售票员”的同步例子，并分析其中的关键操作。"></a>4.10 举出生活中类似“司机和售票员”的同步例子，并分析其中的关键操作。</h4><p>超市购物结算。收银员将商品全部扫码完毕，出示总金额，客户根据总金额付款，收银员根据客户付款方式执行相应操作，将商品打包交给客户。</p>
<h4 id="4-11-V操作定义中的q队列里面的进程都是阻塞进程。请问这些进程是从何而来的？或者说这些进程是怎么变成阻塞状态进入q队列的？"><a href="#4-11-V操作定义中的q队列里面的进程都是阻塞进程。请问这些进程是从何而来的？或者说这些进程是怎么变成阻塞状态进入q队列的？" class="headerlink" title="4.11 V操作定义中的q队列里面的进程都是阻塞进程。请问这些进程是从何而来的？或者说这些进程是怎么变成阻塞状态进入q队列的？"></a>4.11 V操作定义中的q队列里面的进程都是阻塞进程。请问这些进程是从何而来的？或者说这些进程是怎么变成阻塞状态进入q队列的？</h4><p>V操作和P操作是成对出现的。只有一种操作是无意义的。V操作中q队列的阻塞进程是P操作转入的。</p>
<h4 id="4-12-3个进程Pa-Pb-Pc-。临界资源数量为1，CSa-b-c是临界区”中，三个进程并发过程中，是不是一定会发生阻塞或唤醒操作？如果mutex初值设置为0或2会有什么结果？在实际应用中，应该怎么合理的设置互斥量的初值？"><a href="#4-12-3个进程Pa-Pb-Pc-。临界资源数量为1，CSa-b-c是临界区”中，三个进程并发过程中，是不是一定会发生阻塞或唤醒操作？如果mutex初值设置为0或2会有什么结果？在实际应用中，应该怎么合理的设置互斥量的初值？" class="headerlink" title="4.12 3个进程Pa,Pb,Pc 。临界资源数量为1，CSa,b,c是临界区”中，三个进程并发过程中，是不是一定会发生阻塞或唤醒操作？如果mutex初值设置为0或2会有什么结果？在实际应用中，应该怎么合理的设置互斥量的初值？"></a>4.12 3个进程Pa,Pb,Pc 。临界资源数量为1，CSa,b,c是临界区”中，三个进程并发过程中，是不是一定会发生阻塞或唤醒操作？如果mutex初值设置为0或2会有什么结果？在实际应用中，应该怎么合理的设置互斥量的初值？</h4><p>不一定。例如并发过程中，三个进程恰好是分别先后执行PV操作。设置为0的话，所有进程都无法进入临界区；设置为1的话，可以同时有两个进程进入临界区。在实际应用中，根据可最多同时进入临界区的进程个数设置互斥量初值。</p>
<h4 id="4-13-在4-5-4节“实现进程同步的例子：司机vs售票员”中，如果把两个信号量S1-S2的初值都设置为1，司机和售票员还能否正确同步？如果不能，请给出反例证明。在实际应用中，应该怎么合理的设置信号量的初值？"><a href="#4-13-在4-5-4节“实现进程同步的例子：司机vs售票员”中，如果把两个信号量S1-S2的初值都设置为1，司机和售票员还能否正确同步？如果不能，请给出反例证明。在实际应用中，应该怎么合理的设置信号量的初值？" class="headerlink" title="4.13 在4.5.4节“实现进程同步的例子：司机vs售票员”中，如果把两个信号量S1,S2的初值都设置为1，司机和售票员还能否正确同步？如果不能，请给出反例证明。在实际应用中，应该怎么合理的设置信号量的初值？"></a>4.13 在4.5.4节“实现进程同步的例子：司机vs售票员”中，如果把两个信号量S1,S2的初值都设置为1，司机和售票员还能否正确同步？如果不能，请给出反例证明。在实际应用中，应该怎么合理的设置信号量的初值？</h4><p>不能。因为会出现未关门就起步或未停车就开门的情况。在实际应用中，应根据正确的逻辑关系确定初值。如果是分属两个进程的两个步骤先后执行，应将初值设为0，如果是临界区互斥，应将初值设为1。</p>
<h4 id="4-14-编者和读者”同步问题在严格意义上讲是一个同步问题还是一个互斥问题？如果把题目的同步要求做一个加强：如果有读者和编者同时在等一个编者“写完”，则当前的“写”操作完后，等待的编者能优先进入。新的情形应当如何完成P-V同步操作？"><a href="#4-14-编者和读者”同步问题在严格意义上讲是一个同步问题还是一个互斥问题？如果把题目的同步要求做一个加强：如果有读者和编者同时在等一个编者“写完”，则当前的“写”操作完后，等待的编者能优先进入。新的情形应当如何完成P-V同步操作？" class="headerlink" title="4.14 编者和读者”同步问题在严格意义上讲是一个同步问题还是一个互斥问题？如果把题目的同步要求做一个加强：如果有读者和编者同时在等一个编者“写完”，则当前的“写”操作完后，等待的编者能优先进入。新的情形应当如何完成P-V同步操作？"></a>4.14 编者和读者”同步问题在严格意义上讲是一个同步问题还是一个互斥问题？如果把题目的同步要求做一个加强：如果有读者和编者同时在等一个编者“写完”，则当前的“写”操作完后，等待的编者能优先进入。新的情形应当如何完成P-V同步操作？</h4><p>写者优先:</p>
<p>1.写者线程的优先级高于读者线程。</p>
<p>2.当有写者到来时应该阻塞读者线程的队列。</p>
<p>3.当有一个写者正在写时或在阻塞队列时应当阻塞读者进程的读操作，直到所有写者进程完成写操作时放开读者进程。</p>
<p>4.当没有写者进程时读者进程应该能够同时读取文件。</p>
<p>具体实现:</p>
<p>1.通过添加信号量read实现写者到来时能够打断读者进程。</p>
<p>2.设置信号量fileSrc实现读写者对临界资源的访问。</p>
<p>3.设置计数器writeCount来统计当前阻塞的写者进程的数目，设置信号量writeCountSignal完成对writeCount计数器资源的互斥访问。</p>
<p>4.设置计数器readCount来统计访问临界资源的读者数目，设置信号量readCountSignal完成对readCount计数器资源的互斥访问。</p>
<h4 id="4-15-在控制台上直接启动的一个应用程序，其末尾的exit-函数返回参数由谁处理或接收？"><a href="#4-15-在控制台上直接启动的一个应用程序，其末尾的exit-函数返回参数由谁处理或接收？" class="headerlink" title="4.15 在控制台上直接启动的一个应用程序，其末尾的exit( )函数返回参数由谁处理或接收？"></a>4.15 在控制台上直接启动的一个应用程序，其末尾的exit( )函数返回参数由谁处理或接收？</h4><p>应该是init进程。init进程是系统中所有其它用户进程的祖先进程，Linux中的所有进程都是有init进程创建并运行的。首先Linux内核启动，然后在用户空间中启动init进程，再启动其他系统进程。在系统启动完成完成后，init将变为守护进程监视系统其他进程。</p>
<h4 id="4-16-举出生活中类似“司机和售票员”的同步例子，并分析其中的关键操作。"><a href="#4-16-举出生活中类似“司机和售票员”的同步例子，并分析其中的关键操作。" class="headerlink" title="4.16 举出生活中类似“司机和售票员”的同步例子，并分析其中的关键操作。"></a>4.16 举出生活中类似“司机和售票员”的同步例子，并分析其中的关键操作。</h4><p>个人理解，匿名管道实质上是有主从关系的，用来实现父进程对子进程的控制，因此是由父进程单方面的读写，子进程被动的响应。</p>
<h4 id="4-17-Linux信号机制与中断机制有什么异同？"><a href="#4-17-Linux信号机制与中断机制有什么异同？" class="headerlink" title="4.17 Linux信号机制与中断机制有什么异同？"></a>4.17 Linux信号机制与中断机制有什么异同？</h4><p>信号和中断的相似点：</p>
<p>都采用了异步通信的方式，同步就是排队，信息一个接一个的处理，异步就是插队；</p>
<p>都是暂停当前的, 去执行对应的handle程序；</p>
<p>都是处理完返回原来位置；</p>
<p>对于信号和中断, 都是可以屏蔽的。</p>
<p>信号与中断的区别：</p>
<p>中断有优先级, 信号没有；</p>
<p>信号处理程序在用户态下运行的, 中断程序在核心态下运行的；</p>
<p>中断响应是及时的, 当信号响应一般有延迟。</p>
<h3 id="单元作业"><a href="#单元作业" class="headerlink" title="单元作业"></a>单元作业</h3><h4 id="1-进程有哪4个特征？"><a href="#1-进程有哪4个特征？" class="headerlink" title="1 进程有哪4个特征？"></a>1 进程有哪4个特征？</h4><p>动态性：进程是程序的一次执行过程，动态产生和消亡；</p>
<p>并发性：进程同其他进程一起向前推进；</p>
<p>异步性：进程按各自速度向前推进；</p>
<p>独立性：进程是系统分配资源和调度CPU的单位。</p>
<h4 id="2-进程有哪3个基本状态，它们之间如何迁移？"><a href="#2-进程有哪3个基本状态，它们之间如何迁移？" class="headerlink" title="2 进程有哪3个基本状态，它们之间如何迁移？"></a>2 进程有哪3个基本状态，它们之间如何迁移？</h4><p>运行状态：进程已占有CPU，在CPU上运行；</p>
<p>就绪状态：举报运行条件但由于无CPU，暂时不能运行；</p>
<p>阻塞状态：因为等待某项服务完成或信号不能运行的状态。</p>
<p>新建的进程会进入就绪状态，根据进程调度进入运行状态，若有退出信号则进入终止状态，若需等待I/O或事件则进入阻塞状态，若时间片已到则进入就绪状态，组赛状态的进程等到I/O信号或事件信号后进入就绪状态。</p>
<h4 id="3-什么是进程控制，有哪4个典型的进程控制行为？"><a href="#3-什么是进程控制，有哪4个典型的进程控制行为？" class="headerlink" title="3 什么是进程控制，有哪4个典型的进程控制行为？"></a>3 什么是进程控制，有哪4个典型的进程控制行为？</h4><p>进程控制是指在进程生成全周期内，对其全部行为的控制。</p>
<p>四个典型控制行为包括：创建进程、阻塞进程、撤销进程和唤醒进行。</p>
<h4 id="4-什么是原语，有何特点？"><a href="#4-什么是原语，有何特点？" class="headerlink" title="4 什么是原语，有何特点？"></a>4 什么是原语，有何特点？</h4><p>原语是由若干指令构成的具有特定功能的函数。具有原子性，其操作不可分割。</p>
<h4 id="5-试述fork-函数的作用和特点？"><a href="#5-试述fork-函数的作用和特点？" class="headerlink" title="5 试述fork()函数的作用和特点？"></a>5 试述fork()函数的作用和特点？</h4><p>fork()是一个系统调用，用于创建进程。一个进程调用fork()函数后，系统先给新的进程分配资源，例如存储数据和代码的空间。新进程是当前进程的子进程，子进程是父进程的复制，子进程和父进程并发运行。</p>
<p>fork()会返回pid参数，用于判断是子进程还是父进程。pid=0，是子进程；pid&gt;0,是父进程，且值为子进程ID；pid=-1，出错。</p>
<h4 id="6-试述线程的概念（Thread）或特点？"><a href="#6-试述线程的概念（Thread）或特点？" class="headerlink" title="6 试述线程的概念（Thread）或特点？"></a>6 试述线程的概念（Thread）或特点？</h4><p>线程是可由CPU直接运行的实体；一个进程可以创建多个线程；多个线程共享CPU可以实现并发运行。</p>
<h4 id="7-试述线程有哪些典型应用场合？"><a href="#7-试述线程有哪些典型应用场合？" class="headerlink" title="7 试述线程有哪些典型应用场合？"></a>7 试述线程有哪些典型应用场合？</h4><p>1、程序需要并发运行多个功能；</p>
<p>2、需要改善窗口交互性的地方，例如用户输入、文件操作、网络操作、搜索等；</p>
<p>3、需要改善程序结构的地方，后台程序；</p>
<p>4、多核CPU上的应用，重复发挥多核性能。</p>
<h4 id="8-何为临界资源，何为临界区？"><a href="#8-何为临界资源，何为临界区？" class="headerlink" title="8 何为临界资源，何为临界区？"></a>8 何为临界资源，何为临界区？</h4><p>临界资源是指一次只允许一个进程独占访问的资源。临界区是指进程中访问临界资源的程序段。</p>
<h4 id="9-试述设计临界资源或临界区访问机制的四个原则是什么？"><a href="#9-试述设计临界资源或临界区访问机制的四个原则是什么？" class="headerlink" title="9 试述设计临界资源或临界区访问机制的四个原则是什么？"></a>9 试述设计临界资源或临界区访问机制的四个原则是什么？</h4><p>忙则等待、空闲让进、有限等待、让权等待</p>
<h4 id="10-临界区访问机制为什么要实现让权等待原则？锁机制为什么没有满足该原则？"><a href="#10-临界区访问机制为什么要实现让权等待原则？锁机制为什么没有满足该原则？" class="headerlink" title="10 临界区访问机制为什么要实现让权等待原则？锁机制为什么没有满足该原则？"></a>10 临界区访问机制为什么要实现让权等待原则？锁机制为什么没有满足该原则？</h4><p>让权等待可以让其它进程有机会得到CPU。锁机制阻止了其他进程对临界区资源的使用，且让调用该资源的进程处于阻塞状态，直到该进程调用完临界资源，执行解锁操作。</p>
<h4 id="11-什么是进程的互斥，什么是进程的同步？各举一个例子说明。"><a href="#11-什么是进程的互斥，什么是进程的同步？各举一个例子说明。" class="headerlink" title="11 什么是进程的互斥，什么是进程的同步？各举一个例子说明。"></a>11 什么是进程的互斥，什么是进程的同步？各举一个例子说明。</h4><p>进程的互斥是指多个进程由于共享了独占性资源，必须协调各进程对资源的存取顺序，确保没有两个或两个以上的进程同时进行存取操作。例如临界资源的使用。</p>
<p>进程的同步是指若干进程为了完成一个共同的任务，需要相互协调运行步伐，一个进程开始某个操作之前必须要求另一个进程已经完成某个操作，否则前面的进程只能等待。例如司机和售票员之间的操作。</p>
<h4 id="12-P-V操作的作用是什么？P操作和V操作各自的原理是什么？"><a href="#12-P-V操作的作用是什么？P操作和V操作各自的原理是什么？" class="headerlink" title="12 P-V操作的作用是什么？P操作和V操作各自的原理是什么？"></a>12 P-V操作的作用是什么？P操作和V操作各自的原理是什么？</h4><p>P-V操作为了实现信号灯进程同步机制。信号灯包含S和q两个属性，S表示信号量，q表示PCB队列。进程可以通过P-V操作改变信号灯的状态，同时进程的状态也受信号灯状态的约束。</p>
<p>P操作将S减1；若差大于等于0，该进程继续；若差小于0，则进程阻塞并加入队列q。</p>
<p>V操作将S加1；若和大于0，进程继续；若和小于等于0，该进程继续同时从q唤醒一个进程。</p>
<h4 id="13-试述P-V操作解决互斥问题的思路是什么？"><a href="#13-试述P-V操作解决互斥问题的思路是什么？" class="headerlink" title="13 试述P-V操作解决互斥问题的思路是什么？"></a>13 试述P-V操作解决互斥问题的思路是什么？</h4><p>​1、设定合适的S初值；</p>
<p>2、进入临界区前执行P操作；</p>
<p>3、离开临界区之后执行V操作。</p>
<h4 id="14-试述P-V操作解决同步问题的思路是什么？"><a href="#14-试述P-V操作解决同步问题的思路是什么？" class="headerlink" title="14 试述P-V操作解决同步问题的思路是什么？"></a>14 试述P-V操作解决同步问题的思路是什么？</h4><p>1、​定义有意义的信号量S，并设置合适的初值；</p>
<p>2、暂停进程时在关键操作前执行P操作；</p>
<p>3、继续进程时在关键操作后执行V操作。</p>
<h4 id="15-试分析“司机vs售票员”同步问题中，哪些操作是关键操作，哪些不是？为什么？"><a href="#15-试分析“司机vs售票员”同步问题中，哪些操作是关键操作，哪些不是？为什么？" class="headerlink" title="15 试分析“司机vs售票员”同步问题中，哪些操作是关键操作，哪些不是？为什么？"></a>15 试分析“司机vs售票员”同步问题中，哪些操作是关键操作，哪些不是？为什么？</h4><p>关键操作有关门、起步和停车、开门。行驶和售票不是关键操作。关键操作涉及到与其他进程的交互，非关键操作不涉及其他进程，只需满足进程内的逻辑。</p>
<h4 id="16-试分析“生产者与消费者”问题中，P-V操作是如何阻止生产者生产速度过快的，又是如何阻止消费者消费速度过快的？又是如何及时唤醒生产者去尽快生产的，又是如何及时唤醒消费者去尽快消费的？"><a href="#16-试分析“生产者与消费者”问题中，P-V操作是如何阻止生产者生产速度过快的，又是如何阻止消费者消费速度过快的？又是如何及时唤醒生产者去尽快生产的，又是如何及时唤醒消费者去尽快消费的？" class="headerlink" title="16 试分析“生产者与消费者”问题中，P-V操作是如何阻止生产者生产速度过快的，又是如何阻止消费者消费速度过快的？又是如何及时唤醒生产者去尽快生产的，又是如何及时唤醒消费者去尽快消费的？"></a>16 试分析“生产者与消费者”问题中，P-V操作是如何阻止生产者生产速度过快的，又是如何阻止消费者消费速度过快的？又是如何及时唤醒生产者去尽快生产的，又是如何及时唤醒消费者去尽快消费的？</h4><p>添加规则，不能向满缓存区存产品，不能从空缓存区取产品，当缓存区已满，生产者处于阻塞态，只有消费者可以运行，当缓存区已空，消费者处于阻塞态，只有生产者可以运行。</p>
<h4 id="17-试述Windows的信号量（Semaphore）机制的工作原理（或如何应用该机制）？"><a href="#17-试述Windows的信号量（Semaphore）机制的工作原理（或如何应用该机制）？" class="headerlink" title="17 试述Windows的信号量（Semaphore）机制的工作原理（或如何应用该机制）？"></a>17 试述Windows的信号量（Semaphore）机制的工作原理（或如何应用该机制）？</h4><p>信号量允许指定数目的多个线程或进程访问临界区，是一种资源计数器，用于限制并发线程的数量。</p>
<p>WaitForSingleObject将信号量减1，ReleaseSemaphore将信号量加1，信号量大于0为有信号状态，小于等于0为无信号状态。</p>
<h4 id="18-试述Linux中wait函数和exit函数的作用和它们之间的联系？"><a href="#18-试述Linux中wait函数和exit函数的作用和它们之间的联系？" class="headerlink" title="18 试述Linux中wait函数和exit函数的作用和它们之间的联系？"></a>18 试述Linux中wait函数和exit函数的作用和它们之间的联系？</h4><p>wait(int status)可以阻塞自己，当有子进程结束，wait收集该子进程信息并销毁该子进程后返回。</p>
<p>exit(int status)可以终止进程，利用status传递进程结束时的状态，然后变为僵尸状态，保留部分PCB信息供wait收集。</p>
<h4 id="19-试述Windows管道通信或Linux信号机制的原理（或如何应用该机制）？"><a href="#19-试述Windows管道通信或Linux信号机制的原理（或如何应用该机制）？" class="headerlink" title="19 试述Windows管道通信或Linux信号机制的原理（或如何应用该机制）？"></a>19 试述Windows管道通信或Linux信号机制的原理（或如何应用该机制）？</h4><p>管道是一种用于在进程间共享数据的机制，其实质是一段共享内存。Windows系统为这段共享的内存设计采用数据流I/0的方式来访问。由一个进程读、另一个进程写，类似于一个管道两端，因此这种进程间的通信方式称作“管道”。</p>
<p>管道分为匿名管道和命名管道：</p>
<p>匿名管道只能在父子进程间进行通信，不能在网络间通信，而且数据传输是单向的，只能一端写，另一端读，为实现双向通信，需建立两个匿名管道；</p>
<p>命令管道可以在任意进程间通信，通信是双向的，任意一端都可读可写，但是在同一时间只能有一端读、一端写。</p>
<p>匿名管道使用方法：</p>
<p>1、创建一个安全属性描述符，设置句柄可继承</p>
<p>2、创建两个管道，父读子写和子读父写</p>
<p>3、重定向输出，将子进程的读写重定向</p>
<p>4、创建子进程</p>
<p>5、读写数据给子进程</p>
<h4 id="20-阅读Linux2-6或更早早期的版本，查看task-struct结构的定义，了解每个成员变量的含义。"><a href="#20-阅读Linux2-6或更早早期的版本，查看task-struct结构的定义，了解每个成员变量的含义。" class="headerlink" title="20 阅读Linux2.6或更早早期的版本，查看task_struct结构的定义，了解每个成员变量的含义。"></a>20 阅读Linux2.6或更早早期的版本，查看task_struct结构的定义，了解每个成员变量的含义。</h4><p>state 进程状态</p>
<p>pid 进程标识符</p>
<p>tgid 线程组标识符</p>
<p>flags 进程标记符</p>
<p>real_parent 当前执行进程的父进程</p>
<p>parent 父进程</p>
<p>children 子进程</p>
<p>prio 优先级</p>
<p>mm 地址空间</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qk6665">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="welcome to qk6665'blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/" class="post-title-link" itemprop="url">编译原理学习笔记二-高级程序设计语言概述</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-18 12:58:51" itemprop="dateCreated datePublished" datetime="2020-02-18T12:58:51+08:00">2020-02-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-27 14:07:31" itemprop="dateModified" datetime="2020-02-27T14:07:31+08:00">2020-02-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第一章-引论"><a href="#第一章-引论" class="headerlink" title="第一章 引论"></a>第一章 引论</h1><h4 id="1-高级程序设计语言的优点"><a href="#1-高级程序设计语言的优点" class="headerlink" title="1 高级程序设计语言的优点"></a>1 高级程序设计语言的优点</h4><p>相对机器语言或汇编语言，高级程序设计语言更接近于数学语言和工程语言，更直观、自然和易于理解，更容易验证其正确性、改错，编写程序的效率更高，更容易移植</p>
<h4 id="2-程序语言的定义"><a href="#2-程序语言的定义" class="headerlink" title="2 程序语言的定义"></a>2 程序语言的定义</h4><p>语法、语义、语用</p>
<h4 id="3-语法"><a href="#3-语法" class="headerlink" title="3 语法"></a>3 语法</h4><p>程序本质上是一定字符集上的字符串。语法：一组规则，用它可以形成和产生一个合式(well-formed)的程序。<br>词法规则：单词符号的形成规则，单词符号是语言中具有独立意义的最基本结构，一般包括常数、标识符、基本字、算符、界符等，描述工具为有限自动机。<br>语法规则：语法单位的形成规则，语法单位通常包括表达式、语句、分程序、过程、函数、程序等，描述工具为上下文无关文法。<br>语法规则和词法规则定义了程序的形式结构，定义语法单位的意义属于语义问题。</p>
<h4 id="4-语义"><a href="#4-语义" class="headerlink" title="4 语义"></a>4 语义</h4><p>语义指一组规则，用它可以定义一个程序的意义，描述方法有自然语言描述和形式描述。</p>
<p>自然语言描述有二义性、隐藏错误和不完整性，形式描述有操作语义、指称语义、代数语义</p>
<h4 id="5-高级语言的分类"><a href="#5-高级语言的分类" class="headerlink" title="5 高级语言的分类"></a>5 高级语言的分类</h4><p>强制式语言(Imperative Languge)/过程式语言：命令驱动，面向语句。FORTRAN、C、Pascal，Ada<br>应用式语言(Applicative Language)：注重程序所表示的功能，而不是一个语句接一个语句地执行。LISP、ML<br>基于规则的语言( Rule-based Language)：检查一定的条件，当它满足值，则执行适当的动作、Prolog<br>面向对象语言(Object-Oriented Language)：封装、继承和多态性。Smalltalk，C++，Java </p>
<h4 id="6-数据类型与操作"><a href="#6-数据类型与操作" class="headerlink" title="6 数据类型与操作"></a>6 数据类型与操作</h4><p>数据类型通常包括三要素：<br>用于区别这种类型数据对象的<strong>属性</strong>；<br>这种类型的数据对象可以具有的<strong>值</strong>；<br>可以作用于这种类型的数据对象的<strong>操作</strong>。</p>
<h4 id="7-初等数据类型"><a href="#7-初等数据类型" class="headerlink" title="7 初等数据类型"></a>7 初等数据类型</h4><p>数值类型：整型、实型、复数、双精度。运算有+，-，*，/等<br>逻辑类型：true、false。布尔运算有∨，∧，┑等<br>字符类型：符号处理<br>指针类型</p>
<h4 id="8-名字"><a href="#8-名字" class="headerlink" title="8 名字"></a>8 名字</h4><p>名字的意义和属性：值，单元中的内容；属性，类型和作用域<br>名字的说明方式：由说明语句来明确规定的，如int score；隐含说明，如FORTRAN中以I,J,K,…N为首的名字代表整型，否则为实型；动态确定，走到哪里，是什么，算什么，如Python。</p>
<h4 id="9-标识符与名字"><a href="#9-标识符与名字" class="headerlink" title="9 标识符与名字"></a>9 标识符与名字</h4><p>标识符是以字母开头的，由字母数字组成的字符串。<br>标识符与名字两者有本质区别，标识符是语法概念，名字有确切的意义和属性。</p>
<h4 id="10-数据结构"><a href="#10-数据结构" class="headerlink" title="10 数据结构"></a>10 数据结构</h4><p>数组，字符串、表格、栈</p>
<h4 id="11-抽象数据类型"><a href="#11-抽象数据类型" class="headerlink" title="11 抽象数据类型"></a>11 抽象数据类型</h4><p>抽象数据类型(Abstract Data Type)：一组独立于任何特定实现而精确指定的数据值和相关操作。<br>抽象数据类型由数据集合、及其相关的操作组成，这些操作有明确的定义，而且定义不依赖于具体的实现。</p>
<p>一个抽象数据类型包括数据对象集合、作用于这些数据对象的抽象运算的集合、这种类型对象的封装。</p>
<h4 id="12-表达式"><a href="#12-表达式" class="headerlink" title="12 表达式"></a>12 表达式</h4><p>表达式由运算量（也称操作数，即数据引用或函数调用）和算符（运算符，操作符）组成</p>
<p>形式：中缀、前缀、后缀：X*Y、-A、P↑</p>
<p>表达式形成规则：变量（包括下标变量）、常数是表达式；若E1、E2为表达式，是一个二元算符，则E1E2是表达式；若E是表达式，为一元算符，则E（或E）是表达式；若E是表达式，则（E）是表达式。</p>
<h4 id="13-名字的左值和右值"><a href="#13-名字的左值和右值" class="headerlink" title="13 名字的左值和右值"></a>13 名字的左值和右值</h4><p>赋值语句<br>A := B</p>
<p>名字的左值：该名字代表的存储单元的地址</p>
<p>名字的右值：该名字代表的存贮单元的内容</p>
<h4 id="14-语句的分类"><a href="#14-语句的分类" class="headerlink" title="14 语句的分类"></a>14 语句的分类</h4><p>按功能：执行语句，描述程序的动作；说明语句，定义各种不同数据类型的变量或运算，定义名字的性质</p>
<p>按形式：简单句，不包含其他语句成分的基本句；复合句，句中有句的语句</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80-%E5%BC%95%E8%AE%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qk6665">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="welcome to qk6665'blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80-%E5%BC%95%E8%AE%BA/" class="post-title-link" itemprop="url">编译原理学习笔记一-引论</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-18 12:42:44" itemprop="dateCreated datePublished" datetime="2020-02-18T12:42:44+08:00">2020-02-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-27 16:43:06" itemprop="dateModified" datetime="2020-02-27T16:43:06+08:00">2020-02-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第一章-引论"><a href="#第一章-引论" class="headerlink" title="第一章 引论"></a>第一章 引论</h1><h4 id="1-翻译程序-Translator-、编译程序-Compiler-、解释程序-Interpreter"><a href="#1-翻译程序-Translator-、编译程序-Compiler-、解释程序-Interpreter" class="headerlink" title="1 翻译程序(Translator)、编译程序(Compiler)、解释程序(Interpreter)"></a>1 翻译程序(Translator)、编译程序(Compiler)、解释程序(Interpreter)</h4><p>翻译程序是把某一种语言程序(称为源语言程序)等价地转换成另一种语言程序(称为目标语言程序)的程序。</p>
<p>编译程序是把某一种高级语言程序等价地转换成另一种低级语言程序(如汇编语言或机器语言程序)的程序。</p>
<p>解释程序是把源语言写的源程序作为输入，但不产生目标程序，而是边解释边执行源程序。</p>
<h4 id="2-编译过程"><a href="#2-编译过程" class="headerlink" title="2 编译过程"></a>2 编译过程</h4><p><img src="/2020/02/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80-%E5%BC%95%E8%AE%BA/1.png" alt="词法分析程序自动生成--LEX"><br>词法分析：输入源程序，对构成源程序的字符串进行扫描和分解，识别出单词符号；<br>语法分析：在词法分析的基础上，根据语法规则把单词符号串分解成各类语法单位(语法范畴)；<br>中间代码生成：对各类语法单位按语言的语义进行初步翻译；<br>优化：依据程序的等价变换规则，对前阶段产生的中间代码进行加工变换，以期在最后阶段产生更高效的目标代码；<br>目标代码产生：把中间代码变换成特定机器上的目标代码，目标代码有三种形式，汇编指令代码、绝对指令代码、可重新定位指令代码。</p>
<h4 id="3-编译程序结构"><a href="#3-编译程序结构" class="headerlink" title="3 编译程序结构"></a>3 编译程序结构</h4><p>包括词法分析器、语法分析器、语义分析与中间代码生成器、优化段、目标代码生成器、符号表管理和出错处理</p>
<h4 id="4-遍-pass"><a href="#4-遍-pass" class="headerlink" title="4 遍(pass)"></a>4 遍(pass)</h4><p>所谓”遍”， 就是对源程序或源程序的中间表示从头到尾扫描一次.阶段与遍是不同的概念，一遍可以由若干段组成，一个阶段也可以分若干遍来完成</p>
<h4 id="5-编译前端与后端"><a href="#5-编译前端与后端" class="headerlink" title="5 编译前端与后端"></a>5 编译前端与后端</h4><p>编译前端：与源语言有关，如词法分析，语法分析，语义分析与中间代码产生，与机器无关的优化；<br>编译后端：与目标机有关，与目标机有关的优化，目标代码产生；<br>带来的好处：程序逻辑结构清晰；优化更充分，有利于移植。</p>
<h3 id="5-编译语言的生成"><a href="#5-编译语言的生成" class="headerlink" title="5 编译语言的生成"></a>5 编译语言的生成</h3><p>以汇编语言和机器语言为工具。<br>优点:  可以针对具体的机器，充分发挥计算机的系统功能；生成的程序效率高<br>缺点:  程序难读、难写、易出错、难维护、生产的效率低</p>
<p>以高级语言为工具。程序易读、易理解、容易维护、生产的效率高</p>
<p>自编译方式。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">qk6665</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">16</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">qk6665</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.7.1
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
