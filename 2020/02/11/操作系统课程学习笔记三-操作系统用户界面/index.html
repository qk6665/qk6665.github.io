
<!DOCTYPE html>
<html>

<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
    <title>welcome to qk6665&#39;blog</title>
    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>

<header class="header">
    <div class="blog-title">
        <a href="/" class="logo">welcome to qk6665&#39;blog</a>
    </div>
    <nav class="navbar">
        <ul class="menu">
            
                <li class="menu-item">
                    <a href="/" class="menu-item-link">首页</a>
                </li>
            
                <li class="menu-item">
                    <a href="/archives" class="menu-item-link">目录</a>
                </li>
            
                <li class="menu-item">
                    <a href="https://github.com/qk6665" target="_blank" rel="noopener" class="menu-item-link">GitHub</a>
                </li>
            
        </ul>
    </nav>
</header>

<main class="main">
    <article class="post">
    <div class="post-title">
        <h2 class="title">操作系统课程学习笔记三-操作系统用户界面</h2>
    </div>
    <div class="post-meta">
        <span class="post-time">2020-02-11</span>
    </div>
    <div class="post-content">
        <h1 id="第三章-操作系统用户界面"><a href="#第三章-操作系统用户界面" class="headerlink" title="第三章 操作系统用户界面"></a>第三章 操作系统用户界面</h1><h4 id="2-1-BIOS中断是INT-XXh的形式，例如INT-13H是磁盘读写服务。那么INT-21H与这些BIOS中断的机制是不是一样的呢？"><a href="#2-1-BIOS中断是INT-XXh的形式，例如INT-13H是磁盘读写服务。那么INT-21H与这些BIOS中断的机制是不是一样的呢？" class="headerlink" title="2.1 BIOS中断是INT XXh的形式，例如INT 13H是磁盘读写服务。那么INT 21H与这些BIOS中断的机制是不是一样的呢？"></a>2.1 BIOS中断是INT XXh的形式，例如INT 13H是磁盘读写服务。那么INT 21H与这些BIOS中断的机制是不是一样的呢？</h4><p>机制一样，但实现方法有区别。二者都是中断，过程表现为识别中断源、保护断点和现场、装入中断服务程序的入口地址、进入中断服务程序、结束中断程序后恢复现场和断点、中断返回。但BIOS中断由硬件电路实现，INT 21H由软件程序指令实现。</p>
<h4 id="2-2-操作系统的初始引导过程涉及哪些程序模块，各自存放的介质是什么，存放的形式是什么？"><a href="#2-2-操作系统的初始引导过程涉及哪些程序模块，各自存放的介质是什么，存放的形式是什么？" class="headerlink" title="2.2 操作系统的初始引导过程涉及哪些程序模块，各自存放的介质是什么，存放的形式是什么？"></a>2.2 操作系统的初始引导过程涉及哪些程序模块，各自存放的介质是什么，存放的形式是什么？</h4><p>操作系统初始引导是指通过引导程序把操作系统核心装入内存并使之接管计算机系统的过程。首先BIOS读取MRB引导程序到内存运行，MRB的引导程序根据BIOS提供的参数读取硬盘指定位置的文件到内存，该文件加载指定操作系统的内核并初始化基本参数，操作系统内核逐步加载剩余操作系统程序，最后完全控制计算机。</p>
<h4 id="2-3-比较DOS、Windows7与Linux早期版本都有哪些典型的操作界面？操作界面对普通用户（办公或娱乐）选择操作系统有何影响？"><a href="#2-3-比较DOS、Windows7与Linux早期版本都有哪些典型的操作界面？操作界面对普通用户（办公或娱乐）选择操作系统有何影响？" class="headerlink" title="2.3 比较DOS、Windows7与Linux早期版本都有哪些典型的操作界面？操作界面对普通用户（办公或娱乐）选择操作系统有何影响？"></a>2.3 比较DOS、Windows7与Linux早期版本都有哪些典型的操作界面？操作界面对普通用户（办公或娱乐）选择操作系统有何影响？</h4><p>主要有GUI界面（win7）和命令行（DOS、Linux）两种。GUI界面更易被初学者或普通用户接受，操作简单并且可以浏览使用各种图形数据，命令行界面的操作需要学会使用指令，入门成本高，且难以处理复杂图像应用。</p>
<h4 id="2-4-Linux的Shell能否看成操作系统的内核功能？如何理解Shell与内核之间的交互？"><a href="#2-4-Linux的Shell能否看成操作系统的内核功能？如何理解Shell与内核之间的交互？" class="headerlink" title="2.4 Linux的Shell能否看成操作系统的内核功能？如何理解Shell与内核之间的交互？"></a>2.4 Linux的Shell能否看成操作系统的内核功能？如何理解Shell与内核之间的交互？</h4><p>不能。Shell可以看作是用户和操作系统信息交互的中间桥梁。用户用过Shell将命令下达给操作系统，操作系统通过Shell将需要展示给用户的信息返回，Shell本身不执行命令，仅仅是组织和管理命令。</p>
<h4 id="2-5-printf，open都是Linux中典型的隐式系统调用。当我们在“为Linux内核增加新的系统调用实验”中增加一个新的系统调用后，我们在应用程序中是如何调用的它们的？为何我们不能像printf，open等函数一样简单地调用？"><a href="#2-5-printf，open都是Linux中典型的隐式系统调用。当我们在“为Linux内核增加新的系统调用实验”中增加一个新的系统调用后，我们在应用程序中是如何调用的它们的？为何我们不能像printf，open等函数一样简单地调用？" class="headerlink" title="2.5 printf，open都是Linux中典型的隐式系统调用。当我们在“为Linux内核增加新的系统调用实验”中增加一个新的系统调用后，我们在应用程序中是如何调用的它们的？为何我们不能像printf，open等函数一样简单地调用？"></a>2.5 printf，open都是Linux中典型的隐式系统调用。当我们在“为Linux内核增加新的系统调用实验”中增加一个新的系统调用后，我们在应用程序中是如何调用的它们的？为何我们不能像printf，open等函数一样简单地调用？</h4><p>不能。printf和open是高级语言的API接口，Linux中隐式系统调用也会在编译时转化为显式的系统调用，最终用到INT80h。我们在自己制作的操作系统中加入的自定义系统调用，并没有现成的高级语言API接口供我们使用，可以通过汇编语言调用INT80端口使用或封装成高级语言API接口直接调用。</p>
<p>###单元作业</p>
<h4 id="1-系统BIOS的功能有哪些？"><a href="#1-系统BIOS的功能有哪些？" class="headerlink" title="1 系统BIOS的功能有哪些？"></a>1 系统BIOS的功能有哪些？</h4><p>BIOS全程Basic I/O System，是一种固件（Firmware），是以硬件形式储存的软件，储存主板启动配置信息、基本设备I/O服务，完成系统的加电自检、初始化基本硬件。</p>
<h4 id="2-计算机加电后执行的第一条指令存放在哪里，有什么特点？"><a href="#2-计算机加电后执行的第一条指令存放在哪里，有什么特点？" class="headerlink" title="2 计算机加电后执行的第一条指令存放在哪里，有什么特点？"></a>2 计算机加电后执行的第一条指令存放在哪里，有什么特点？</h4><p>BIOS的指令位置位于F0000-FFFFF处，按下开机或重启键后执行的第一条指令位于FFFFQ处，执行JUMP POST（加电自检）动作，POST位于BIOS内部，该指令由硬件电路实现，功能是初始化基本硬件，若自检错误通过喇叭或数显二极管的方式提示。</p>
<h4 id="3-何为操作系统的生成？简述Linux内核的生成过程。"><a href="#3-何为操作系统的生成？简述Linux内核的生成过程。" class="headerlink" title="3 何为操作系统的生成？简述Linux内核的生成过程。"></a>3 何为操作系统的生成？简述Linux内核的生成过程。</h4><p>​操作系统的生成是指满足特定硬件环境和用户需要，组装和构建操作系统的过程。<br>Linux操作系统的生成过程如下：</p>
<p>1、获取Linux内核的源代码</p>
<p>2、选择和启动内核配置程序</p>
<p>3、根据需要配置内核模块的参数</p>
<p>4、程序编译新的内核</p>
<p>5、编译和安装模块</p>
<p>6、启动新内核</p>
<h4 id="4-何为用户界面？有哪些类别？各有什么特点？"><a href="#4-何为用户界面？有哪些类别？各有什么特点？" class="headerlink" title="4 何为用户界面？有哪些类别？各有什么特点？"></a>4 何为用户界面？有哪些类别？各有什么特点？</h4><p>用户界面是指操作系统提供给用户控制计算机的机制，又称用户接口。分为操作界面和系统调用。</p>
<p>操作界面通过GUI或控制台接受普通命令、批处理程序或Shell指令，一般不涉及核心资源或硬件操作。</p>
<p>系统调用需要操作系统内核为应用程序提供服务或函数，CPU运行于核态，调用过程会产生自愿中断。</p>
<h4 id="5-何为shell？有哪4类典型的shell？"><a href="#5-何为shell？有哪4类典型的shell？" class="headerlink" title="5 何为shell？有哪4类典型的shell？"></a>5 何为shell？有哪4类典型的shell？</h4><p>Shell可以看作是用户和操作系统信息交互的中间桥梁。用户用过Shell将命令下达给操作系统，操作系统通过Shell将需要展示给用户的信息返回，Shell本身不执行命令，仅仅是组织和管理命令。</p>
<p>Shell有Bsh、Csh、Ksh、Bash四种，前三种是早期版本，各有优缺点，Bsh有较强编程功能，Csh交互方便，Ksh结合Bsh和Csh优势，Bash是Bsh的升级并且吸收了Ksh的特性。</p>
<h4 id="6-何为输出重定向？举一个Linux或Windows中的重定向的应用命令或例子。"><a href="#6-何为输出重定向？举一个Linux或Windows中的重定向的应用命令或例子。" class="headerlink" title="6 何为输出重定向？举一个Linux或Windows中的重定向的应用命令或例子。"></a>6 何为输出重定向？举一个Linux或Windows中的重定向的应用命令或例子。</h4><p>输出重定向是指将命令输出由默认的显示器更改为指定的文件。</p>
<p>在Linux命令行中输入以下命令，可以将原本会在命令行中显示的etc目录信息储存在当前目录下的etcdir.log文件中。</p>
 <figure class="highlight ls"><figcaption><span>/etc/ > etcdir.log```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">#### 7 试述运行shell脚本程序的三种方式？</span></span><br><span class="line">       </span><br><span class="line">第一种是直接运行，用缺省版本的Shell运行程序；</span><br><span class="line"></span><br><span class="line">第二种是使用特定版本，在运行程序时输入Shell版本+程序名可以使用特定版本，如bash my_script 。</span><br><span class="line"></span><br><span class="line">第三种是在脚本文件首行指定。在脚本开头加一行：<span class="comment">#!/bin/bush 。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#### 8 系统调用与普通用户态函数比较，有何异同点？</span></span><br><span class="line">       </span><br><span class="line">系统调用一般设计核心资源或硬件的操作，CPU运行于核态，每个系统调用具有唯一ID，调用过程会产生自愿中断，实现过程较复杂。相同点是都属于用户接口，实现用户对计算机的控制。</span><br><span class="line"></span><br><span class="line"><span class="comment">#### 9 何为隐式系统调用？</span></span><br><span class="line"></span><br><span class="line">隐式调用是指通过高级语言的API接口在编译时转化为显式的系统调用，最终用到特定的中断执行系统调用指令。使用隐式系统调用可以快捷方便的使用计算的机某些内核资源。</span><br><span class="line"></span><br><span class="line"><span class="comment">#### 10 试述Linux系统调用(INT 80H)的工作原理？</span></span><br><span class="line"></span><br><span class="line">应用程序调用库函数（API）；</span><br><span class="line"></span><br><span class="line">API将系统调用号存入EAX，然后通过中断调用使系统进入内核态；</span><br><span class="line"></span><br><span class="line">内核中的中断处理函数根据系统调用号，调用对应的内核函数（系统调用）；</span><br><span class="line"></span><br><span class="line">系统调用完成相应功能，将返回值存入EAX，返回到中断处理函数；</span><br><span class="line"></span><br><span class="line">中断处理函数返回到API中；</span><br><span class="line"></span><br><span class="line">API将EAX返回给应用程序。</span><br><span class="line"></span><br><span class="line"><span class="comment">#### 11 试述为Linux增加新的系统调用的过程？        </span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、在sys.c中加入函数</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、添加声明</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、添加ID</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、重新配置安装内核</span><br><span class="line"></span><br><span class="line"><span class="comment">#### 12 回顾汇编语言中关于寄存器结构和定义部分的知识，理解各个寄存器的基本作用和用法。</span></span><br><span class="line"></span><br><span class="line">寄存器是中央处理器内的组成部份。寄存器是有限存贮容量的高速存贮部件，它们可用来暂存指令、数据和位址。在中央处理器的控制部件中，包含的寄存器有指令寄存器(IR)和程序计数器(PC)。在中央处理器的算术及逻辑部件中，包含的寄存器有累加器(ACC)。</span><br><span class="line"></span><br><span class="line">寄存器的作用：可将寄存器内的数据执行算术及逻辑运算；存于寄存器内的地址可用来指向内存的某个位置，即寻址；可以用来读写数据到电脑的周边设备。</span><br><span class="line"></span><br><span class="line">数据寄存器主要用来保存操作数和运算结果等信息，从而节省读取操作数所需占用总线和访问存储器的时间。</span><br><span class="line"></span><br><span class="line">寄存器 ESI、EDI称为变址寄存器(Index Register)，它们主要用于存放存储单元在段内的偏移量，用它们可实现多种存储器操作数的寻址方式，为以不同的地址形式访问存储单元提供方便。</span><br><span class="line"></span><br><span class="line">寄存器EBP、ESP、BP和SP称为指针寄存器(Pointer Register)，主要用于存放堆栈内存储单元的偏移量，用它们可实现多种存储器操作数的寻址方式，为以不同的地址形式访问存储单元提供方便。</span><br><span class="line"></span><br><span class="line">段寄存器是根据内存分段的管理模式而设置的。内存单元的物理地址由段寄存器的值和一个偏移量组合而成的，这样可用两个较少位数的值组合成一个可访问较大物理空间的内存地址。</span><br><span class="line"></span><br><span class="line">​指令指针EIP、IP(InstructionPointer)是存放下次将要执行的指令在代码段的偏移量。</span><br><span class="line"></span><br><span class="line">标志寄存器用于实现特定功能。</span><br><span class="line"></span><br><span class="line"><span class="comment">#### 13 尝试去理解用 menucofig命令去配置Linux内核时，配置界面上每个条目的含义和作用？</span></span><br><span class="line"></span><br><span class="line">Code maturity level options：代码成熟等级</span><br><span class="line"></span><br><span class="line">Loadable <span class="built_in">module</span> support：对模块的支持</span><br><span class="line"></span><br><span class="line">General setup：常规内核选项</span><br><span class="line"></span><br><span class="line">Memory Technology Devices (MTD)：配置存储设备</span><br><span class="line"></span><br><span class="line">Parallel port support：配置并口</span><br><span class="line"></span><br><span class="line">Plug <span class="keyword">and</span> Play configuration：即插即用支持</span><br><span class="line"></span><br><span class="line">Block devices：块设备支持</span><br><span class="line"></span><br><span class="line">Multiple devices driver support：多设备驱动支持</span><br><span class="line"></span><br><span class="line">Networking options：网络选项</span><br><span class="line"></span><br><span class="line">Telephony Support：电话支持</span><br><span class="line"></span><br><span class="line">ATA/IDE/MFM/RLL support：配置对ATA，IDE，MFM和RLL的支持</span><br><span class="line"></span><br><span class="line">SCSI support：SCSI设备的支持</span><br><span class="line"></span><br><span class="line">I2O Device Support：I20设备支持</span><br><span class="line"></span><br><span class="line">Network Device Support：网络设备支持</span><br><span class="line"></span><br><span class="line">Amateur Radio support：配置业余广播支持</span><br><span class="line"></span><br><span class="line">IrDA（infrared）support：配置红外线（无线）通讯支持</span><br><span class="line"></span><br><span class="line">ISDN subsystem：配置ISDN</span><br><span class="line"></span><br><span class="line">Old CD-ROM drivers（<span class="keyword">not</span> SCSI、<span class="keyword">not</span> IDE）：配置老CDROM</span><br><span class="line"></span><br><span class="line">Input Core Support：提供USB支持</span><br><span class="line"></span><br><span class="line">Character devices：字符设备</span><br><span class="line"></span><br><span class="line">Multimedia Devices：配置多媒体设备</span><br><span class="line"></span><br><span class="line">File System：配置文件系统</span><br><span class="line"></span><br><span class="line">Console drivers：配置控制台驱动</span><br><span class="line"></span><br><span class="line">USB support：配置USB支持</span><br><span class="line"></span><br><span class="line">kernel hacking：配置“kernel hacking”</span><br><span class="line"></span><br><span class="line">​https:<span class="regexp">//blog.csdn.net/xuyuefei1988/article/details/8635539</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"><span class="comment">#### 14 在Linux上练习使用管道命令。</span></span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">```curl -s https://</span>api.github.com/repos/iissnan/hexo-theme-next/releases/latest | grep tarball_url | cut -d <span class="string">'"'</span> -f <span class="number">4</span> | wget -i - -O- | tar -zx -C themes/next --strip-components=<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>这条指令是一个管道指令，首先打开指定网络文件，获取tarball_url对应的值，去掉首末端双引号得到一个网址，下载对应文件并解压到指定目录，去掉第一层目录。</p>

    </div>
</article>

</main>
</body>
</html>
