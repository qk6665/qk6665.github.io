
<!DOCTYPE html>
<html>

<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
    <title>welcome to qk6665&#39;blog</title>
    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>

<header class="header">
    <div class="blog-title">
        <a href="/" class="logo">welcome to qk6665&#39;blog</a>
    </div>
    <nav class="navbar">
        <ul class="menu">
            
                <li class="menu-item">
                    <a href="/" class="menu-item-link">首页</a>
                </li>
            
                <li class="menu-item">
                    <a href="/archives" class="menu-item-link">目录</a>
                </li>
            
                <li class="menu-item">
                    <a href="https://github.com/qk6665" target="_blank" rel="noopener" class="menu-item-link">GitHub</a>
                </li>
            
        </ul>
    </nav>
</header>

<main class="main">
    <article class="post">
    <div class="post-title">
        <h2 class="title">操作系统课程学习笔记四-进程管理</h2>
    </div>
    <div class="post-meta">
        <span class="post-time">2020-02-21</span>
    </div>
    <div class="post-content">
        <h1 id="第四章-进程管理"><a href="#第四章-进程管理" class="headerlink" title="第四章 进程管理"></a>第四章 进程管理</h1><h4 id="4-1-进程具有异步性，是进程的优点还是缺点呢？"><a href="#4-1-进程具有异步性，是进程的优点还是缺点呢？" class="headerlink" title="4.1 进程具有异步性，是进程的优点还是缺点呢？"></a>4.1 进程具有异步性，是进程的优点还是缺点呢？</h4><p>是优点。异步可以提高系统运行效率，例如当某进程在加载资源时，可以异步执行，将系统资源让给其他进程。同时，异步运行也不影响进程的同步性，当需要同步执行某些进程时，可以使用进程的消息管理机制控制进程的运行。</p>
<h4 id="4-2-为何没有“阻塞到运行”或“就绪到阻塞”这样的状态迁移？"><a href="#4-2-为何没有“阻塞到运行”或“就绪到阻塞”这样的状态迁移？" class="headerlink" title="4.2 为何没有“阻塞到运行”或“就绪到阻塞”这样的状态迁移？"></a>4.2 为何没有“阻塞到运行”或“就绪到阻塞”这样的状态迁移？</h4><p>个人的理解是，就绪态的操作相当于一个队列等待。想要运行，在一定的优先级条件下首先要进入队列排队，而排队中的进程直到进入运行状态才能进行进入阻塞态等操作。</p>
<p>如果有“阻塞到运行”或“就绪到阻塞”的操作，实质上就打破了常规的流程，需要专门写一段代码处理这两种情况，降低系统稳定性。</p>
<h4 id="4-3-进程控制块中“内部进程通信信息”这一类成员变量的作用是什么？"><a href="#4-3-进程控制块中“内部进程通信信息”这一类成员变量的作用是什么？" class="headerlink" title="4.3 进程控制块中“内部进程通信信息”这一类成员变量的作用是什么？"></a>4.3 进程控制块中“内部进程通信信息”这一类成员变量的作用是什么？</h4><p>不同进程间的交互，数据通信，互斥与同步。</p>
<h4 id="4-4-列举你知道的WINDOWS中，在程序启动exe程序创建相应进程的方法？"><a href="#4-4-列举你知道的WINDOWS中，在程序启动exe程序创建相应进程的方法？" class="headerlink" title="4.4 列举你知道的WINDOWS中，在程序启动exe程序创建相应进程的方法？"></a>4.4 列举你知道的WINDOWS中，在程序启动exe程序创建相应进程的方法？</h4><p>1、system()</p>
<p>2、WinExec()</p>
<p>3、SheelExcute()</p>
<p>4、CreateProcess()</p>
<p>CreateProcess()是最底层的创建进程方法，创建进程内核对象，创建虚拟地址空间，装载exe、dll代码和数据到地址空间，创建主线程和线程内核对象，启动主线程并进入main函数。前三种函数是对CreateProcess()的封装简化，system()最简单，直接传入exe文件目录就可以直接开启进程。</p>
<h4 id="4-5-如何理解fork（）函数的返回值有2个取值？"><a href="#4-5-如何理解fork（）函数的返回值有2个取值？" class="headerlink" title="4.5 如何理解fork（）函数的返回值有2个取值？"></a>4.5 如何理解fork（）函数的返回值有2个取值？</h4><p>fork()会返回pid参数，用于判断是子进程还是父进程。pid=0，是子进程；pid&gt;0,是父进程，且值为子进程ID；pid=-1，出错。</p>
<h4 id="4-6-画圆和画方两个过程是完全同步的吗？"><a href="#4-6-画圆和画方两个过程是完全同步的吗？" class="headerlink" title="4.6 画圆和画方两个过程是完全同步的吗？"></a>4.6 画圆和画方两个过程是完全同步的吗？</h4><p>不会完全同步，因为首先创建的线程会先执行。要提高同步性，应首先创建好两个进程，然后采用时钟触发的方式同时执行。</p>
<h4 id="4-7-你有没有可用“线程编程技术”去改造和完善的编程项目？"><a href="#4-7-你有没有可用“线程编程技术”去改造和完善的编程项目？" class="headerlink" title="4.7 你有没有可用“线程编程技术”去改造和完善的编程项目？"></a>4.7 你有没有可用“线程编程技术”去改造和完善的编程项目？</h4><p>有。在前端页面开发中，获取网络资源应采用异步获取的方式，否则当网速较低时，页面会出现卡顿，影响体验效果。因此获取网络资源时应新建一线程获取，不影响页面其他内容的交互。</p>
<h4 id="4-8-临界区的设置大些好还是小些好？各有什么缺点？"><a href="#4-8-临界区的设置大些好还是小些好？各有什么缺点？" class="headerlink" title="4.8 临界区的设置大些好还是小些好？各有什么缺点？"></a>4.8 临界区的设置大些好还是小些好？各有什么缺点？</h4><p>应在满足访问控制的条件下尽可能小。太大会造成不必要的阻塞。</p>
<h4 id="4-9-Lock-S-，unLock-S-两个函数能否用于控制多线程之间的临界区访问"><a href="#4-9-Lock-S-，unLock-S-两个函数能否用于控制多线程之间的临界区访问" class="headerlink" title="4.9 Lock(S)，unLock(S)两个函数能否用于控制多线程之间的临界区访问?"></a>4.9 Lock(S)，unLock(S)两个函数能否用于控制多线程之间的临界区访问?</h4><p>可以是可以，但并不是一种好方法，线程间的临界区访问有其他更好的方式来实现。</p>
<h4 id="4-10-举出生活中类似“司机和售票员”的同步例子，并分析其中的关键操作。"><a href="#4-10-举出生活中类似“司机和售票员”的同步例子，并分析其中的关键操作。" class="headerlink" title="4.10 举出生活中类似“司机和售票员”的同步例子，并分析其中的关键操作。"></a>4.10 举出生活中类似“司机和售票员”的同步例子，并分析其中的关键操作。</h4><p>超市购物结算。收银员将商品全部扫码完毕，出示总金额，客户根据总金额付款，收银员根据客户付款方式执行相应操作，将商品打包交给客户。</p>
<h4 id="4-11-V操作定义中的q队列里面的进程都是阻塞进程。请问这些进程是从何而来的？或者说这些进程是怎么变成阻塞状态进入q队列的？"><a href="#4-11-V操作定义中的q队列里面的进程都是阻塞进程。请问这些进程是从何而来的？或者说这些进程是怎么变成阻塞状态进入q队列的？" class="headerlink" title="4.11 V操作定义中的q队列里面的进程都是阻塞进程。请问这些进程是从何而来的？或者说这些进程是怎么变成阻塞状态进入q队列的？"></a>4.11 V操作定义中的q队列里面的进程都是阻塞进程。请问这些进程是从何而来的？或者说这些进程是怎么变成阻塞状态进入q队列的？</h4><p>V操作和P操作是成对出现的。只有一种操作是无意义的。V操作中q队列的阻塞进程是P操作转入的。</p>
<h4 id="4-12-3个进程Pa-Pb-Pc-。临界资源数量为1，CSa-b-c是临界区”中，三个进程并发过程中，是不是一定会发生阻塞或唤醒操作？如果mutex初值设置为0或2会有什么结果？在实际应用中，应该怎么合理的设置互斥量的初值？"><a href="#4-12-3个进程Pa-Pb-Pc-。临界资源数量为1，CSa-b-c是临界区”中，三个进程并发过程中，是不是一定会发生阻塞或唤醒操作？如果mutex初值设置为0或2会有什么结果？在实际应用中，应该怎么合理的设置互斥量的初值？" class="headerlink" title="4.12 3个进程Pa,Pb,Pc 。临界资源数量为1，CSa,b,c是临界区”中，三个进程并发过程中，是不是一定会发生阻塞或唤醒操作？如果mutex初值设置为0或2会有什么结果？在实际应用中，应该怎么合理的设置互斥量的初值？"></a>4.12 3个进程Pa,Pb,Pc 。临界资源数量为1，CSa,b,c是临界区”中，三个进程并发过程中，是不是一定会发生阻塞或唤醒操作？如果mutex初值设置为0或2会有什么结果？在实际应用中，应该怎么合理的设置互斥量的初值？</h4><p>不一定。例如并发过程中，三个进程恰好是分别先后执行PV操作。设置为0的话，所有进程都无法进入临界区；设置为1的话，可以同时有两个进程进入临界区。在实际应用中，根据可最多同时进入临界区的进程个数设置互斥量初值。</p>
<h4 id="4-13-在4-5-4节“实现进程同步的例子：司机vs售票员”中，如果把两个信号量S1-S2的初值都设置为1，司机和售票员还能否正确同步？如果不能，请给出反例证明。在实际应用中，应该怎么合理的设置信号量的初值？"><a href="#4-13-在4-5-4节“实现进程同步的例子：司机vs售票员”中，如果把两个信号量S1-S2的初值都设置为1，司机和售票员还能否正确同步？如果不能，请给出反例证明。在实际应用中，应该怎么合理的设置信号量的初值？" class="headerlink" title="4.13 在4.5.4节“实现进程同步的例子：司机vs售票员”中，如果把两个信号量S1,S2的初值都设置为1，司机和售票员还能否正确同步？如果不能，请给出反例证明。在实际应用中，应该怎么合理的设置信号量的初值？"></a>4.13 在4.5.4节“实现进程同步的例子：司机vs售票员”中，如果把两个信号量S1,S2的初值都设置为1，司机和售票员还能否正确同步？如果不能，请给出反例证明。在实际应用中，应该怎么合理的设置信号量的初值？</h4><p>不能。因为会出现未关门就起步或未停车就开门的情况。在实际应用中，应根据正确的逻辑关系确定初值。如果是分属两个进程的两个步骤先后执行，应将初值设为0，如果是临界区互斥，应将初值设为1。</p>
<h4 id="4-14-编者和读者”同步问题在严格意义上讲是一个同步问题还是一个互斥问题？如果把题目的同步要求做一个加强：如果有读者和编者同时在等一个编者“写完”，则当前的“写”操作完后，等待的编者能优先进入。新的情形应当如何完成P-V同步操作？"><a href="#4-14-编者和读者”同步问题在严格意义上讲是一个同步问题还是一个互斥问题？如果把题目的同步要求做一个加强：如果有读者和编者同时在等一个编者“写完”，则当前的“写”操作完后，等待的编者能优先进入。新的情形应当如何完成P-V同步操作？" class="headerlink" title="4.14 编者和读者”同步问题在严格意义上讲是一个同步问题还是一个互斥问题？如果把题目的同步要求做一个加强：如果有读者和编者同时在等一个编者“写完”，则当前的“写”操作完后，等待的编者能优先进入。新的情形应当如何完成P-V同步操作？"></a>4.14 编者和读者”同步问题在严格意义上讲是一个同步问题还是一个互斥问题？如果把题目的同步要求做一个加强：如果有读者和编者同时在等一个编者“写完”，则当前的“写”操作完后，等待的编者能优先进入。新的情形应当如何完成P-V同步操作？</h4><p>写者优先:</p>
<p>1.写者线程的优先级高于读者线程。</p>
<p>2.当有写者到来时应该阻塞读者线程的队列。</p>
<p>3.当有一个写者正在写时或在阻塞队列时应当阻塞读者进程的读操作，直到所有写者进程完成写操作时放开读者进程。</p>
<p>4.当没有写者进程时读者进程应该能够同时读取文件。</p>
<p>具体实现:</p>
<p>1.通过添加信号量read实现写者到来时能够打断读者进程。</p>
<p>2.设置信号量fileSrc实现读写者对临界资源的访问。</p>
<p>3.设置计数器writeCount来统计当前阻塞的写者进程的数目，设置信号量writeCountSignal完成对writeCount计数器资源的互斥访问。</p>
<p>4.设置计数器readCount来统计访问临界资源的读者数目，设置信号量readCountSignal完成对readCount计数器资源的互斥访问。</p>
<h4 id="4-15-在控制台上直接启动的一个应用程序，其末尾的exit-函数返回参数由谁处理或接收？"><a href="#4-15-在控制台上直接启动的一个应用程序，其末尾的exit-函数返回参数由谁处理或接收？" class="headerlink" title="4.15 在控制台上直接启动的一个应用程序，其末尾的exit( )函数返回参数由谁处理或接收？"></a>4.15 在控制台上直接启动的一个应用程序，其末尾的exit( )函数返回参数由谁处理或接收？</h4><p>应该是init进程。init进程是系统中所有其它用户进程的祖先进程，Linux中的所有进程都是有init进程创建并运行的。首先Linux内核启动，然后在用户空间中启动init进程，再启动其他系统进程。在系统启动完成完成后，init将变为守护进程监视系统其他进程。</p>
<h4 id="4-16-举出生活中类似“司机和售票员”的同步例子，并分析其中的关键操作。"><a href="#4-16-举出生活中类似“司机和售票员”的同步例子，并分析其中的关键操作。" class="headerlink" title="4.16 举出生活中类似“司机和售票员”的同步例子，并分析其中的关键操作。"></a>4.16 举出生活中类似“司机和售票员”的同步例子，并分析其中的关键操作。</h4><p>个人理解，匿名管道实质上是有主从关系的，用来实现父进程对子进程的控制，因此是由父进程单方面的读写，子进程被动的响应。</p>
<h4 id="4-17-Linux信号机制与中断机制有什么异同？"><a href="#4-17-Linux信号机制与中断机制有什么异同？" class="headerlink" title="4.17 Linux信号机制与中断机制有什么异同？"></a>4.17 Linux信号机制与中断机制有什么异同？</h4><p>信号和中断的相似点：</p>
<p>都采用了异步通信的方式，同步就是排队，信息一个接一个的处理，异步就是插队；</p>
<p>都是暂停当前的, 去执行对应的handle程序；</p>
<p>都是处理完返回原来位置；</p>
<p>对于信号和中断, 都是可以屏蔽的。</p>
<p>信号与中断的区别：</p>
<p>中断有优先级, 信号没有；</p>
<p>信号处理程序在用户态下运行的, 中断程序在核心态下运行的；</p>
<p>中断响应是及时的, 当信号响应一般有延迟。</p>
<h3 id="单元作业"><a href="#单元作业" class="headerlink" title="单元作业"></a>单元作业</h3><h4 id="1-进程有哪4个特征？"><a href="#1-进程有哪4个特征？" class="headerlink" title="1 进程有哪4个特征？"></a>1 进程有哪4个特征？</h4><p>动态性：进程是程序的一次执行过程，动态产生和消亡；</p>
<p>并发性：进程同其他进程一起向前推进；</p>
<p>异步性：进程按各自速度向前推进；</p>
<p>独立性：进程是系统分配资源和调度CPU的单位。</p>
<h4 id="2-进程有哪3个基本状态，它们之间如何迁移？"><a href="#2-进程有哪3个基本状态，它们之间如何迁移？" class="headerlink" title="2 进程有哪3个基本状态，它们之间如何迁移？"></a>2 进程有哪3个基本状态，它们之间如何迁移？</h4><p>运行状态：进程已占有CPU，在CPU上运行；</p>
<p>就绪状态：举报运行条件但由于无CPU，暂时不能运行；</p>
<p>阻塞状态：因为等待某项服务完成或信号不能运行的状态。</p>
<p>新建的进程会进入就绪状态，根据进程调度进入运行状态，若有退出信号则进入终止状态，若需等待I/O或事件则进入阻塞状态，若时间片已到则进入就绪状态，组赛状态的进程等到I/O信号或事件信号后进入就绪状态。</p>
<h4 id="3-什么是进程控制，有哪4个典型的进程控制行为？"><a href="#3-什么是进程控制，有哪4个典型的进程控制行为？" class="headerlink" title="3 什么是进程控制，有哪4个典型的进程控制行为？"></a>3 什么是进程控制，有哪4个典型的进程控制行为？</h4><p>进程控制是指在进程生成全周期内，对其全部行为的控制。</p>
<p>四个典型控制行为包括：创建进程、阻塞进程、撤销进程和唤醒进行。</p>
<h4 id="4-什么是原语，有何特点？"><a href="#4-什么是原语，有何特点？" class="headerlink" title="4 什么是原语，有何特点？"></a>4 什么是原语，有何特点？</h4><p>原语是由若干指令构成的具有特定功能的函数。具有原子性，其操作不可分割。</p>
<h4 id="5-试述fork-函数的作用和特点？"><a href="#5-试述fork-函数的作用和特点？" class="headerlink" title="5 试述fork()函数的作用和特点？"></a>5 试述fork()函数的作用和特点？</h4><p>fork()是一个系统调用，用于创建进程。一个进程调用fork()函数后，系统先给新的进程分配资源，例如存储数据和代码的空间。新进程是当前进程的子进程，子进程是父进程的复制，子进程和父进程并发运行。</p>
<p>fork()会返回pid参数，用于判断是子进程还是父进程。pid=0，是子进程；pid&gt;0,是父进程，且值为子进程ID；pid=-1，出错。</p>
<h4 id="6-试述线程的概念（Thread）或特点？"><a href="#6-试述线程的概念（Thread）或特点？" class="headerlink" title="6 试述线程的概念（Thread）或特点？"></a>6 试述线程的概念（Thread）或特点？</h4><p>线程是可由CPU直接运行的实体；一个进程可以创建多个线程；多个线程共享CPU可以实现并发运行。</p>
<h4 id="7-试述线程有哪些典型应用场合？"><a href="#7-试述线程有哪些典型应用场合？" class="headerlink" title="7 试述线程有哪些典型应用场合？"></a>7 试述线程有哪些典型应用场合？</h4><p>1、程序需要并发运行多个功能；</p>
<p>2、需要改善窗口交互性的地方，例如用户输入、文件操作、网络操作、搜索等；</p>
<p>3、需要改善程序结构的地方，后台程序；</p>
<p>4、多核CPU上的应用，重复发挥多核性能。</p>
<h4 id="8-何为临界资源，何为临界区？"><a href="#8-何为临界资源，何为临界区？" class="headerlink" title="8 何为临界资源，何为临界区？"></a>8 何为临界资源，何为临界区？</h4><p>临界资源是指一次只允许一个进程独占访问的资源。临界区是指进程中访问临界资源的程序段。</p>
<h4 id="9-试述设计临界资源或临界区访问机制的四个原则是什么？"><a href="#9-试述设计临界资源或临界区访问机制的四个原则是什么？" class="headerlink" title="9 试述设计临界资源或临界区访问机制的四个原则是什么？"></a>9 试述设计临界资源或临界区访问机制的四个原则是什么？</h4><p>忙则等待、空闲让进、有限等待、让权等待</p>
<h4 id="10-临界区访问机制为什么要实现让权等待原则？锁机制为什么没有满足该原则？"><a href="#10-临界区访问机制为什么要实现让权等待原则？锁机制为什么没有满足该原则？" class="headerlink" title="10 临界区访问机制为什么要实现让权等待原则？锁机制为什么没有满足该原则？"></a>10 临界区访问机制为什么要实现让权等待原则？锁机制为什么没有满足该原则？</h4><p>让权等待可以让其它进程有机会得到CPU。锁机制阻止了其他进程对临界区资源的使用，且让调用该资源的进程处于阻塞状态，直到该进程调用完临界资源，执行解锁操作。</p>
<h4 id="11-什么是进程的互斥，什么是进程的同步？各举一个例子说明。"><a href="#11-什么是进程的互斥，什么是进程的同步？各举一个例子说明。" class="headerlink" title="11 什么是进程的互斥，什么是进程的同步？各举一个例子说明。"></a>11 什么是进程的互斥，什么是进程的同步？各举一个例子说明。</h4><p>进程的互斥是指多个进程由于共享了独占性资源，必须协调各进程对资源的存取顺序，确保没有两个或两个以上的进程同时进行存取操作。例如临界资源的使用。</p>
<p>进程的同步是指若干进程为了完成一个共同的任务，需要相互协调运行步伐，一个进程开始某个操作之前必须要求另一个进程已经完成某个操作，否则前面的进程只能等待。例如司机和售票员之间的操作。</p>
<h4 id="12-P-V操作的作用是什么？P操作和V操作各自的原理是什么？"><a href="#12-P-V操作的作用是什么？P操作和V操作各自的原理是什么？" class="headerlink" title="12 P-V操作的作用是什么？P操作和V操作各自的原理是什么？"></a>12 P-V操作的作用是什么？P操作和V操作各自的原理是什么？</h4><p>P-V操作为了实现信号灯进程同步机制。信号灯包含S和q两个属性，S表示信号量，q表示PCB队列。进程可以通过P-V操作改变信号灯的状态，同时进程的状态也受信号灯状态的约束。</p>
<p>P操作将S减1；若差大于等于0，该进程继续；若差小于0，则进程阻塞并加入队列q。</p>
<p>V操作将S加1；若和大于0，进程继续；若和小于等于0，该进程继续同时从q唤醒一个进程。</p>
<h4 id="13-试述P-V操作解决互斥问题的思路是什么？"><a href="#13-试述P-V操作解决互斥问题的思路是什么？" class="headerlink" title="13 试述P-V操作解决互斥问题的思路是什么？"></a>13 试述P-V操作解决互斥问题的思路是什么？</h4><p>​1、设定合适的S初值；</p>
<p>2、进入临界区前执行P操作；</p>
<p>3、离开临界区之后执行V操作。</p>
<h4 id="14-试述P-V操作解决同步问题的思路是什么？"><a href="#14-试述P-V操作解决同步问题的思路是什么？" class="headerlink" title="14 试述P-V操作解决同步问题的思路是什么？"></a>14 试述P-V操作解决同步问题的思路是什么？</h4><p>1、​定义有意义的信号量S，并设置合适的初值；</p>
<p>2、暂停进程时在关键操作前执行P操作；</p>
<p>3、继续进程时在关键操作后执行V操作。</p>
<h4 id="15-试分析“司机vs售票员”同步问题中，哪些操作是关键操作，哪些不是？为什么？"><a href="#15-试分析“司机vs售票员”同步问题中，哪些操作是关键操作，哪些不是？为什么？" class="headerlink" title="15 试分析“司机vs售票员”同步问题中，哪些操作是关键操作，哪些不是？为什么？"></a>15 试分析“司机vs售票员”同步问题中，哪些操作是关键操作，哪些不是？为什么？</h4><p>关键操作有关门、起步和停车、开门。行驶和售票不是关键操作。关键操作涉及到与其他进程的交互，非关键操作不涉及其他进程，只需满足进程内的逻辑。</p>
<h4 id="16-试分析“生产者与消费者”问题中，P-V操作是如何阻止生产者生产速度过快的，又是如何阻止消费者消费速度过快的？又是如何及时唤醒生产者去尽快生产的，又是如何及时唤醒消费者去尽快消费的？"><a href="#16-试分析“生产者与消费者”问题中，P-V操作是如何阻止生产者生产速度过快的，又是如何阻止消费者消费速度过快的？又是如何及时唤醒生产者去尽快生产的，又是如何及时唤醒消费者去尽快消费的？" class="headerlink" title="16 试分析“生产者与消费者”问题中，P-V操作是如何阻止生产者生产速度过快的，又是如何阻止消费者消费速度过快的？又是如何及时唤醒生产者去尽快生产的，又是如何及时唤醒消费者去尽快消费的？"></a>16 试分析“生产者与消费者”问题中，P-V操作是如何阻止生产者生产速度过快的，又是如何阻止消费者消费速度过快的？又是如何及时唤醒生产者去尽快生产的，又是如何及时唤醒消费者去尽快消费的？</h4><p>添加规则，不能向满缓存区存产品，不能从空缓存区取产品，当缓存区已满，生产者处于阻塞态，只有消费者可以运行，当缓存区已空，消费者处于阻塞态，只有生产者可以运行。</p>
<h4 id="17-试述Windows的信号量（Semaphore）机制的工作原理（或如何应用该机制）？"><a href="#17-试述Windows的信号量（Semaphore）机制的工作原理（或如何应用该机制）？" class="headerlink" title="17 试述Windows的信号量（Semaphore）机制的工作原理（或如何应用该机制）？"></a>17 试述Windows的信号量（Semaphore）机制的工作原理（或如何应用该机制）？</h4><p>信号量允许指定数目的多个线程或进程访问临界区，是一种资源计数器，用于限制并发线程的数量。</p>
<p>WaitForSingleObject将信号量减1，ReleaseSemaphore将信号量加1，信号量大于0为有信号状态，小于等于0为无信号状态。</p>
<h4 id="18-试述Linux中wait函数和exit函数的作用和它们之间的联系？"><a href="#18-试述Linux中wait函数和exit函数的作用和它们之间的联系？" class="headerlink" title="18 试述Linux中wait函数和exit函数的作用和它们之间的联系？"></a>18 试述Linux中wait函数和exit函数的作用和它们之间的联系？</h4><p>wait(int status)可以阻塞自己，当有子进程结束，wait收集该子进程信息并销毁该子进程后返回。</p>
<p>exit(int status)可以终止进程，利用status传递进程结束时的状态，然后变为僵尸状态，保留部分PCB信息供wait收集。</p>
<h4 id="19-试述Windows管道通信或Linux信号机制的原理（或如何应用该机制）？"><a href="#19-试述Windows管道通信或Linux信号机制的原理（或如何应用该机制）？" class="headerlink" title="19 试述Windows管道通信或Linux信号机制的原理（或如何应用该机制）？"></a>19 试述Windows管道通信或Linux信号机制的原理（或如何应用该机制）？</h4><p>管道是一种用于在进程间共享数据的机制，其实质是一段共享内存。Windows系统为这段共享的内存设计采用数据流I/0的方式来访问。由一个进程读、另一个进程写，类似于一个管道两端，因此这种进程间的通信方式称作“管道”。</p>
<p>管道分为匿名管道和命名管道：</p>
<p>匿名管道只能在父子进程间进行通信，不能在网络间通信，而且数据传输是单向的，只能一端写，另一端读，为实现双向通信，需建立两个匿名管道；</p>
<p>命令管道可以在任意进程间通信，通信是双向的，任意一端都可读可写，但是在同一时间只能有一端读、一端写。</p>
<p>匿名管道使用方法：</p>
<p>1、创建一个安全属性描述符，设置句柄可继承</p>
<p>2、创建两个管道，父读子写和子读父写</p>
<p>3、重定向输出，将子进程的读写重定向</p>
<p>4、创建子进程</p>
<p>5、读写数据给子进程</p>
<h4 id="20-阅读Linux2-6或更早早期的版本，查看task-struct结构的定义，了解每个成员变量的含义。"><a href="#20-阅读Linux2-6或更早早期的版本，查看task-struct结构的定义，了解每个成员变量的含义。" class="headerlink" title="20 阅读Linux2.6或更早早期的版本，查看task_struct结构的定义，了解每个成员变量的含义。"></a>20 阅读Linux2.6或更早早期的版本，查看task_struct结构的定义，了解每个成员变量的含义。</h4><p>state 进程状态</p>
<p>pid 进程标识符</p>
<p>tgid 线程组标识符</p>
<p>flags 进程标记符</p>
<p>real_parent 当前执行进程的父进程</p>
<p>parent 父进程</p>
<p>children 子进程</p>
<p>prio 优先级</p>
<p>mm 地址空间</p>

    </div>
</article>

</main>
</body>
</html>
