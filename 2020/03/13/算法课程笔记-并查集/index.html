
<!DOCTYPE html>
<html>

<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
    <title>welcome to qk6665&#39;blog</title>
    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>

<header class="header">
    <div class="blog-title">
        <a href="/" class="logo">welcome to qk6665&#39;blog</a>
    </div>
    <nav class="navbar">
        <ul class="menu">
            
                <li class="menu-item">
                    <a href="/" class="menu-item-link">首页</a>
                </li>
            
                <li class="menu-item">
                    <a href="/archives" class="menu-item-link">目录</a>
                </li>
            
                <li class="menu-item">
                    <a href="https://github.com/qk6665" target="_blank" rel="noopener" class="menu-item-link">GitHub</a>
                </li>
            
        </ul>
    </nav>
</header>

<main class="main">
    <article class="post">
    <div class="post-title">
        <h2 class="title">算法课程笔记-并查集</h2>
    </div>
    <div class="post-meta">
        <span class="post-time">2020-03-13</span>
    </div>
    <div class="post-content">
        <h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p>用于解决连接问题<br><img src="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%B9%B6%E6%9F%A5%E9%9B%86/1.png" alt="并查集">  </p>
<h4 id="1-树结构并查集"><a href="#1-树结构并查集" class="headerlink" title="1 树结构并查集"></a>1 树结构并查集</h4><p>初始条件下所有结点都为根节点，根节点指向自己。连接时，将一节点的根节点指向另一节点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> UF2&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span>&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">// 使用一个数组构建一棵指向父节点的树</span></span><br><span class="line">        <span class="comment">// parent[i]表示第一个元素所指向的父节点</span></span><br><span class="line">        <span class="keyword">int</span>* parent;</span><br><span class="line">        <span class="keyword">int</span> count;  <span class="comment">// 数据个数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 构造函数</span></span><br><span class="line">        UnionFind(<span class="keyword">int</span> count)&#123;</span><br><span class="line">            parent = <span class="keyword">new</span> <span class="keyword">int</span>[count];</span><br><span class="line">            <span class="keyword">this</span>-&gt;count = count;</span><br><span class="line">            <span class="comment">// 初始化, 每一个parent[i]指向自己, 表示每一个元素自己自成一个集合</span></span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; count ; i ++ )</span><br><span class="line">                parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 析构函数</span></span><br><span class="line">        ~UnionFind()&#123;</span><br><span class="line">            <span class="keyword">delete</span>[] parent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找过程, 查找元素p所对应的集合编号</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">            assert( p &gt;= <span class="number">0</span> &amp;&amp; p &lt; count );</span><br><span class="line">            <span class="comment">// 不断去查询自己的父亲节点, 直到到达根节点</span></span><br><span class="line">            <span class="comment">// 根节点的特点: parent[p] == p</span></span><br><span class="line">            <span class="keyword">while</span>( p != parent[p] )</span><br><span class="line">                p = parent[p];</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查看元素p和元素q是否所属一个集合</span></span><br><span class="line">        <span class="comment">// O(h)复杂度, h为树的高度</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">isConnected</span><span class="params">( <span class="keyword">int</span> p , <span class="keyword">int</span> q )</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">find</span>(p) == <span class="built_in">find</span>(q);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并元素p和元素q所属的集合</span></span><br><span class="line">        <span class="comment">// O(h)复杂度, h为树的高度</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">unionElements</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> pRoot = <span class="built_in">find</span>(p);</span><br><span class="line">            <span class="keyword">int</span> qRoot = <span class="built_in">find</span>(q);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( pRoot == qRoot )</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-树结构层数优化并查集"><a href="#2-树结构层数优化并查集" class="headerlink" title="2 树结构层数优化并查集"></a>2 树结构层数优化并查集</h4><p>合并时将层数较少的集合指向层数较多的集合，减少树的总层数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> UF4&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span>&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span>* rank;   <span class="comment">// rank[i]表示以i为根的集合所表示的树的层数</span></span><br><span class="line">        <span class="keyword">int</span>* parent; <span class="comment">// parent[i]表示第i个元素所指向的父节点</span></span><br><span class="line">        <span class="keyword">int</span> count;   <span class="comment">// 数据个数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 构造函数</span></span><br><span class="line">        UnionFind(<span class="keyword">int</span> count)&#123;</span><br><span class="line">            parent = <span class="keyword">new</span> <span class="keyword">int</span>[count];</span><br><span class="line">            rank = <span class="keyword">new</span> <span class="keyword">int</span>[count];</span><br><span class="line">            <span class="keyword">this</span>-&gt;count = count;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; count ; i ++ )&#123;</span><br><span class="line">                parent[i] = i;</span><br><span class="line">                rank[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 析构函数</span></span><br><span class="line">        ~UnionFind()&#123;</span><br><span class="line">            <span class="keyword">delete</span>[] parent;</span><br><span class="line">            <span class="keyword">delete</span>[] rank;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找过程, 查找元素p所对应的集合编号</span></span><br><span class="line">        <span class="comment">// O(h)复杂度, h为树的高度</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">            assert( p &gt;= <span class="number">0</span> &amp;&amp; p &lt; count );</span><br><span class="line">            <span class="comment">// 不断去查询自己的父亲节点, 直到到达根节点</span></span><br><span class="line">            <span class="comment">// 根节点的特点: parent[p] == p</span></span><br><span class="line">            <span class="keyword">while</span>( p != parent[p] )</span><br><span class="line">                p = parent[p];</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查看元素p和元素q是否所属一个集合</span></span><br><span class="line">        <span class="comment">// O(h)复杂度, h为树的高度</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">isConnected</span><span class="params">( <span class="keyword">int</span> p , <span class="keyword">int</span> q )</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">find</span>(p) == <span class="built_in">find</span>(q);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并元素p和元素q所属的集合</span></span><br><span class="line">        <span class="comment">// O(h)复杂度, h为树的高度</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">unionElements</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> pRoot = <span class="built_in">find</span>(p);</span><br><span class="line">            <span class="keyword">int</span> qRoot = <span class="built_in">find</span>(q);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( pRoot == qRoot )</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根据两个元素所在树的元素个数不同判断合并方向</span></span><br><span class="line">            <span class="comment">// 将元素个数少的集合合并到元素个数多的集合上</span></span><br><span class="line">            <span class="keyword">if</span>( rank[pRoot] &lt; rank[qRoot] )&#123;</span><br><span class="line">                parent[pRoot] = qRoot;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>( rank[qRoot] &lt; rank[pRoot])&#123;</span><br><span class="line">                parent[qRoot] = pRoot;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123; <span class="comment">// rank[pRoot] == rank[qRoot]</span></span><br><span class="line">                parent[pRoot] = qRoot;</span><br><span class="line">                rank[qRoot] += <span class="number">1</span>;   <span class="comment">// 此时, 我维护rank的值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-路径压缩并查集"><a href="#3-路径压缩并查集" class="headerlink" title="3 路径压缩并查集"></a>3 路径压缩并查集</h4><p>查找根节点时将父节点指向父节点的父节点。<br><img src="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%B9%B6%E6%9F%A5%E9%9B%86/2.png" alt="路径压缩"> </p>
<pre><code class="c++"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span>

<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;

<span class="comment">// 我们的第五版Union-Find</span>
<span class="keyword">namespace</span> UF5{

    <span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span>{</span>

    <span class="keyword">private</span>:
        <span class="comment">// rank[i]表示以i为根的集合所表示的树的层数</span>
        <span class="comment">// 在后续的代码中, 我们并不会维护rank的语意, 也就是rank的值在路径压缩的过程中, 有可能不在是树的层数值</span>
        <span class="comment">// 这也是我们的rank不叫height或者depth的原因, 他只是作为比较的一个标准</span>
        <span class="comment">// 关于这个问题，可以参考问答区：http://coding.imooc.com/learn/questiondetail/7287.html</span>
        <span class="keyword">int</span>* rank;
        <span class="keyword">int</span>* parent; <span class="comment">// parent[i]表示第i个元素所指向的父节点</span>
        <span class="keyword">int</span> count;   <span class="comment">// 数据个数</span>

    <span class="keyword">public</span>:
        <span class="comment">// 构造函数</span>
        UnionFind(<span class="keyword">int</span> count){
            parent = <span class="keyword">new</span> <span class="keyword">int</span>[count];
            rank = <span class="keyword">new</span> <span class="keyword">int</span>[count];
            <span class="keyword">this</span>-&gt;count = count;
            <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; count ; i ++ ){
                parent[i] = i;
                rank[i] = <span class="number">1</span>;
            }
        }

        <span class="comment">// 析构函数</span>
        ~UnionFind(){
            <span class="keyword">delete</span>[] parent;
            <span class="keyword">delete</span>[] rank;
        }

        <span class="comment">// 查找过程, 查找元素p所对应的集合编号</span>
        <span class="comment">// O(h)复杂度, h为树的高度</span>
        <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>{
            assert( p &gt;= <span class="number">0</span> &amp;&amp; p &lt; count );

            <span class="comment">// path compression 1</span>
            <span class="keyword">while</span>( p != parent[p] ){
                parent[p] = parent[parent[p]];
                p = parent[p];
            }
            <span class="keyword">return</span> p;

            <span class="comment">// path compression 2, 递归算法</span>
<span class="comment">//            if( p != parent[p] )</span>
<span class="comment">//                parent[p] = find( parent[p] );</span>
<span class="comment">//            return parent[p];</span>
        }

        <span class="comment">// 查看元素p和元素q是否所属一个集合</span>
        <span class="comment">// O(h)复杂度, h为树的高度</span>
        <span class="function"><span class="keyword">bool</span> <span class="title">isConnected</span><span class="params">( <span class="keyword">int</span> p , <span class="keyword">int</span> q )</span></span>{
            <span class="keyword">return</span> find(p) == find(q);
        }

        <span class="comment">// 合并元素p和元素q所属的集合</span>
        <span class="comment">// O(h)复杂度, h为树的高度</span>
        <span class="function"><span class="keyword">void</span> <span class="title">unionElements</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>{

            <span class="keyword">int</span> pRoot = find(p);
            <span class="keyword">int</span> qRoot = find(q);

            <span class="keyword">if</span>( pRoot == qRoot )
                <span class="keyword">return</span>;

            <span class="comment">// 根据两个元素所在树的元素个数不同判断合并方向</span>
            <span class="comment">// 将元素个数少的集合合并到元素个数多的集合上</span>
            <span class="keyword">if</span>( rank[pRoot] &lt; rank[qRoot] ){
                parent[pRoot] = qRoot;
            }
            <span class="keyword">else</span> <span class="keyword">if</span>( rank[qRoot] &lt; rank[pRoot]){
                parent[qRoot] = pRoot;
            }
            <span class="keyword">else</span>{ <span class="comment">// rank[pRoot] == rank[qRoot]</span>
                parent[pRoot] = qRoot;
                rank[qRoot] += <span class="number">1</span>;   <span class="comment">// 此时, 我维护rank的值</span>
            }
        }
    };
}</code></pre>

    </div>
</article>

</main>
</body>
</html>
