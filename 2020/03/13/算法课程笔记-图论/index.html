
<!DOCTYPE html>
<html>

<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
    <title>welcome to qk6665&#39;blog</title>
    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>

<header class="header">
    <div class="blog-title">
        <a href="/" class="logo">welcome to qk6665&#39;blog</a>
    </div>
    <nav class="navbar">
        <ul class="menu">
            
                <li class="menu-item">
                    <a href="/" class="menu-item-link">首页</a>
                </li>
            
                <li class="menu-item">
                    <a href="/archives" class="menu-item-link">目录</a>
                </li>
            
                <li class="menu-item">
                    <a href="https://github.com/qk6665" target="_blank" rel="noopener" class="menu-item-link">GitHub</a>
                </li>
            
        </ul>
    </nav>
</header>

<main class="main">
    <article class="post">
    <div class="post-title">
        <h2 class="title">算法课程笔记-图论</h2>
    </div>
    <div class="post-meta">
        <span class="post-time">2020-03-13</span>
    </div>
    <div class="post-content">
        <h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><p>分为无向图和有向图<br>分为有权图和无权图（边的值）<br>图的连通性<br><img src="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%9B%BE%E8%AE%BA/1.png" alt="自环边和平行边">  </p>
<h4 id="1-图的表示"><a href="#1-图的表示" class="headerlink" title="1 图的表示"></a>1 图的表示</h4><p><img src="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%9B%BE%E8%AE%BA/2.png" alt="邻接矩阵">  </p>
<p><img src="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%9B%BE%E8%AE%BA/3.png" alt="邻接表1"><br><img src="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%9B%BE%E8%AE%BA/4.png" alt="邻接表2">  </p>
<p>邻接矩阵适合表示稠密图，邻接表适合表示稀疏图。稠密与稀疏取决于边（edge）的数量。</p>
<h4 id="2-深度优先遍历（dfs）与连通分量（Components）"><a href="#2-深度优先遍历（dfs）与连通分量（Components）" class="headerlink" title="2 深度优先遍历（dfs）与连通分量（Components）"></a>2 深度优先遍历（dfs）与连通分量（Components）</h4><p>深度优先遍历与树的遍历类似，但需要记录该节点是否遍历过<br><img src="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%9B%BE%E8%AE%BA/5.png" alt="连通分量"> </p>
<h4 id="3-寻路"><a href="#3-寻路" class="headerlink" title="3 寻路"></a>3 寻路</h4><p>与dfs相似</p>
<h4 id="4-广度优先遍历（bfs）与最短路径"><a href="#4-广度优先遍历（bfs）与最短路径" class="headerlink" title="4 广度优先遍历（bfs）与最短路径"></a>4 广度优先遍历（bfs）与最短路径</h4><p>广度优先遍历与树的层序遍历类似，利用队列，一个节点出队，将所有相连节点加入队列，需要记录该节点是否遍历过。<br>广度优先遍历的特点在于先遍历的元素距离起点近（无权图）。</p>
<h4 id="5-有权图（weighted-graph）"><a href="#5-有权图（weighted-graph）" class="headerlink" title="5 有权图（weighted graph）"></a>5 有权图（weighted graph）</h4><p><img src="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%9B%BE%E8%AE%BA/6.png" alt="有权图"><br><img src="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%9B%BE%E8%AE%BA/7.png" alt="有权图邻接矩阵"><br><img src="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%9B%BE%E8%AE%BA/8.png" alt="有权图邻接表">  </p>
<h4 id="6-最小生成树和切分定理（cut-property）"><a href="#6-最小生成树和切分定理（cut-property）" class="headerlink" title="6 最小生成树和切分定理（cut property）"></a>6 最小生成树和切分定理（cut property）</h4><p>n-1条边连接了n个节点，称为生成树。若总权值最小，称为最小生成树。<br>将图进行切分，边的两个节点分属两半称为横切边。<br>切分定理：对于任意切分，横切边中权值最小的边属于最小生成树。  </p>
<h4 id="7-prim算法"><a href="#7-prim算法" class="headerlink" title="7 prim算法"></a>7 prim算法</h4><p><img src="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%9B%BE%E8%AE%BA/9.png" alt="有权图邻接表">  </p>
<h4 id="8-kruskal算法"><a href="#8-kruskal算法" class="headerlink" title="8 kruskal算法"></a>8 kruskal算法</h4><h4 id="9-最短路径问题与松弛操作（relaxation）"><a href="#9-最短路径问题与松弛操作（relaxation）" class="headerlink" title="9 最短路径问题与松弛操作（relaxation）"></a>9 最短路径问题与松弛操作（relaxation）</h4><p>松弛操作是最短路径问题的核心。</p>
<h4 id="10-dijkstra算法"><a href="#10-dijkstra算法" class="headerlink" title="10 dijkstra算法"></a>10 dijkstra算法</h4><p>前提：没有负权边。<br><img src="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%9B%BE%E8%AE%BA/10.png" alt="dijkstra算法"><br>如图所示，0到2的路径最短，因此0到2的最短路径可以确定为2。  </p>
<p><img src="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%9B%BE%E8%AE%BA/11.png" alt="dijkstra算法"><br>如图所示，2到1的距离是1，则0到1的最短距离更新为3，距离为5的边被废弃，这一操作为松弛操作。  </p>
<p>通过上述两种操作，可得到如下结果。<br><img src="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%9B%BE%E8%AE%BA/12.png" alt="dijkstra算法">   </p>
<h4 id="11-负权边与bellman-ford算法"><a href="#11-负权边与bellman-ford算法" class="headerlink" title="11 负权边与bellman-ford算法"></a>11 负权边与bellman-ford算法</h4><p>如果有负权环，则没有最短路径。<br>bellman-ford算法可解决负权边最短路径问题。<br>最短路径最多经过n个节点，否则就有负权环。<br>一个点的一次松弛操作就是找到经过这个点的另外一条路径，多一条边，权值更小。从一点到另外一点最多有n-1条边。对所有的点进行n-1次松弛操作，找到最短路径。如果n-1次松弛操作后还可以继续松弛，则有负权环。  </p>
<h4 id="12-拓扑排序"><a href="#12-拓扑排序" class="headerlink" title="12 拓扑排序"></a>12 拓扑排序</h4><p>用于有向无环图</p>
<h4 id="13-课程用到的算法思想"><a href="#13-课程用到的算法思想" class="headerlink" title="13 课程用到的算法思想"></a>13 课程用到的算法思想</h4><p><img src="/2020/03/13/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%9B%BE%E8%AE%BA/13.png" alt="总结">  </p>

    </div>
</article>

</main>
</body>
</html>
